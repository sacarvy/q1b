exports.id = 708;
exports.ids = [708];
exports.modules = {

/***/ 69797:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({
    value: true
});
exports.N = void 0;
var invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im;
var htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g;
var htmlCtrlEntityRegex = /&(newline|tab);/gi;
var ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim;
var urlSchemeRegex = /^.+(:|&colon;)/gim;
var relativeFirstCharacters = [
    ".",
    "/"
];
function isRelativeUrlWithoutProtocol(url) {
    return relativeFirstCharacters.indexOf(url[0]) > -1;
}
// adapted from https://stackoverflow.com/a/29824550/2601552
function decodeHtmlCharacters(str) {
    return str.replace(htmlEntitiesRegex, function(match, dec) {
        return String.fromCharCode(dec);
    });
}
function sanitizeUrl(url) {
    var sanitizedUrl = decodeHtmlCharacters(url || "").replace(htmlCtrlEntityRegex, "").replace(ctrlCharactersRegex, "").trim();
    if (!sanitizedUrl) {
        return "about:blank";
    }
    if (isRelativeUrlWithoutProtocol(sanitizedUrl)) {
        return sanitizedUrl;
    }
    var urlSchemeParseResults = sanitizedUrl.match(urlSchemeRegex);
    if (!urlSchemeParseResults) {
        return sanitizedUrl;
    }
    var urlScheme = urlSchemeParseResults[0];
    if (invalidProtocolRegex.test(urlScheme)) {
        return "about:blank";
    }
    return sanitizedUrl;
}
exports.N = sanitizeUrl;


/***/ }),

/***/ 69286:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   X: () => (/* binding */ e0)
/* harmony export */ });
/* unused harmony export CheckboxGroup */
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21572);

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/sukhpreetsingh/apps/q1b-v2/node_modules/@keystar/ui/checkbox/dist/keystar-ui-checkbox.esm.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = proxy["Checkbox"];

const e1 = proxy["CheckboxGroup"];


/***/ }),

/***/ 57646:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   xv: () => (/* binding */ e4)
/* harmony export */ });
/* unused harmony exports Emoji, Heading, Kbd, Numeral, textClassList, useHeadingContext, useTextContext, useTextStyles */
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21572);

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/sukhpreetsingh/apps/q1b-v2/node_modules/@keystar/ui/typography/dist/keystar-ui-typography.esm.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = proxy["Emoji"];

const e1 = proxy["Heading"];

const e2 = proxy["Kbd"];

const e3 = proxy["Numeral"];

const e4 = proxy["Text"];

const e5 = proxy["textClassList"];

const e6 = proxy["useHeadingContext"];

const e7 = proxy["useTextContext"];

const e8 = proxy["useTextStyles"];


/***/ }),

/***/ 79646:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   F: () => (/* binding */ FieldDataError)
/* harmony export */ });
class FieldDataError extends Error {
    constructor(message){
        super(message);
        this.name = "FieldDataError";
    }
}



/***/ }),

/***/ 77619:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  d: () => (/* binding */ index_36a0dcb1_node_react_server_esm_document),
  g: () => (/* binding */ getValueAtPropPath),
  i: () => (/* binding */ index_36a0dcb1_node_react_server_esm_image)
});

// UNUSED EXPORTS: _, a, b, c, e, f, h, j, k, l, m, n, s

// EXTERNAL MODULE: ../node_modules/@markdoc/markdoc/dist/index.js
var dist = __webpack_require__(70212);
var dist_default = /*#__PURE__*/__webpack_require__.n(dist);
// EXTERNAL MODULE: ../node_modules/slate/dist/index.js
var slate_dist = __webpack_require__(7859);
// EXTERNAL MODULE: ../node_modules/emery/assertions/dist/emery-assertions.cjs.js
var emery_assertions_cjs = __webpack_require__(42220);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/initial-values-25bf35f4.node.react-server.esm.js
var initial_values_25bf35f4_node_react_server_esm = __webpack_require__(26136);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/utils-677addd9.node.react-server.esm.js
var utils_677addd9_node_react_server_esm = __webpack_require__(32186);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/error-ca8f88e5.node.react-server.esm.js
var error_ca8f88e5_node_react_server_esm = __webpack_require__(79646);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/utils-ff285f26.node.react-server.esm.js
var utils_ff285f26_node_react_server_esm = __webpack_require__(33794);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/ui-32b334fd.node.react-server.esm.js
var ui_32b334fd_node_react_server_esm = __webpack_require__(90253);
// EXTERNAL MODULE: external "next/dist/compiled/react/jsx-runtime"
var jsx_runtime_ = __webpack_require__(56786);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/index-7a5cd0db.node.react-server.esm.js
var index_7a5cd0db_node_react_server_esm = __webpack_require__(32159);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/ui-1f1aa184.node.react-server.esm.js
var ui_1f1aa184_node_react_server_esm = __webpack_require__(63688);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/utils-2bbfbd32.node.react-server.esm.js
var utils_2bbfbd32_node_react_server_esm = __webpack_require__(91001);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/languages-14058067.node.react-server.esm.js
var languages_14058067_node_react_server_esm = __webpack_require__(94438);
// EXTERNAL MODULE: ../node_modules/emery/dist/emery.cjs.js
var emery_cjs = __webpack_require__(45603);
;// CONCATENATED MODULE: ../node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js
var weakMemoize = function weakMemoize(func) {
    // $FlowFixMe flow doesn't include all non-primitive types as allowed for weakmaps
    var cache = new WeakMap();
    return function(arg) {
        if (cache.has(arg)) {
            // $FlowFixMe
            return cache.get(arg);
        }
        var ret = func(arg);
        cache.set(arg, ret);
        return ret;
    };
};


;// CONCATENATED MODULE: ../node_modules/@keystatic/core/dist/index-36a0dcb1.node.react-server.esm.js















function getValueAtPropPath(value, inputPath) {
    const path = [
        ...inputPath
    ];
    while(path.length){
        const key = path.shift();
        value = value[key];
    }
    return value;
}
function traverseProps(schema, value, visitor) {
    let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    if (schema.kind === "form" || schema.kind === "child") {
        visitor(schema, value, path);
        return;
    }
    if (schema.kind === "object") {
        for (const [key, childProp] of Object.entries(schema.fields)){
            traverseProps(childProp, value[key], visitor, [
                ...path,
                key
            ]);
        }
        visitor(schema, value, path);
        return;
    }
    if (schema.kind === "array") {
        for (const [idx, val] of value.entries()){
            traverseProps(schema.element, val, visitor, path.concat(idx));
        }
        return visitor(schema, value, path);
    }
    if (schema.kind === "conditional") {
        const discriminant = value.discriminant;
        visitor(schema, discriminant, path.concat("discriminant"));
        traverseProps(schema.values[discriminant.toString()], value.value, visitor, path.concat("value"));
        visitor(schema, value, path);
        return;
    }
    (0,emery_assertions_cjs.assertNever)(schema);
}
function transformProps(schema, value, visitors) {
    let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    if (schema.kind === "form" || schema.kind === "child") {
        if (visitors[schema.kind]) {
            return visitors[schema.kind](schema, value, path);
        }
        return value;
    }
    if (schema.kind === "object") {
        const val = Object.fromEntries(Object.entries(schema.fields).map((_ref)=>{
            let [key, val] = _ref;
            return [
                key,
                transformProps(val, value[key], visitors, [
                    ...path,
                    key
                ])
            ];
        }));
        if (visitors.object) {
            return visitors[schema.kind](schema, val, path);
        }
        return val;
    }
    if (schema.kind === "array") {
        const val = value.map((val, idx)=>transformProps(schema.element, val, visitors, path.concat(idx)));
        if (visitors.array) {
            return visitors[schema.kind](schema, val, path);
        }
        return val;
    }
    if (schema.kind === "conditional") {
        const discriminant = transformProps(schema.discriminant, value.discriminant, visitors, path.concat("discriminant"));
        const conditionalVal = transformProps(schema.values[discriminant.toString()], value.value, visitors, path.concat("value"));
        const val = {
            discriminant,
            value: conditionalVal
        };
        if (visitors.conditional) {
            return visitors[schema.kind](schema, val, path);
        }
        return val;
    }
    (0,emery_assertions_cjs.assertNever)(schema);
}
function replaceValueAtPropPath(schema, value, newValue, path) {
    if (path.length === 0) {
        return newValue;
    }
    const [key, ...newPath] = path;
    if (schema.kind === "object") {
        return {
            ...value,
            [key]: replaceValueAtPropPath(schema.fields[key], value[key], newValue, newPath)
        };
    }
    if (schema.kind === "conditional") {
        const conditionalValue = value;
        // replaceValueAtPropPath should not be used to only update the discriminant of a conditional field
        // if you want to update the discriminant of a conditional field, replace the value of the whole conditional field
        (0,emery_assertions_cjs.assert)(key === "value");
        return {
            discriminant: conditionalValue.discriminant,
            value: replaceValueAtPropPath(schema.values[key], conditionalValue.value, newValue, newPath)
        };
    }
    if (schema.kind === "array") {
        const prevVal = value;
        const newVal = [
            ...prevVal
        ];
        (0,initial_values_25bf35f4_node_react_server_esm.s)(newVal, (0,initial_values_25bf35f4_node_react_server_esm.a)(prevVal));
        newVal[key] = replaceValueAtPropPath(schema.element, newVal[key], newValue, newPath);
        return newVal;
    }
    // we should never reach here since form or child fields don't contain other fields
    // so the only thing that can happen to them is to be replaced which happens at the start of this function when path.length === 0
    (0,emery_assertions_cjs.assert)(schema.kind !== "form" && schema.kind !== "child");
    (0,emery_assertions_cjs.assertNever)(schema);
}
// a v important note
// marks in the markdown ast/html are represented quite differently to how they are in slate
// if you had the markdown **something https://keystonejs.com something**
// the bold node is the parent of the link node
// but in slate, marks are only represented on text nodes
const currentlyActiveMarks = new Set();
const currentlyDisabledMarks = new Set();
let currentLink = null;
function addMarkToChildren(mark, cb) {
    const wasPreviouslyActive = currentlyActiveMarks.has(mark);
    currentlyActiveMarks.add(mark);
    try {
        return cb();
    } finally{
        if (!wasPreviouslyActive) {
            currentlyActiveMarks.delete(mark);
        }
    }
}
function setLinkForChildren(href, cb) {
    // we'll only use the outer link
    if (currentLink !== null) {
        return cb();
    }
    currentLink = href;
    try {
        return cb();
    } finally{
        currentLink = null;
    }
}
function addMarksToChildren(marks, cb) {
    const marksToRemove = new Set();
    for (const mark of marks){
        if (!currentlyActiveMarks.has(mark)) {
            marksToRemove.add(mark);
        }
        currentlyActiveMarks.add(mark);
    }
    try {
        return cb();
    } finally{
        for (const mark of marksToRemove){
            currentlyActiveMarks.delete(mark);
        }
    }
}
function forceDisableMarkForChildren(mark, cb) {
    const wasPreviouslyDisabled = currentlyDisabledMarks.has(mark);
    currentlyDisabledMarks.add(mark);
    try {
        return cb();
    } finally{
        if (!wasPreviouslyDisabled) {
            currentlyDisabledMarks.delete(mark);
        }
    }
}
/**
 * This type is more strict than `Element & { type: 'link'; }` because `children`
 * is constrained to only contain Text nodes. This can't be assumed generally around the editor
 * (because of potentially future inline components or nested links(which are normalized away but the editor needs to not break if it happens))
 * but where this type is used, we're only going to allow links to contain Text and that's important
 * so that we know a block will never be inside an inline because Slate gets unhappy when that happens
 * (really the link inline should probably be a mark rather than an inline,
 * non-void inlines are probably always bad but that would imply changing the document
 * structure which would be such unnecessary breakage)
 */ function getInlineNodes(text) {
    const node = {
        text
    };
    for (const mark of currentlyActiveMarks){
        if (!currentlyDisabledMarks.has(mark)) {
            node[mark] = true;
        }
    }
    if (currentLink !== null) {
        return [
            {
                text: ""
            },
            {
                type: "link",
                href: currentLink,
                children: [
                    node
                ]
            },
            {
                text: ""
            }
        ];
    }
    return [
        node
    ];
}
class VariableChildFields extends Error {
    constructor(){
        super("There are a variable number of child fields");
    }
}
function findSingleChildField(schema) {
    try {
        const result = _findConstantChildFields(schema, [], new Set());
        if (result.length === 1) {
            return result[0];
        }
        return;
    } catch (err) {
        if (err instanceof VariableChildFields) {
            return;
        }
        throw err;
    }
}
function _findConstantChildFields(schema, path, seenSchemas) {
    if (seenSchemas.has(schema)) {
        return [];
    }
    seenSchemas.add(schema);
    switch(schema.kind){
        case "form":
            return [];
        case "child":
            return [
                {
                    relativePath: path,
                    options: schema.options,
                    kind: "child"
                }
            ];
        case "conditional":
            {
                if (couldContainChildField(schema)) {
                    throw new VariableChildFields();
                }
                return [];
            }
        case "array":
            {
                if (schema.asChildTag) {
                    const child = _findConstantChildFields(schema.element, [], seenSchemas);
                    if (child.length > 1) {
                        return [];
                    }
                    return [
                        {
                            kind: "array",
                            asChildTag: schema.asChildTag,
                            field: schema,
                            relativePath: path,
                            child: child[0]
                        }
                    ];
                }
                if (couldContainChildField(schema)) {
                    throw new VariableChildFields();
                }
                return [];
            }
        case "object":
            {
                const paths = [];
                for (const [key, value] of Object.entries(schema.fields)){
                    paths.push(..._findConstantChildFields(value, path.concat(key), seenSchemas));
                }
                return paths;
            }
    }
}
function couldContainChildField(schema) {
    let seen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
    if (seen.has(schema)) {
        return false;
    }
    seen.add(schema);
    switch(schema.kind){
        case "form":
            return false;
        case "child":
            return true;
        case "conditional":
            return Object.values(schema.values).some((value)=>couldContainChildField(value, seen));
        case "object":
            return Object.keys(schema.fields).some((key)=>couldContainChildField(schema.fields[key], seen));
        case "array":
            return couldContainChildField(schema.element, seen);
    }
}
function inlineNodeFromMarkdoc(node) {
    if (node.type === "inline") {
        return inlineChildrenFromMarkdoc(node.children);
    }
    if (node.type === "link") {
        return setLinkForChildren(node.attributes.href, ()=>inlineChildrenFromMarkdoc(node.children));
    }
    if (node.type === "text") {
        return getInlineNodes(node.attributes.content);
    }
    if (node.type === "strong") {
        return addMarkToChildren("bold", ()=>inlineChildrenFromMarkdoc(node.children));
    }
    if (node.type === "code") {
        return addMarkToChildren("code", ()=>[
                {
                    text: node.attributes.content,
                    code: true
                }
            ]);
    }
    if (node.type === "em") {
        return addMarkToChildren("italic", ()=>inlineChildrenFromMarkdoc(node.children));
    }
    if (node.type === "s") {
        return addMarkToChildren("strikethrough", ()=>inlineChildrenFromMarkdoc(node.children));
    }
    if (node.type === "tag") {
        if (node.tag === "u") {
            return addMarkToChildren("underline", ()=>inlineChildrenFromMarkdoc(node.children));
        }
        if (node.tag === "kbd") {
            return addMarkToChildren("keyboard", ()=>inlineChildrenFromMarkdoc(node.children));
        }
        if (node.tag === "sub") {
            return addMarkToChildren("subscript", ()=>inlineChildrenFromMarkdoc(node.children));
        }
        if (node.tag === "sup") {
            return addMarkToChildren("superscript", ()=>inlineChildrenFromMarkdoc(node.children));
        }
    }
    if (node.type === "softbreak") {
        return getInlineNodes(" ");
    }
    if (node.type === "hardbreak") {
        return getInlineNodes("\n");
    }
    if (node.tag === "component-inline-prop" && Array.isArray(node.attributes.propPath) && node.attributes.propPath.every((x)=>typeof x === "string" || typeof x === "number")) {
        return {
            type: "component-inline-prop",
            children: inlineFromMarkdoc(node.children),
            propPath: node.attributes.propPath
        };
    }
    throw new Error(`Unknown inline node type: ${node.type}`);
}
function inlineChildrenFromMarkdoc(nodes) {
    return nodes.flatMap(inlineNodeFromMarkdoc);
}
function inlineFromMarkdoc(nodes) {
    const transformedNodes = nodes.flatMap(inlineNodeFromMarkdoc);
    const nextNodes = [];
    let lastNode;
    for (const [idx, node] of transformedNodes.entries()){
        var _lastNode;
        if (node.type === undefined && node.text === "" && ((_lastNode = lastNode) === null || _lastNode === void 0 ? void 0 : _lastNode.type) === undefined && idx !== transformedNodes.length - 1) {
            continue;
        }
        nextNodes.push(node);
        lastNode = node;
    }
    if (!nextNodes.length) {
        nextNodes.push({
            text: ""
        });
    }
    return nextNodes;
}
function fromMarkdoc(node, componentBlocks) {
    const nodes = node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks));
    if (nodes.length === 0) {
        return [
            {
                type: "paragraph",
                children: [
                    {
                        text: ""
                    }
                ]
            }
        ];
    }
    if (nodes[nodes.length - 1].type !== "paragraph") {
        nodes.push({
            type: "paragraph",
            children: [
                {
                    text: ""
                }
            ]
        });
    }
    return nodes;
}
function fromMarkdocNode(node, componentBlocks) {
    if (node.type === "blockquote") {
        return {
            type: "blockquote",
            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))
        };
    }
    if (node.type === "fence") {
        const { language, content, ...rest } = node.attributes;
        return {
            type: "code",
            children: [
                {
                    text: content.replace(/\n$/, "")
                }
            ],
            ...typeof language === "string" ? {
                language
            } : {},
            ...rest
        };
    }
    if (node.type === "heading") {
        return {
            ...node.attributes,
            level: node.attributes.level,
            type: "heading",
            children: inlineFromMarkdoc(node.children)
        };
    }
    if (node.type === "list") {
        return {
            type: node.attributes.ordered ? "ordered-list" : "unordered-list",
            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))
        };
    }
    if (node.type === "item") {
        var _node$children$;
        const children = [
            {
                type: "list-item-content",
                children: inlineFromMarkdoc([
                    node.children[0]
                ])
            }
        ];
        if (((_node$children$ = node.children[1]) === null || _node$children$ === void 0 ? void 0 : _node$children$.type) === "list") {
            const list = node.children[1];
            children.push({
                type: list.attributes.ordered ? "ordered-list" : "unordered-list",
                children: list.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))
            });
        }
        return {
            type: "list-item",
            children
        };
    }
    if (node.type === "paragraph") {
        if (node.children.length === 1 && node.children[0].type === "inline" && node.children[0].children.length === 1 && node.children[0].children[0].type === "image") {
            var _image$attributes$tit;
            const image = node.children[0].children[0];
            return {
                type: "image",
                src: decodeURI(image.attributes.src),
                alt: image.attributes.alt,
                title: (_image$attributes$tit = image.attributes.title) !== null && _image$attributes$tit !== void 0 ? _image$attributes$tit : "",
                children: [
                    {
                        text: ""
                    }
                ]
            };
        }
        const children = inlineFromMarkdoc(node.children);
        if (children.length === 1 && children[0].type === "component-inline-prop") {
            return children[0];
        }
        return {
            type: "paragraph",
            children,
            textAlign: node.attributes.textAlign
        };
    }
    if (node.type === "hr") {
        return {
            type: "divider",
            children: [
                {
                    text: ""
                }
            ]
        };
    }
    if (node.type === "table") {
        return {
            type: "table",
            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))
        };
    }
    if (node.type === "tbody") {
        return {
            type: "table-body",
            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))
        };
    }
    if (node.type === "thead") {
        if (!node.children.length) return [];
        return {
            type: "table-head",
            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))
        };
    }
    if (node.type === "tr") {
        return {
            type: "table-row",
            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))
        };
    }
    if (node.type === "td") {
        return {
            type: "table-cell",
            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))
        };
    }
    if (node.type === "th") {
        return {
            type: "table-cell",
            header: true,
            children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))
        };
    }
    if (node.type === "tag") {
        if (node.tag === "table") {
            return fromMarkdocNode(node.children[0], componentBlocks);
        }
        if (node.tag === "layout") {
            return {
                type: "layout",
                layout: node.attributes.layout,
                children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))
            };
        }
        if (node.tag === "layout-area") {
            return {
                type: "layout-area",
                children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))
            };
        }
        if (node.tag === "component-block") {
            return {
                type: "component-block",
                component: node.attributes.component,
                props: node.attributes.props,
                children: node.children.length === 0 ? [
                    {
                        type: "component-inline-prop",
                        children: [
                            {
                                text: ""
                            }
                        ]
                    }
                ] : node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))
            };
        }
        if (node.tag === "component-block-prop" && Array.isArray(node.attributes.propPath) && node.attributes.propPath.every((x)=>typeof x === "string" || typeof x === "number")) {
            return {
                type: "component-block-prop",
                children: node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks)),
                propPath: node.attributes.propPath
            };
        }
        if (node.tag) {
            const componentBlock = componentBlocks[node.tag];
            if (componentBlock) {
                const singleChildField = findSingleChildField({
                    kind: "object",
                    fields: componentBlock.schema
                });
                if (singleChildField) {
                    const newAttributes = JSON.parse(JSON.stringify(node.attributes));
                    const children = [];
                    toChildrenAndProps$1(node.children, children, newAttributes, singleChildField, [], componentBlocks);
                    return {
                        type: "component-block",
                        component: node.tag,
                        props: newAttributes,
                        children
                    };
                }
                return {
                    type: "component-block",
                    component: node.tag,
                    props: node.attributes,
                    children: node.children.length === 0 ? [
                        {
                            type: "component-inline-prop",
                            children: [
                                {
                                    text: ""
                                }
                            ]
                        }
                    ] : node.children.flatMap((x)=>fromMarkdocNode(x, componentBlocks))
                };
            }
        }
        throw new Error(`Unknown tag: ${node.tag}`);
    }
    return inlineNodeFromMarkdoc(node);
}
function toChildrenAndProps$1(fromMarkdoc, resultingChildren, value, singleChildField, parentPropPath, componentBlocks) {
    if (singleChildField.kind === "child") {
        const children = fromMarkdoc.flatMap((x)=>fromMarkdocNode(x, componentBlocks));
        resultingChildren.push({
            type: `component-${singleChildField.options.kind}-prop`,
            propPath: [
                ...parentPropPath,
                ...singleChildField.relativePath
            ],
            children
        });
    }
    if (singleChildField.kind === "array") {
        const arr = [];
        for (let [idx, child] of fromMarkdoc.entries()){
            if (child.type === "paragraph") {
                child = child.children[0].children[0];
            }
            if (child.type !== "tag") {
                throw new Error(`expected tag ${singleChildField.asChildTag}, found type: ${child.type}`);
            }
            if (child.tag !== singleChildField.asChildTag) {
                throw new Error(`expected tag ${singleChildField.asChildTag}, found tag: ${child.tag}`);
            }
            const attributes = JSON.parse(JSON.stringify(child.attributes));
            if (singleChildField.child) {
                toChildrenAndProps$1(child.children, resultingChildren, attributes, singleChildField.child, [
                    ...parentPropPath,
                    ...singleChildField.relativePath,
                    idx
                ], componentBlocks);
            }
            arr.push(attributes);
        }
        const key = singleChildField.relativePath[singleChildField.relativePath.length - 1];
        const parent = getValueAtPropPath(value, singleChildField.relativePath.slice(0, -1));
        parent[key] = arr;
    }
}
function areArraysEqual(a, b) {
    return a.length === b.length && a.every((x, i)=>x === b[i]);
}
function normalizeTextBasedOnInlineMarksAndSoftBreaks(_ref, editor, inlineMarks, softBreaks) {
    let [node, path] = _ref;
    const marksToRemove = Object.keys(node).filter((x)=>x !== "text" && x !== "insertMenu" && inlineMarks[x] !== true);
    if (marksToRemove.length) {
        slate_dist/* Transforms */.YR.unsetNodes(editor, marksToRemove, {
            at: path
        });
        return true;
    }
    if (!softBreaks) {
        const hasSoftBreaks = node.text.includes("\n");
        if (hasSoftBreaks) {
            const [parentNode] = slate_dist/* Editor */.ML.parent(editor, path);
            if (parentNode.type !== "code") {
                for (const position of slate_dist/* Editor */.ML.positions(editor, {
                    at: path
                })){
                    const character = slate_dist/* Node */.NB.get(editor, position.path).text[position.offset];
                    if (character === "\n") {
                        slate_dist/* Transforms */.YR.delete(editor, {
                            at: position
                        });
                        return true;
                    }
                }
            }
        }
    }
    return false;
}
function normalizeInlineBasedOnLinks(_ref2, editor, links) {
    let [node, path] = _ref2;
    if (node.type === "link" && !links) {
        slate_dist/* Transforms */.YR.insertText(editor, ` (${node.href})`, {
            at: slate_dist/* Editor */.ML.end(editor, path)
        });
        slate_dist/* Transforms */.YR.unwrapNodes(editor, {
            at: path
        });
        return true;
    }
    return false;
}
function normalizeElementBasedOnDocumentFeatures(_ref3, editor, _ref4) {
    let [node, path] = _ref3;
    let { formatting, dividers, layouts, links, images, tables } = _ref4;
    if (node.type === "heading" && (!formatting.headings.levels.length || !formatting.headings.levels.includes(node.level)) || node.type === "ordered-list" && !formatting.listTypes.ordered || node.type === "unordered-list" && !formatting.listTypes.unordered || node.type === "code" && !formatting.blockTypes.code || node.type === "blockquote" && !formatting.blockTypes.blockquote || node.type === "image" && !images || node.type === "table" && !tables || node.type === "layout" && (layouts.length === 0 || !layouts.some((layout)=>areArraysEqual(layout, node.layout)))) {
        slate_dist/* Transforms */.YR.unwrapNodes(editor, {
            at: path
        });
        return true;
    }
    if ((node.type === "paragraph" || node.type === "heading") && (!formatting.alignment.center && node.textAlign === "center" || !formatting.alignment.end && node.textAlign === "end" || "textAlign" in node && node.textAlign !== "center" && node.textAlign !== "end")) {
        slate_dist/* Transforms */.YR.unsetNodes(editor, "textAlign", {
            at: path
        });
        return true;
    }
    if (node.type === "divider" && !dividers) {
        slate_dist/* Transforms */.YR.removeNodes(editor, {
            at: path
        });
        return true;
    }
    return normalizeInlineBasedOnLinks([
        node,
        path
    ], editor, links);
}
function withDocumentFeaturesNormalization(documentFeatures, editor) {
    const { normalizeNode } = editor;
    editor.normalizeNode = (_ref5)=>{
        let [node, path] = _ref5;
        if (slate_dist/* Text */.xv.isText(node)) {
            normalizeTextBasedOnInlineMarksAndSoftBreaks([
                node,
                path
            ], editor, documentFeatures.formatting.inlineMarks, documentFeatures.formatting.softBreaks);
        } else if (slate_dist/* Element */.W_.isElement(node)) {
            normalizeElementBasedOnDocumentFeatures([
                node,
                path
            ], editor, documentFeatures);
        }
        normalizeNode([
            node,
            path
        ]);
    };
    return editor;
}
function index_36a0dcb1_node_react_server_esm_image(_ref) {
    let { label, directory, validation, description, publicPath } = _ref;
    return {
        kind: "form",
        formKind: "asset",
        Input (props) {
            return /*#__PURE__*/ (0,jsx_runtime_.jsx)(ui_32b334fd_node_react_server_esm/* ImageFieldInput */.Sd, {
                label: label,
                description: description,
                validation: validation,
                ...props
            });
        },
        defaultValue () {
            return null;
        },
        filename (value, args) {
            if (typeof value === "string") {
                return value.slice(getSrcPrefix(publicPath, args.slug).length);
            }
            return undefined;
        },
        parse (value, args) {
            var _value$match$, _value$match;
            if (value === undefined) {
                return null;
            }
            if (typeof value !== "string") {
                throw new error_ca8f88e5_node_react_server_esm.F("Must be a string");
            }
            if (args.asset === undefined) {
                return null;
            }
            return {
                data: args.asset,
                filename: value.slice(getSrcPrefix(publicPath, args.slug).length),
                extension: (_value$match$ = (_value$match = value.match(/\.([^.]+$)/)) === null || _value$match === void 0 ? void 0 : _value$match[1]) !== null && _value$match$ !== void 0 ? _value$match$ : ""
            };
        },
        validate (value) {
            (0,utils_ff285f26_node_react_server_esm.a)(value, validation, label);
            return value;
        },
        serialize (value, args) {
            if (value === null) {
                return {
                    value: undefined,
                    asset: undefined
                };
            }
            const filename = args.suggestedFilenamePrefix ? args.suggestedFilenamePrefix + "." + value.extension : value.filename;
            return {
                value: `${getSrcPrefix(publicPath, args.slug)}${filename}`,
                asset: {
                    filename,
                    content: value.data
                }
            };
        },
        directory: directory ? (0,utils_677addd9_node_react_server_esm.A)(directory) : undefined,
        reader: {
            parse (value) {
                if (typeof value !== "string" && value !== undefined) {
                    throw new error_ca8f88e5_node_react_server_esm.F("Must be a string");
                }
                const val = value === undefined ? null : value;
                (0,utils_ff285f26_node_react_server_esm.a)(val, validation, label);
                return val;
            }
        }
    };
}
function getSrcPrefix(publicPath, slug) {
    return typeof publicPath === "string" ? `/${(0,utils_677addd9_node_react_server_esm.A)(publicPath)}/${slug === undefined ? "" : slug + "/"}` : "";
}
function deserializeFiles(nodes, componentBlocks, files, otherFiles, mode, documentFeatures, slug) {
    return nodes.map((node)=>{
        if (node.type === "component-block") {
            const componentBlock = componentBlocks[node.component];
            if (!componentBlock) return node;
            const schema = (0,utils_677addd9_node_react_server_esm.o)(componentBlock.schema);
            return {
                ...node,
                props: deserializeProps(schema, node.props, files, otherFiles, mode, slug)
            };
        }
        if (node.type === "image" && typeof node.src === "string" && mode === "edit") {
            var _ref;
            const prefix = getSrcPrefixForImageBlock(documentFeatures, slug);
            const filename = node.src.slice(prefix.length);
            const content = (_ref = typeof documentFeatures.images === "object" && typeof documentFeatures.images.directory === "string" ? otherFiles.get((0,utils_677addd9_node_react_server_esm.A)(documentFeatures.images.directory)) : files) === null || _ref === void 0 ? void 0 : _ref.get(filename);
            if (!content) {
                return {
                    type: "paragraph",
                    children: [
                        {
                            text: `Missing image ${filename}`
                        }
                    ]
                };
            }
            return {
                type: "image",
                src: {
                    filename,
                    content
                },
                alt: node.alt,
                title: node.title,
                children: [
                    {
                        text: ""
                    }
                ]
            };
        }
        if (typeof node.type === "string") {
            const children = deserializeFiles(node.children, componentBlocks, files, otherFiles, mode, documentFeatures, slug);
            return {
                ...node,
                children
            };
        }
        return node;
    });
}
function deserializeProps(schema, value, files, otherFiles, mode, slug) {
    return transformProps(schema, value, {
        form: (schema, value)=>{
            if (schema.formKind === "asset") {
                var _otherFiles$get;
                if (mode === "read") {
                    return schema.reader.parse(value);
                }
                const filename = schema.filename(value, {
                    slug,
                    suggestedFilenamePrefix: undefined
                });
                return schema.parse(value, {
                    asset: filename ? schema.directory ? (_otherFiles$get = otherFiles.get(schema.directory)) === null || _otherFiles$get === void 0 ? void 0 : _otherFiles$get.get(filename) : files.get(filename) : undefined,
                    slug
                });
            }
            if (schema.formKind === "content") {
                throw new Error("Not implemented");
            }
            if (mode === "read") {
                return schema.reader.parse(value);
            }
            return schema.parse(value, undefined);
        }
    });
}
function getSrcPrefixForImageBlock(documentFeatures, slug) {
    return getSrcPrefix(typeof documentFeatures.images === "object" ? documentFeatures.images.publicPath : undefined, slug);
}
function serializeProps(rootValue, rootSchema, // note you might have a slug without a slug field when serializing props inside a component block or etc. in the editor
slugField, slug, shouldSuggestFilenamePrefix) {
    const extraFiles = [];
    return {
        value: transformProps(rootSchema, rootValue, {
            form (schema, value, propPath) {
                if (propPath.length === 1 && slugField === propPath[0]) {
                    if (schema.formKind !== "slug") {
                        throw new Error("slugField is a not a slug field");
                    }
                    return schema.serializeWithSlug(value).value;
                }
                if (schema.formKind === "asset") {
                    const { asset, value: forYaml } = schema.serialize(value, {
                        suggestedFilenamePrefix: shouldSuggestFilenamePrefix ? getPropPathPortion(propPath, rootSchema, rootValue) : undefined,
                        slug
                    });
                    if (asset) {
                        extraFiles.push({
                            path: asset.filename,
                            contents: asset.content,
                            parent: schema.directory
                        });
                    }
                    return forYaml;
                }
                if (schema.formKind === "content") {
                    const { other, external, content, value: forYaml } = schema.serialize(value, {
                        slug
                    });
                    if (content) {
                        extraFiles.push({
                            path: getPropPathPortion(propPath, rootSchema, rootValue) + schema.contentExtension,
                            contents: content,
                            parent: undefined
                        });
                    }
                    for (const [key, contents] of other){
                        extraFiles.push({
                            path: getPropPathPortion(propPath, rootSchema, rootValue) + "/" + key,
                            contents,
                            parent: undefined
                        });
                    }
                    const allowedDirectories = new Set(schema.directories);
                    for (const [directory, contents] of external){
                        if (!allowedDirectories.has(directory)) {
                            throw new Error(`Invalid directory ${directory} in content field serialization`);
                        }
                        for (const [filename, fileContents] of contents){
                            extraFiles.push({
                                path: filename,
                                contents: fileContents,
                                parent: directory
                            });
                        }
                    }
                    return forYaml;
                }
                return schema.serialize(value).value;
            },
            object (_schema, value) {
                return Object.fromEntries(Object.entries(value).filter((_ref)=>{
                    let [_, val] = _ref;
                    return val !== undefined;
                }));
            },
            array (_schema, value) {
                return value.map((val)=>val === undefined ? null : val);
            },
            child () {
                return undefined;
            }
        }),
        extraFiles
    };
}
function getPropPathPortion(path, schema, value) {
    const end = [];
    for (const portion of path){
        if (schema.kind === "array") {
            value = value[portion];
            if (schema.slugField && schema.element.kind === "object") {
                const slug = (0,utils_677addd9_node_react_server_esm.m)({
                    schema: schema.element.fields,
                    slugField: schema.slugField
                }, value);
                end.push(slug);
            } else {
                end.push(portion);
            }
            schema = schema.element;
            continue;
        }
        end.push(portion);
        if (schema.kind === "object") {
            value = value[portion];
            schema = schema.fields[portion];
            continue;
        }
        if (schema.kind === "conditional") {
            if (portion === "discriminant") {
                schema = schema.discriminant;
            } else if (portion === "value") {
                schema = schema.values[value.discriminant];
            }
            value = value[portion];
            continue;
        }
        throw new Error(`unexpected ${schema.kind}`);
    }
    return end.join("/");
}
function toInline(nodes) {
    return new dist.Ast.Node("inline", {}, nodes.flatMap(toMarkdocInline));
}
const markToMarkdoc = {
    bold: {
        type: "strong"
    },
    code: {
        type: "code"
    },
    italic: {
        type: "em"
    },
    underline: {
        type: "tag",
        tag: "u"
    },
    keyboard: {
        type: "tag",
        tag: "kbd"
    },
    strikethrough: {
        type: "s"
    },
    subscript: {
        type: "tag",
        tag: "sub"
    },
    superscript: {
        type: "tag",
        tag: "sup"
    }
};
function toMarkdocInline(node) {
    if (node.type === "link") {
        return new dist.Ast.Node("link", {
            href: node.href
        }, node.children.flatMap(toMarkdocInline));
    }
    if (node.type !== undefined) {
        throw new Error(`unexpected inline node type: ${node.type}`);
    }
    if (node.code) {
        return new dist.Ast.Node("code", {
            content: node.text
        }, []);
    }
    const marks = Object.keys(node).filter((mark)=>mark !== "text").sort();
    let markdocNode = new dist.Ast.Node("text", {
        content: node.text
    });
    for (const mark of marks){
        const config = markToMarkdoc[mark];
        if (config) {
            markdocNode = new dist.Ast.Node(config.type, {}, [
                markdocNode
            ], config.tag);
        }
    }
    return markdocNode;
}
function toMarkdocDocument(nodes, _config) {
    const extraFiles = [];
    const config = {
        ..._config,
        extraFiles
    };
    const node = new dist.Ast.Node("document", {}, nodes.flatMap((x)=>toMarkdoc(x, config)));
    return {
        node,
        extraFiles
    };
}
function toChildrenAndProps(childrenAsMarkdoc, resultingChildren, value, singleChildField) {
    if (singleChildField.kind === "child") {
        const child = childrenAsMarkdoc.find((x)=>areArraysEqual(x.propPath, singleChildField.relativePath));
        if (child) {
            resultingChildren.push(...child.children);
        }
        return;
    }
    if (singleChildField.kind === "array") {
        const key = singleChildField.relativePath[singleChildField.relativePath.length - 1];
        const parent = getValueAtPropPath(value, singleChildField.relativePath.slice(0, -1));
        const valueAtPropPath = parent[key];
        delete parent[key];
        const childNodes = new Map();
        for (const child of childrenAsMarkdoc){
            const innerPropPath = child.propPath.slice(singleChildField.relativePath.length + 1);
            const num = child.propPath[singleChildField.relativePath.length];
            if (childNodes.get(num) === undefined) {
                childNodes.set(num, []);
            }
            childNodes.get(num).push({
                children: child.children,
                propPath: innerPropPath
            });
        }
        resultingChildren.push(...valueAtPropPath.map((x, i)=>{
            var _childNodes$get;
            const newChildrenAsMarkdoc = (_childNodes$get = childNodes.get(i)) !== null && _childNodes$get !== void 0 ? _childNodes$get : [];
            const children = [];
            toChildrenAndProps(newChildrenAsMarkdoc, children, x, singleChildField.child);
            return new dist.Ast.Node("tag", x, children, singleChildField.asChildTag);
        }));
    }
}
function toMarkdoc(node, config) {
    if (node.type === "paragraph") {
        const markdocNode = new dist.Ast.Node("paragraph", node.textAlign ? {
            textAlign: node.textAlign
        } : {}, [
            toInline(node.children)
        ]);
        if (node.textAlign) {
            markdocNode.annotations.push({
                name: "textAlign",
                value: node.textAlign,
                type: "attribute"
            });
        }
        return markdocNode;
    }
    if (node.type === "image") {
        config.extraFiles.push({
            contents: node.src.content,
            path: node.src.filename,
            parent: typeof config.documentFeatures.images === "object" && typeof config.documentFeatures.images.directory === "string" ? (0,utils_677addd9_node_react_server_esm.A)(config.documentFeatures.images.directory) : undefined
        });
        return new dist.Ast.Node("paragraph", {}, [
            new dist.Ast.Node("inline", {}, [
                new dist.Ast.Node("image", {
                    src: encodeURI(`${getSrcPrefixForImageBlock(config.documentFeatures, config.slug)}${node.src.filename}`),
                    alt: node.alt,
                    title: node.title
                })
            ])
        ]);
    }
    if (node.type === "code") {
        const extraAttributes = {};
        const { children, language, type, ...rest } = node;
        const schema = typeof config.documentFeatures.formatting.blockTypes.code === "object" ? config.documentFeatures.formatting.blockTypes.code.schema : undefined;
        if (schema && Object.keys(schema.fields).length > 0) {
            const serialized = serializeProps((0,initial_values_25bf35f4_node_react_server_esm.b)(schema, rest), schema, undefined, config.slug, false);
            Object.assign(extraAttributes, serialized.value);
            config.extraFiles.push(...serialized.extraFiles);
        }
        let content = children[0].text + "\n";
        const markdocNode = new dist.Ast.Node("fence", {
            content,
            language,
            ...extraAttributes
        }, [
            new dist.Ast.Node("text", {
                content
            })
        ]);
        for (const [key, value] of Object.entries(extraAttributes)){
            markdocNode.annotations.push({
                name: key,
                value,
                type: "attribute"
            });
        }
        return markdocNode;
    }
    const _toMarkdoc = (node)=>toMarkdoc(node, config);
    if (node.type === "blockquote") {
        return new dist.Ast.Node("blockquote", {}, node.children.map(_toMarkdoc));
    }
    if (node.type === "divider") {
        return new dist.Ast.Node("hr");
    }
    if (node.type === "table") {
        const head = node.children.find((x)=>x.type === "table-head");
        return new dist.Ast.Node("tag", {}, [
            new dist.Ast.Node("table", {}, [
                new dist.Ast.Node("thead", {}, head ? head.children.map(_toMarkdoc) : []),
                _toMarkdoc(node.children.find((x)=>x.type === "table-body"))
            ])
        ], "table");
    }
    if (node.type === "table-body") {
        return new dist.Ast.Node("tbody", {}, node.children.map(_toMarkdoc));
    }
    if (node.type === "table-row") {
        return new dist.Ast.Node("tr", {}, node.children.map(_toMarkdoc));
    }
    if (node.type === "table-cell") {
        return new dist.Ast.Node(node.header ? "th" : "td", {}, node.children.map(_toMarkdoc));
    }
    if (node.type === "heading") {
        const extraAttributes = {};
        if (node.textAlign) {
            extraAttributes.textAlign = node.textAlign;
        }
        const { children, level, textAlign, type, ...rest } = node;
        const schema = config.documentFeatures.formatting.headings.schema;
        if (Object.keys(schema.fields).length > 0) {
            Object.assign(extraAttributes, serializeProps((0,initial_values_25bf35f4_node_react_server_esm.b)(schema, rest), schema, undefined, config.slug, false).value);
        }
        const markdocNode = new dist.Ast.Node("heading", {
            level: node.level,
            ...extraAttributes
        }, [
            toInline(node.children)
        ]);
        for (const [key, value] of Object.entries(extraAttributes)){
            markdocNode.annotations.push({
                name: key,
                value,
                type: "attribute"
            });
        }
        return markdocNode;
    }
    if (node.type === "ordered-list") {
        return new dist.Ast.Node("list", {
            ordered: true
        }, node.children.map(_toMarkdoc));
    }
    if (node.type === "unordered-list") {
        return new dist.Ast.Node("list", {
            ordered: false
        }, node.children.map(_toMarkdoc));
    }
    if (node.type === "layout") {
        return new dist.Ast.Node("tag", {
            layout: node.layout
        }, node.children.map(_toMarkdoc), "layout");
    }
    if (node.type === "layout-area") {
        return new dist.Ast.Node("tag", {}, node.children.flatMap(_toMarkdoc), "layout-area");
    }
    if (node.type === "component-block") {
        const isVoid = node.children.length === 1 && node.children[0].type === "component-inline-prop" && node.children[0].propPath === undefined;
        const componentBlock = config.componentBlocks[node.component];
        const childrenAsMarkdoc = [];
        for (const child of node.children){
            if ((child.type === "component-block-prop" || child.type === "component-inline-prop") && child.propPath !== undefined) {
                childrenAsMarkdoc.push({
                    type: child.type,
                    propPath: child.propPath,
                    children: child.type === "component-block-prop" ? child.children.flatMap(_toMarkdoc) : [
                        toInline(child.children)
                    ]
                });
            }
        }
        let attributes = node.props;
        if (componentBlock) {
            const serialized = serializeProps(node.props, {
                kind: "object",
                fields: componentBlock.schema
            }, undefined, config.slug, false);
            attributes = serialized.value;
            config.extraFiles.push(...serialized.extraFiles);
            const singleChildField = findSingleChildField({
                kind: "object",
                fields: componentBlock.schema
            });
            if (singleChildField) {
                const children = [];
                toChildrenAndProps(childrenAsMarkdoc, children, attributes, singleChildField);
                return new dist.Ast.Node("tag", attributes, children, node.component);
            }
        }
        const children = isVoid ? [] : childrenAsMarkdoc.map((x)=>new dist.Ast.Node("tag", {
                propPath: x.propPath
            }, x.children, x.type));
        return new dist.Ast.Node("tag", attributes, children, node.component);
    }
    if (node.type === "component-block-prop" || node.type === "component-inline-prop") {
        return new dist.Ast.Node("tag", {
            propPath: node.propPath
        }, node.type === "component-inline-prop" ? [
            toInline(node.children)
        ] : node.children.flatMap(_toMarkdoc), node.type);
    }
    if (node.type === "list-item") {
        const listItemContent = node.children[0];
        if (listItemContent.type !== "list-item-content") {
            throw new Error("list item content must contain a list-item-content");
        }
        const inline = toInline(listItemContent.children);
        const children = [
            inline
        ];
        const nestedList = node.children[1];
        if (nestedList) {
            children.push(toMarkdoc(nestedList, config));
        }
        return new dist.Ast.Node("item", {}, children);
    }
    if (node.type === "list-item-content") {
        throw new Error("list-item-content in unexpected position");
    }
    debugger;
    throw new Error(`unexpected node type: ${node.type}`);
}
const codeBlockShortcutPattern = /^```(\w+)? ?$/;
function withCodeBlock(documentFeatures, componentBlocks, editor) {
    const { insertBreak, normalizeNode, insertText } = editor;
    function codeBlockShortcut(block) {
        var _aliasesToCanonicalNa;
        if ((block === null || block === void 0 ? void 0 : block[0].type) !== "paragraph" || block[0].children.length !== 1 || block[0].children[0].type !== undefined) {
            return false;
        }
        const match = codeBlockShortcutPattern.exec(block[0].children[0].text);
        if (!match) {
            return false;
        }
        const locationDocumentFeatures = (0,utils_2bbfbd32_node_react_server_esm.g)(editor, documentFeatures, componentBlocks);
        if (locationDocumentFeatures && (locationDocumentFeatures.kind === "inline" || !locationDocumentFeatures.documentFeatures.formatting.blockTypes.code)) {
            return false;
        }
        // so that this starts a new undo group
        editor.history.undos.push({
            operations: [],
            selectionBefore: editor.selection
        });
        slate_dist/* Transforms */.YR.select(editor, block[1]);
        slate_dist/* Transforms */.YR.delete(editor);
        slate_dist/* Transforms */.YR.wrapNodes(editor, {
            type: "code",
            ...match[1] ? {
                language: (_aliasesToCanonicalNa = languages_14058067_node_react_server_esm.a.get(match[1].toLowerCase())) !== null && _aliasesToCanonicalNa !== void 0 ? _aliasesToCanonicalNa : match[1]
            } : {},
            children: []
        }, {
            match: (node)=>node.type === "paragraph"
        });
        return true;
    }
    editor.insertBreak = ()=>{
        const block = slate_dist/* Editor */.ML.above(editor, {
            match: utils_2bbfbd32_node_react_server_esm.i
        });
        if ((block === null || block === void 0 ? void 0 : block[0].type) === "code" && slate_dist/* Text */.xv.isText(block[0].children[0])) {
            const text = block[0].children[0].text;
            if (text[text.length - 1] === "\n" && editor.selection && slate_dist/* Range */.e6.isCollapsed(editor.selection) && slate_dist/* Point */.E9.equals(slate_dist/* Editor */.ML.end(editor, block[1]), editor.selection.anchor)) {
                insertBreak();
                slate_dist/* Transforms */.YR.setNodes(editor, {
                    type: "paragraph",
                    children: []
                });
                slate_dist/* Transforms */.YR.delete(editor, {
                    distance: 1,
                    at: {
                        path: [
                            ...block[1],
                            0
                        ],
                        offset: text.length - 1
                    }
                });
                return;
            }
            editor.insertText("\n");
            return;
        }
        if (editor.selection && slate_dist/* Range */.e6.isCollapsed(editor.selection) && codeBlockShortcut(block)) {
            return;
        }
        insertBreak();
    };
    editor.insertText = (text)=>{
        insertText(text);
        if (text === " " && editor.selection && slate_dist/* Range */.e6.isCollapsed(editor.selection)) {
            codeBlockShortcut(slate_dist/* Editor */.ML.above(editor, {
                match: utils_2bbfbd32_node_react_server_esm.i
            }));
        }
    };
    editor.normalizeNode = (_ref)=>{
        let [node, path] = _ref;
        if (node.type === "code" && slate_dist/* Element */.W_.isElement(node)) {
            for (const [index, childNode] of node.children.entries()){
                if (!slate_dist/* Text */.xv.isText(childNode)) {
                    if (editor.isVoid(childNode)) {
                        slate_dist/* Transforms */.YR.removeNodes(editor, {
                            at: [
                                ...path,
                                index
                            ]
                        });
                    } else {
                        slate_dist/* Transforms */.YR.unwrapNodes(editor, {
                            at: [
                                ...path,
                                index
                            ]
                        });
                    }
                    return;
                }
                const marks = Object.keys(childNode).filter((x)=>x !== "text");
                if (marks.length) {
                    slate_dist/* Transforms */.YR.unsetNodes(editor, marks, {
                        at: [
                            ...path,
                            index
                        ]
                    });
                    return;
                }
            }
        }
        normalizeNode([
            node,
            path
        ]);
    };
    return editor;
}
function findChildPropPathsForProp(value, schema, path) {
    switch(schema.kind){
        case "form":
            return [];
        case "child":
            return [
                {
                    path: path,
                    options: schema.options
                }
            ];
        case "conditional":
            return findChildPropPathsForProp(value.value, schema.values[value.discriminant], path.concat("value"));
        case "object":
            {
                const paths = [];
                Object.keys(schema.fields).forEach((key)=>{
                    paths.push(...findChildPropPathsForProp(value[key], schema.fields[key], path.concat(key)));
                });
                return paths;
            }
        case "array":
            {
                const paths = [];
                value.forEach((val, i)=>{
                    paths.push(...findChildPropPathsForProp(val, schema.element, path.concat(i)));
                });
                return paths;
            }
    }
}
function findChildPropPaths(value, props) {
    const propPaths = findChildPropPathsForProp(value, {
        kind: "object",
        fields: props
    }, []);
    if (!propPaths.length) {
        return [
            {
                path: undefined,
                options: {
                    kind: "inline",
                    placeholder: ""
                }
            }
        ];
    }
    return propPaths;
}
function getAncestorComponentBlock(editor) {
    if (editor.selection) {
        const ancestorEntry = slate_dist/* Editor */.ML.above(editor, {
            match: (node)=>(0,utils_2bbfbd32_node_react_server_esm.i)(node) && node.type !== "paragraph"
        });
        if (ancestorEntry && (ancestorEntry[0].type === "component-block-prop" || ancestorEntry[0].type === "component-inline-prop")) {
            return {
                isInside: true,
                componentBlock: slate_dist/* Editor */.ML.parent(editor, ancestorEntry[1]),
                prop: ancestorEntry
            };
        }
    }
    return {
        isInside: false
    };
}
const alreadyNormalizedThings = new WeakMap();
function normalizeNodeWithinComponentProp(_ref, editor, fieldOptions) {
    let [node, path] = _ref;
    let alreadyNormalizedNodes = alreadyNormalizedThings.get(fieldOptions);
    if (!alreadyNormalizedNodes) {
        alreadyNormalizedNodes = new WeakSet();
        alreadyNormalizedThings.set(fieldOptions, alreadyNormalizedNodes);
    }
    if (alreadyNormalizedNodes.has(node)) {
        return false;
    }
    let didNormalization = false;
    if (fieldOptions.inlineMarks !== "inherit" && slate_dist/* Text */.xv.isText(node)) {
        didNormalization = normalizeTextBasedOnInlineMarksAndSoftBreaks([
            node,
            path
        ], editor, fieldOptions.inlineMarks, fieldOptions.softBreaks);
    }
    if (slate_dist/* Element */.W_.isElement(node)) {
        let childrenHasChanged = node.children.map((node, i)=>normalizeNodeWithinComponentProp([
                node,
                [
                    ...path,
                    i
                ]
            ], editor, fieldOptions))// .map then .some because we don't want to exit early
        .some((x)=>x);
        if (fieldOptions.kind === "block") {
            if (node.type === "component-block") {
                if (!fieldOptions.componentBlocks) {
                    slate_dist/* Transforms */.YR.unwrapNodes(editor, {
                        at: path
                    });
                    didNormalization = true;
                }
            } else {
                didNormalization = normalizeElementBasedOnDocumentFeatures([
                    node,
                    path
                ], editor, fieldOptions.documentFeatures) || childrenHasChanged;
            }
        } else {
            didNormalization = normalizeInlineBasedOnLinks([
                node,
                path
            ], editor, fieldOptions.documentFeatures.links);
        }
    }
    if (didNormalization === false) {
        alreadyNormalizedNodes.add(node);
    }
    return didNormalization;
}
function canSchemaContainChildField(rootSchema) {
    const queue = new Set([
        rootSchema
    ]);
    for (const schema of queue){
        if (schema.kind === "form") ;
        else if (schema.kind === "child") {
            return true;
        } else if (schema.kind === "array") {
            queue.add(schema.element);
        } else if (schema.kind === "object") {
            for (const innerProp of Object.values(schema.fields)){
                queue.add(innerProp);
            }
        } else if (schema.kind === "conditional") {
            for (const innerProp of Object.values(schema.values)){
                queue.add(innerProp);
            }
        } else {
            (0,emery_cjs.assertNever)(schema);
        }
    }
    return false;
}
function doesSchemaOnlyEverContainASingleChildField(rootSchema) {
    const queue = new Set([
        rootSchema
    ]);
    let hasFoundChildField = false;
    for (const schema of queue){
        if (schema.kind === "form") ;
        else if (schema.kind === "child") {
            if (hasFoundChildField) {
                return false;
            }
            hasFoundChildField = true;
        } else if (schema.kind === "array") {
            if (canSchemaContainChildField(schema.element)) {
                return false;
            }
        } else if (schema.kind === "object") {
            for (const innerProp of Object.values(schema.fields)){
                queue.add(innerProp);
            }
        } else if (schema.kind === "conditional") {
            for (const innerProp of Object.values(schema.values)){
                queue.add(innerProp);
            }
        } else {
            (0,emery_cjs.assertNever)(schema);
        }
    }
    return hasFoundChildField;
}
function findArrayFieldsWithSingleChildField(schema, value) {
    const propPaths = [];
    traverseProps(schema, value, (schema, value, path)=>{
        if (schema.kind === "array" && doesSchemaOnlyEverContainASingleChildField(schema.element)) {
            propPaths.push([
                path,
                schema
            ]);
        }
    });
    return propPaths;
}
function isEmptyChildFieldNode(element) {
    const firstChild = element.children[0];
    return element.children.length === 1 && (element.type === "component-inline-prop" && firstChild.type === undefined && firstChild.text === "" || element.type === "component-block-prop" && firstChild.type === "paragraph" && firstChild.children.length === 1 && firstChild.children[0].type === undefined && firstChild.children[0].text === "");
}
function withComponentBlocks(blockComponents, editorDocumentFeatures, editor) {
    // note that conflicts between the editor document features
    // and the child field document features are dealt with elsewhere
    const memoizedGetDocumentFeaturesForChildField = weakMemoize((options)=>{
        return (0,utils_2bbfbd32_node_react_server_esm.a)(editorDocumentFeatures, options);
    });
    const { normalizeNode, deleteBackward, insertBreak } = editor;
    editor.deleteBackward = (unit)=>{
        if (editor.selection) {
            const ancestorComponentBlock = getAncestorComponentBlock(editor);
            if (ancestorComponentBlock.isInside && slate_dist/* Range */.e6.isCollapsed(editor.selection) && slate_dist/* Editor */.ML.isStart(editor, editor.selection.anchor, ancestorComponentBlock.prop[1]) && ancestorComponentBlock.prop[1][ancestorComponentBlock.prop[1].length - 1] === 0) {
                slate_dist/* Transforms */.YR.unwrapNodes(editor, {
                    at: ancestorComponentBlock.componentBlock[1]
                });
                return;
            }
        }
        deleteBackward(unit);
    };
    editor.insertBreak = ()=>{
        const ancestorComponentBlock = getAncestorComponentBlock(editor);
        if (editor.selection && ancestorComponentBlock.isInside) {
            const { prop: [componentPropNode, componentPropPath], componentBlock: [componentBlockNode, componentBlockPath] } = ancestorComponentBlock;
            const isLastProp = componentPropPath[componentPropPath.length - 1] === componentBlockNode.children.length - 1;
            if (componentPropNode.type === "component-block-prop") {
                const [[paragraphNode, paragraphPath]] = slate_dist/* Editor */.ML.nodes(editor, {
                    match: (node)=>node.type === "paragraph"
                });
                const isLastParagraph = paragraphPath[paragraphPath.length - 1] === componentPropNode.children.length - 1;
                if (slate_dist/* Node */.NB.string(paragraphNode) === "" && isLastParagraph) {
                    if (isLastProp) {
                        slate_dist/* Transforms */.YR.moveNodes(editor, {
                            at: paragraphPath,
                            to: slate_dist/* Path */.y$.next(ancestorComponentBlock.componentBlock[1])
                        });
                    } else {
                        slate_dist/* Transforms */.YR.move(editor, {
                            distance: 1,
                            unit: "line"
                        });
                        slate_dist/* Transforms */.YR.removeNodes(editor, {
                            at: paragraphPath
                        });
                    }
                    return;
                }
            }
            if (componentPropNode.type === "component-inline-prop") {
                slate_dist/* Editor */.ML.withoutNormalizing(editor, ()=>{
                    const componentBlock = blockComponents[componentBlockNode.component];
                    if (componentPropNode.propPath !== undefined && componentBlock !== undefined) {
                        const rootSchema = {
                            kind: "object",
                            fields: componentBlock.schema
                        };
                        const ancestorFields = (0,utils_2bbfbd32_node_react_server_esm.b)(rootSchema, componentPropNode.propPath, componentBlockNode.props);
                        const idx = [
                            ...ancestorFields
                        ].reverse().findIndex((item)=>item.kind === "array");
                        if (idx !== -1) {
                            const arrayFieldIdx = ancestorFields.length - 1 - idx;
                            const arrayField = ancestorFields[arrayFieldIdx];
                            (0,emery_cjs.assert)(arrayField.kind === "array");
                            const val = getValueAtPropPath(componentBlockNode.props, componentPropNode.propPath.slice(0, arrayFieldIdx));
                            if (doesSchemaOnlyEverContainASingleChildField(arrayField.element)) {
                                if (slate_dist/* Node */.NB.string(componentPropNode) === "" && val.length - 1 === componentPropNode.propPath[arrayFieldIdx]) {
                                    slate_dist/* Transforms */.YR.removeNodes(editor, {
                                        at: componentPropPath
                                    });
                                    if (isLastProp) {
                                        slate_dist/* Transforms */.YR.insertNodes(editor, {
                                            type: "paragraph",
                                            children: [
                                                {
                                                    text: ""
                                                }
                                            ]
                                        }, {
                                            at: slate_dist/* Path */.y$.next(componentBlockPath)
                                        });
                                        slate_dist/* Transforms */.YR.select(editor, slate_dist/* Path */.y$.next(componentBlockPath));
                                    } else {
                                        slate_dist/* Transforms */.YR.move(editor, {
                                            distance: 1,
                                            unit: "line"
                                        });
                                    }
                                } else {
                                    insertBreak();
                                }
                                return;
                            }
                        }
                    }
                    slate_dist/* Transforms */.YR.splitNodes(editor, {
                        always: true
                    });
                    const splitNodePath = slate_dist/* Path */.y$.next(componentPropPath);
                    if (isLastProp) {
                        slate_dist/* Transforms */.YR.moveNodes(editor, {
                            at: splitNodePath,
                            to: slate_dist/* Path */.y$.next(componentBlockPath)
                        });
                    } else {
                        (0,utils_2bbfbd32_node_react_server_esm.m)(editor, splitNodePath, [
                            ...slate_dist/* Path */.y$.next(splitNodePath),
                            0
                        ]);
                        slate_dist/* Transforms */.YR.removeNodes(editor, {
                            at: splitNodePath
                        });
                    }
                });
                return;
            }
        }
        insertBreak();
    };
    editor.normalizeNode = (entry)=>{
        const [node, path] = entry;
        if (node.type === "component-inline-prop" && !node.propPath && (node.children.length !== 1 || !slate_dist/* Text */.xv.isText(node.children[0]) || node.children[0].text !== "")) {
            slate_dist/* Transforms */.YR.removeNodes(editor, {
                at: path
            });
            return;
        }
        if (node.type === "component-block") {
            const componentBlock = blockComponents[node.component];
            if (componentBlock) {
                const rootSchema = {
                    kind: "object",
                    fields: componentBlock.schema
                };
                const updatedProps = addMissingFields(node.props, rootSchema);
                if (updatedProps !== node.props) {
                    slate_dist/* Transforms */.YR.setNodes(editor, {
                        props: updatedProps
                    }, {
                        at: path
                    });
                    return;
                }
                for (const [propPath, arrayField] of findArrayFieldsWithSingleChildField(rootSchema, node.props)){
                    if (node.children.length === 1 && node.children[0].type === "component-inline-prop" && node.children[0].propPath === undefined) {
                        break;
                    }
                    const nodesWithin = [];
                    for (const [idx, childNode] of node.children.entries()){
                        if ((childNode.type === "component-block-prop" || childNode.type === "component-inline-prop") && childNode.propPath !== undefined) {
                            const subPath = childNode.propPath.concat();
                            while(subPath.length){
                                if (typeof subPath.pop() === "number") break;
                            }
                            if (areArraysEqual(propPath, subPath)) {
                                nodesWithin.push([
                                    idx,
                                    childNode
                                ]);
                            }
                        }
                    }
                    const arrVal = getValueAtPropPath(node.props, propPath);
                    const prevKeys = (0,initial_values_25bf35f4_node_react_server_esm.a)(arrVal);
                    const prevKeysSet = new Set(prevKeys);
                    const alreadyUsedIndicies = new Set();
                    const newVal = [];
                    const newKeys = [];
                    const getNewKey = ()=>{
                        let key = (0,initial_values_25bf35f4_node_react_server_esm.c)();
                        while(prevKeysSet.has(key)){
                            key = (0,initial_values_25bf35f4_node_react_server_esm.c)();
                        }
                        return key;
                    };
                    for (const [, node] of nodesWithin){
                        const idxFromValue = node.propPath[propPath.length];
                        (0,emery_cjs.assert)(typeof idxFromValue === "number");
                        if (arrVal.length <= idxFromValue || alreadyUsedIndicies.has(idxFromValue) && isEmptyChildFieldNode(node)) {
                            newVal.push((0,initial_values_25bf35f4_node_react_server_esm.g)(arrayField.element));
                            newKeys.push(getNewKey());
                        } else {
                            alreadyUsedIndicies.add(idxFromValue);
                            newVal.push(arrVal[idxFromValue]);
                            newKeys.push(alreadyUsedIndicies.has(idxFromValue) ? getNewKey() : prevKeys[idxFromValue]);
                        }
                    }
                    (0,initial_values_25bf35f4_node_react_server_esm.s)(newVal, newKeys);
                    if (!areArraysEqual(arrVal, newVal)) {
                        const transformedProps = replaceValueAtPropPath(rootSchema, node.props, newVal, propPath);
                        slate_dist/* Transforms */.YR.setNodes(editor, {
                            props: transformedProps
                        }, {
                            at: path
                        });
                        for (const [idx, [idxInChildrenOfBlock, nodeWithin]] of nodesWithin.entries()){
                            const newPropPath = [
                                ...nodeWithin.propPath
                            ];
                            newPropPath[propPath.length] = idx;
                            slate_dist/* Transforms */.YR.setNodes(editor, {
                                propPath: newPropPath
                            }, {
                                at: [
                                    ...path,
                                    idxInChildrenOfBlock
                                ]
                            });
                        }
                        return;
                    }
                }
                const missingKeys = new Map(findChildPropPaths(node.props, componentBlock.schema).map((x)=>[
                        JSON.stringify(x.path),
                        x.options.kind
                    ]));
                node.children.forEach((node)=>{
                    (0,emery_cjs.assert)(node.type === "component-block-prop" || node.type === "component-inline-prop");
                    missingKeys.delete(JSON.stringify(node.propPath));
                });
                if (missingKeys.size) {
                    slate_dist/* Transforms */.YR.insertNodes(editor, [
                        ...missingKeys
                    ].map((_ref2)=>{
                        let [prop, kind] = _ref2;
                        return {
                            type: `component-${kind}-prop`,
                            propPath: prop ? JSON.parse(prop) : prop,
                            children: [
                                {
                                    text: ""
                                }
                            ]
                        };
                    }), {
                        at: [
                            ...path,
                            node.children.length
                        ]
                    });
                    return;
                }
                const foundProps = new Set();
                const stringifiedInlinePropPaths = {};
                findChildPropPaths(node.props, blockComponents[node.component].schema).forEach((x, index)=>{
                    stringifiedInlinePropPaths[JSON.stringify(x.path)] = {
                        options: x.options,
                        index
                    };
                });
                for (const [index, childNode] of node.children.entries()){
                    if (// children that are not these will be handled by
                    // the generic allowedChildren normalization
                    childNode.type !== "component-inline-prop" && childNode.type !== "component-block-prop") {
                        continue;
                    }
                    const childPath = [
                        ...path,
                        index
                    ];
                    const stringifiedPropPath = JSON.stringify(childNode.propPath);
                    if (stringifiedInlinePropPaths[stringifiedPropPath] === undefined) {
                        slate_dist/* Transforms */.YR.removeNodes(editor, {
                            at: childPath
                        });
                        return;
                    }
                    if (foundProps.has(stringifiedPropPath)) {
                        slate_dist/* Transforms */.YR.removeNodes(editor, {
                            at: childPath
                        });
                        return;
                    }
                    foundProps.add(stringifiedPropPath);
                    const propInfo = stringifiedInlinePropPaths[stringifiedPropPath];
                    const expectedIndex = propInfo.index;
                    if (index !== expectedIndex) {
                        slate_dist/* Transforms */.YR.moveNodes(editor, {
                            at: childPath,
                            to: [
                                ...path,
                                expectedIndex
                            ]
                        });
                        return;
                    }
                    const expectedChildNodeType = `component-${propInfo.options.kind}-prop`;
                    if (childNode.type !== expectedChildNodeType) {
                        slate_dist/* Transforms */.YR.setNodes(editor, {
                            type: expectedChildNodeType
                        }, {
                            at: childPath
                        });
                        return;
                    }
                    const documentFeatures = memoizedGetDocumentFeaturesForChildField(propInfo.options);
                    if (normalizeNodeWithinComponentProp([
                        childNode,
                        childPath
                    ], editor, documentFeatures)) {
                        return;
                    }
                }
            }
        }
        normalizeNode(entry);
    };
    return editor;
}
// the only thing that this will fix is a new field being added to an object field, nothing else.
function addMissingFields(value, schema) {
    if (schema.kind === "child" || schema.kind === "form") {
        return value;
    }
    if (schema.kind === "conditional") {
        const conditionalValue = value;
        const updatedInnerValue = addMissingFields(conditionalValue.value, schema.values[conditionalValue.discriminant.toString()]);
        if (updatedInnerValue === conditionalValue.value) {
            return value;
        }
        return {
            discriminant: conditionalValue.discriminant,
            value: updatedInnerValue
        };
    }
    if (schema.kind === "array") {
        const arrValue = value;
        const newArrValue = arrValue.map((x)=>addMissingFields(x, schema.element));
        if (areArraysEqual(arrValue, newArrValue)) {
            return value;
        }
        return newArrValue;
    }
    if (schema.kind === "object") {
        const objectValue = value;
        let hasChanged = false;
        const newObjectValue = {};
        for (const [key, innerSchema] of Object.entries(schema.fields)){
            const innerValue = objectValue[key];
            if (innerValue === undefined) {
                hasChanged = true;
                newObjectValue[key] = (0,initial_values_25bf35f4_node_react_server_esm.g)(innerSchema);
                continue;
            }
            const newInnerValue = addMissingFields(innerValue, innerSchema);
            if (newInnerValue !== innerValue) {
                hasChanged = true;
            }
            newObjectValue[key] = newInnerValue;
        }
        if (hasChanged) {
            return newObjectValue;
        }
        return value;
    }
    (0,emery_cjs.assertNever)(schema);
}
const paragraphElement = ()=>({
        type: "paragraph",
        children: [
            {
                text: ""
            }
        ]
    });
function withParagraphs(editor) {
    const { normalizeNode } = editor;
    editor.normalizeNode = (entry)=>{
        const [node, path] = entry;
        if (slate_dist/* Editor */.ML.isEditor(node)) {
            let lastNode = node.children[node.children.length - 1];
            if ((lastNode === null || lastNode === void 0 ? void 0 : lastNode.type) !== "paragraph") {
                slate_dist/* Transforms */.YR.insertNodes(editor, paragraphElement(), {
                    at: [
                        ...path,
                        node.children.length
                    ]
                });
                return;
            }
        }
        normalizeNode(entry);
    };
    return editor;
}
function withLayouts(editor) {
    const { normalizeNode, deleteBackward } = editor;
    editor.deleteBackward = (unit)=>{
        if (editor.selection && slate_dist/* Range */.e6.isCollapsed(editor.selection) && // this is just an little optimisation
        // we're only doing things if we're at the start of a layout area
        // and the start of anything will always be offset 0
        // so we'll bailout if we're not at offset 0
        editor.selection.anchor.offset === 0) {
            const [aboveNode, abovePath] = slate_dist/* Editor */.ML.above(editor, {
                match: (node)=>node.type === "layout-area"
            }) || [
                editor,
                []
            ];
            if (aboveNode.type === "layout-area" && slate_dist/* Point */.E9.equals(slate_dist/* Editor */.ML.start(editor, abovePath), editor.selection.anchor)) {
                return;
            }
        }
        deleteBackward(unit);
    };
    editor.normalizeNode = (entry)=>{
        const [node, path] = entry;
        if (slate_dist/* Element */.W_.isElement(node) && node.type === "layout") {
            if (node.layout === undefined) {
                slate_dist/* Transforms */.YR.unwrapNodes(editor, {
                    at: path
                });
                return;
            }
            if (node.children.length < node.layout.length) {
                slate_dist/* Transforms */.YR.insertNodes(editor, Array.from({
                    length: node.layout.length - node.children.length
                }).map(()=>({
                        type: "layout-area",
                        children: [
                            paragraphElement()
                        ]
                    })), {
                    at: [
                        ...path,
                        node.children.length
                    ]
                });
                return;
            }
            if (node.children.length > node.layout.length) {
                Array.from({
                    length: node.children.length - node.layout.length
                }).map((_, i)=>i).reverse().forEach((i)=>{
                    const layoutAreaToRemovePath = [
                        ...path,
                        i + node.layout.length
                    ];
                    const child = node.children[i + node.layout.length];
                    (0,utils_2bbfbd32_node_react_server_esm.m)(editor, layoutAreaToRemovePath, [
                        ...path,
                        node.layout.length - 1,
                        node.children[node.layout.length - 1].children.length
                    ], (node)=>node.type !== "paragraph" || slate_dist/* Node */.NB.string(child) !== "");
                    slate_dist/* Transforms */.YR.removeNodes(editor, {
                        at: layoutAreaToRemovePath
                    });
                });
                return;
            }
        }
        normalizeNode(entry);
    };
    return editor;
}
const markdownLinkPattern = /(^|\s)\[(.+?)\]\((\S+)\)$/;
function withLink(editorDocumentFeatures, componentBlocks, editor) {
    const { insertText, isInline, normalizeNode } = editor;
    editor.isInline = (element)=>{
        return element.type === "link" ? true : isInline(element);
    };
    if (editorDocumentFeatures.links) {
        editor.insertText = (text)=>{
            insertText(text);
            if (text !== ")" || !editor.selection) {
                return;
            }
            const startOfBlock = slate_dist/* Editor */.ML.start(editor, slate_dist/* Editor */.ML.above(editor, {
                match: utils_2bbfbd32_node_react_server_esm.i
            })[1]);
            const startOfBlockToEndOfShortcutString = slate_dist/* Editor */.ML.string(editor, {
                anchor: editor.selection.anchor,
                focus: startOfBlock
            });
            const match = markdownLinkPattern.exec(startOfBlockToEndOfShortcutString);
            if (!match) {
                return;
            }
            const ancestorComponentChildFieldDocumentFeatures = (0,utils_2bbfbd32_node_react_server_esm.g)(editor, editorDocumentFeatures, componentBlocks);
            if ((ancestorComponentChildFieldDocumentFeatures === null || ancestorComponentChildFieldDocumentFeatures === void 0 ? void 0 : ancestorComponentChildFieldDocumentFeatures.documentFeatures.links) === false) {
                return;
            }
            const [, maybeWhitespace, linkText, href] = match;
            // by doing this, the insertText(')') above will happen in a different undo than the link replacement
            // so that means that when someone does an undo after this
            // it will undo to the state of "[content](link)" rather than "[content](link" (note the missing closing bracket)
            editor.history.undos.push({
                operations: [],
                selectionBefore: editor.selection
            });
            const startOfShortcut = match.index === 0 ? startOfBlock : (0,utils_2bbfbd32_node_react_server_esm.E)(editor, startOfBlock, {
                distance: match.index
            });
            const startOfLinkText = (0,utils_2bbfbd32_node_react_server_esm.E)(editor, startOfShortcut, {
                distance: maybeWhitespace === "" ? 1 : 2
            });
            const endOfLinkText = (0,utils_2bbfbd32_node_react_server_esm.E)(editor, startOfLinkText, {
                distance: linkText.length
            });
            slate_dist/* Transforms */.YR.delete(editor, {
                at: {
                    anchor: endOfLinkText,
                    focus: editor.selection.anchor
                }
            });
            slate_dist/* Transforms */.YR.delete(editor, {
                at: {
                    anchor: startOfShortcut,
                    focus: startOfLinkText
                }
            });
            slate_dist/* Transforms */.YR.wrapNodes(editor, {
                type: "link",
                href,
                children: []
            }, {
                at: {
                    anchor: editor.selection.anchor,
                    focus: startOfShortcut
                },
                split: true
            });
            const nextNode = slate_dist/* Editor */.ML.next(editor);
            if (nextNode) {
                slate_dist/* Transforms */.YR.select(editor, nextNode[1]);
            }
        };
    }
    editor.normalizeNode = (_ref)=>{
        let [node, path] = _ref;
        if (node.type === "link") {
            if (slate_dist/* Node */.NB.string(node) === "") {
                slate_dist/* Transforms */.YR.unwrapNodes(editor, {
                    at: path
                });
                return;
            }
            for (const [idx, child] of node.children.entries()){
                if (child.type === "link") {
                    // links cannot contain links
                    slate_dist/* Transforms */.YR.unwrapNodes(editor, {
                        at: [
                            ...path,
                            idx
                        ]
                    });
                    return;
                }
            }
        }
        if ((0,utils_2bbfbd32_node_react_server_esm.c)(node)) {
            let lastMergableLink = null;
            for (const [idx, child] of node.children.entries()){
                var _lastMergableLink;
                if (child.type === "link" && child.href === ((_lastMergableLink = lastMergableLink) === null || _lastMergableLink === void 0 ? void 0 : _lastMergableLink.node.href)) {
                    const firstLinkPath = [
                        ...path,
                        lastMergableLink.index
                    ];
                    const secondLinkPath = [
                        ...path,
                        idx
                    ];
                    const to = [
                        ...firstLinkPath,
                        lastMergableLink.node.children.length
                    ];
                    // note this is going in reverse, js doesn't have double-ended iterators so it's a for(;;)
                    for(let i = child.children.length - 1; i >= 0; i--){
                        const childPath = [
                            ...secondLinkPath,
                            i
                        ];
                        slate_dist/* Transforms */.YR.moveNodes(editor, {
                            at: childPath,
                            to
                        });
                    }
                    slate_dist/* Transforms */.YR.removeNodes(editor, {
                        at: secondLinkPath
                    });
                    return;
                }
                if (!slate_dist/* Text */.xv.isText(child) || child.text !== "") {
                    lastMergableLink = null;
                }
                if (child.type === "link") {
                    lastMergableLink = {
                        index: idx,
                        node: child
                    };
                }
            }
        }
        normalizeNode([
            node,
            path
        ]);
    };
    return editor;
}
const isListType = (type)=>type === "ordered-list" || type === "unordered-list";
const isListNode = (node)=>isListType(node.type);
function getAncestorList(editor) {
    if (editor.selection) {
        const listItem = slate_dist/* Editor */.ML.above(editor, {
            match: (0,utils_2bbfbd32_node_react_server_esm.n)("list-item")
        });
        const list = slate_dist/* Editor */.ML.above(editor, {
            match: isListNode
        });
        if (listItem && list) {
            return {
                isInside: true,
                listItem,
                list
            };
        }
    }
    return {
        isInside: false
    };
}
function withList(editor) {
    const { insertBreak, normalizeNode, deleteBackward } = editor;
    editor.deleteBackward = (unit)=>{
        if (editor.selection) {
            const ancestorList = getAncestorList(editor);
            if (ancestorList.isInside && slate_dist/* Range */.e6.isCollapsed(editor.selection) && slate_dist/* Editor */.ML.isStart(editor, editor.selection.anchor, ancestorList.list[1])) {
                slate_dist/* Transforms */.YR.unwrapNodes(editor, {
                    match: isListNode,
                    split: true
                });
                return;
            }
        }
        deleteBackward(unit);
    };
    editor.insertBreak = ()=>{
        const [listItem] = slate_dist/* Editor */.ML.nodes(editor, {
            match: (node)=>node.type === "list-item",
            mode: "lowest"
        });
        if (listItem && slate_dist/* Node */.NB.string(listItem[0]) === "") {
            slate_dist/* Transforms */.YR.unwrapNodes(editor, {
                match: isListNode,
                split: true
            });
            return;
        }
        insertBreak();
    };
    editor.normalizeNode = (entry)=>{
        const [node, path] = entry;
        if (slate_dist/* Element */.W_.isElement(node) || slate_dist/* Editor */.ML.isEditor(node)) {
            const isElementBeingNormalizedAList = isListNode(node);
            for (const [childNode, childPath] of slate_dist/* Node */.NB.children(editor, path)){
                const index = childPath[childPath.length - 1];
                // merge sibling lists
                if (isListNode(childNode)) {
                    var _node$children;
                    if (((_node$children = node.children[childPath[childPath.length - 1] + 1]) === null || _node$children === void 0 ? void 0 : _node$children.type) === childNode.type) {
                        const siblingNodePath = slate_dist/* Path */.y$.next(childPath);
                        (0,utils_2bbfbd32_node_react_server_esm.m)(editor, siblingNodePath, [
                            ...childPath,
                            childNode.children.length
                        ]);
                        slate_dist/* Transforms */.YR.removeNodes(editor, {
                            at: siblingNodePath
                        });
                        return;
                    }
                    if (isElementBeingNormalizedAList) {
                        const previousChild = node.children[index - 1];
                        if (slate_dist/* Element */.W_.isElement(previousChild)) {
                            slate_dist/* Transforms */.YR.moveNodes(editor, {
                                at: childPath,
                                to: [
                                    ...slate_dist/* Path */.y$.previous(childPath),
                                    previousChild.children.length - 1
                                ]
                            });
                        } else {
                            slate_dist/* Transforms */.YR.unwrapNodes(editor, {
                                at: childPath
                            });
                        }
                        return;
                    }
                }
                if (node.type === "list-item" && childNode.type !== "list-item-content" && index === 0 && (0,utils_2bbfbd32_node_react_server_esm.i)(childNode)) {
                    if (path[path.length - 1] !== 0) {
                        const previousChild = slate_dist/* Node */.NB.get(editor, slate_dist/* Path */.y$.previous(path));
                        if (slate_dist/* Element */.W_.isElement(previousChild)) {
                            slate_dist/* Transforms */.YR.moveNodes(editor, {
                                at: path,
                                to: [
                                    ...slate_dist/* Path */.y$.previous(path),
                                    previousChild.children.length
                                ]
                            });
                            return;
                        }
                    }
                    slate_dist/* Transforms */.YR.unwrapNodes(editor, {
                        at: childPath
                    });
                    return;
                }
                if (node.type === "list-item" && childNode.type === "list-item-content" && index !== 0) {
                    slate_dist/* Transforms */.YR.splitNodes(editor, {
                        at: childPath
                    });
                    return;
                }
            }
        }
        normalizeNode(entry);
    };
    return editor;
}
function order(a, b) {
    return {
        start: Math.min(a, b),
        end: Math.max(a, b)
    };
}
function getRelativeRowPath(hasHead, rowIndex) {
    return hasHead ? rowIndex === 0 ? [
        0,
        0
    ] : [
        1,
        rowIndex - 1
    ] : [
        0,
        rowIndex
    ];
}
function getSelectedTableArea(editor) {
    var _Editor$above, _editor$selection, _Editor$above2, _editor$selection2;
    const anchor = (_Editor$above = slate_dist/* Editor */.ML.above(editor, {
        match: (0,utils_2bbfbd32_node_react_server_esm.n)("table-cell"),
        at: (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.anchor.path
    })) === null || _Editor$above === void 0 ? void 0 : _Editor$above[1];
    const focus = (_Editor$above2 = slate_dist/* Editor */.ML.above(editor, {
        match: (0,utils_2bbfbd32_node_react_server_esm.n)("table-cell"),
        at: (_editor$selection2 = editor.selection) === null || _editor$selection2 === void 0 ? void 0 : _editor$selection2.focus.path
    })) === null || _Editor$above2 === void 0 ? void 0 : _Editor$above2[1];
    const table = slate_dist/* Editor */.ML.above(editor, {
        match: (0,utils_2bbfbd32_node_react_server_esm.n)("table")
    });
    if (editor.selection && table && slate_dist/* Element */.W_.isElement(table[0].children[0]) && anchor && focus && slate_dist/* Path */.y$.equals(anchor.slice(0, -3), focus.slice(0, -3))) {
        const [start, end] = slate_dist/* Editor */.ML.edges(editor, editor.selection);
        return {
            tablePath: table[1],
            table: table[0],
            singleCell: slate_dist/* Path */.y$.equals(anchor, focus) ? slate_dist/* Point */.E9.equals(slate_dist/* Editor */.ML.start(editor, anchor), start) && slate_dist/* Point */.E9.equals(slate_dist/* Editor */.ML.end(editor, anchor), end) && !slate_dist/* Point */.E9.equals(start, end) ? "selected" : "not-selected" : "many",
            row: order(anchor[anchor.length - 2] + anchor[anchor.length - 3], focus[focus.length - 2] + focus[anchor.length - 3]),
            column: order(anchor[anchor.length - 1], focus[focus.length - 1])
        };
    }
}
const cell = (header)=>({
        type: "table-cell",
        ...header ? {
            header: true
        } : {},
        children: [
            {
                type: "paragraph",
                children: [
                    {
                        text: ""
                    }
                ]
            }
        ]
    });
function cloneDescendant(node) {
    if (slate_dist/* Text */.xv.isText(node)) return {
        ...node
    };
    return {
        ...node,
        children: node.children.map(cloneDescendant)
    };
}
function withTable(editor) {
    const { deleteFragment, normalizeNode, getFragment, insertFragment, deleteBackward } = editor;
    editor.insertFragment = (fragment)=>{
        const selectedTableArea = getSelectedTableArea(editor);
        if (!selectedTableArea || fragment.length !== 1 || fragment[0].type !== "table") {
            insertFragment(fragment);
            return;
        }
        const newRows = fragment[0].children.flatMap((child)=>child.type === "table-head" || child.type === "table-body" ? child.children : []);
        if (!newRows.every((0,utils_2bbfbd32_node_react_server_esm.n)("table-row"))) {
            insertFragment(fragment);
            return;
        }
        let { row, column, tablePath, table } = selectedTableArea;
        const existingBody = selectedTableArea.table.children[selectedTableArea.table.children.length === 1 ? 0 : 1];
        if (newRows[0].type !== "table-row" || existingBody.type !== "table-body" || existingBody.children[0].type !== "table-row") {
            insertFragment(fragment);
            return;
        }
        const hasHead = table.children[0].type === "table-head";
        if (selectedTableArea.singleCell !== "many") {
            row = {
                start: row.start,
                end: Math.min(row.start + newRows.length - 1, existingBody.children.length - 1 + (hasHead ? 1 : 0))
            };
            column = {
                start: column.start,
                end: Math.min(column.start + newRows[0].children.length - 1, existingBody.children[0].children.length - 1)
            };
        }
        slate_dist/* Editor */.ML.withoutNormalizing(editor, ()=>{
            for(let rowIndex = row.start; rowIndex <= row.end; rowIndex++){
                const newRow = newRows[(rowIndex - row.start) % newRows.length];
                for(let cellIndex = column.start; cellIndex <= column.end; cellIndex++){
                    const relativeCellPath = [
                        ...getRelativeRowPath(hasHead, rowIndex),
                        cellIndex
                    ];
                    const cell = slate_dist/* Node */.NB.get(table, relativeCellPath);
                    const newCell = newRow.children[(cellIndex - column.start) % newRow.children.length];
                    if (cell.type !== "table-cell" || newCell.type !== "table-cell") {
                        continue;
                    }
                    const cellPath = [
                        ...tablePath,
                        ...relativeCellPath
                    ];
                    for (const childIdx of [
                        ...cell.children.keys()
                    ].reverse()){
                        slate_dist/* Transforms */.YR.removeNodes(editor, {
                            at: [
                                ...cellPath,
                                childIdx
                            ]
                        });
                    }
                    slate_dist/* Transforms */.YR.insertNodes(editor, newCell.children.map(cloneDescendant), {
                        at: [
                            ...cellPath,
                            0
                        ]
                    });
                }
            }
            slate_dist/* Transforms */.YR.setSelection(editor, {
                anchor: slate_dist/* Editor */.ML.start(editor, [
                    ...tablePath,
                    ...getRelativeRowPath(hasHead, row.start),
                    column.start
                ]),
                focus: slate_dist/* Editor */.ML.end(editor, [
                    ...tablePath,
                    ...getRelativeRowPath(hasHead, row.end),
                    column.end
                ])
            });
        });
    };
    editor.deleteBackward = (unit)=>{
        if (editor.selection && slate_dist/* Range */.e6.isCollapsed(editor.selection) && editor.selection.anchor.offset === 0) {
            const tableCell = slate_dist/* Editor */.ML.above(editor, {
                match: (0,utils_2bbfbd32_node_react_server_esm.n)("table-cell")
            });
            if (tableCell && tableCell[0].children[0].type === "paragraph" && tableCell[0].children[0].children[0].type === undefined && slate_dist/* Path */.y$.equals(editor.selection.anchor.path, [
                ...tableCell[1],
                0,
                0
            ])) {
                return;
            }
        }
        deleteBackward(unit);
    };
    editor.getFragment = ()=>{
        const selectedTableArea = getSelectedTableArea(editor);
        if (selectedTableArea && selectedTableArea.singleCell !== "not-selected") {
            var _table$children$;
            const { table } = selectedTableArea;
            const first = table.children[0].type === "table-head" || table.children[0].type === "table-body" ? table.children[0] : undefined;
            if (!first) {
                return getFragment();
            }
            const second = ((_table$children$ = table.children[1]) === null || _table$children$ === void 0 ? void 0 : _table$children$.type) === "table-body" ? table.children[1] : undefined;
            const body = second || first;
            const hasHead = first.type === "table-head";
            const isSelectionInHead = selectedTableArea.row.start === 0 && !!second;
            const columnLength = selectedTableArea.column.end - selectedTableArea.column.start + 1;
            return [
                {
                    type: "table",
                    children: [
                        ...isSelectionInHead ? [
                            {
                                type: "table-head",
                                children: [
                                    {
                                        type: "table-row",
                                        children: Array.from({
                                            length: columnLength
                                        }).map((_, columnIndex)=>first.children[0].children[columnIndex + selectedTableArea.column.start])
                                    }
                                ]
                            }
                        ] : [],
                        {
                            type: "table-body",
                            children: Array.from({
                                length: selectedTableArea.row.end - selectedTableArea.row.start + (isSelectionInHead ? 0 : 1)
                            }).map((_, rowIndex)=>({
                                    type: "table-row",
                                    children: Array.from({
                                        length: columnLength
                                    }).map((_, columnIndex)=>body.children[rowIndex + selectedTableArea.row.start - (hasHead && !isSelectionInHead ? 1 : 0)].children[columnIndex + selectedTableArea.column.start])
                                }))
                        }
                    ]
                }
            ];
        }
        return getFragment();
    };
    editor.deleteFragment = (direction)=>{
        if (!editor.selection || slate_dist/* Range */.e6.isCollapsed(editor.selection)) {
            deleteFragment(direction);
            return;
        }
        const selectedTableArea = getSelectedTableArea(editor);
        if (!selectedTableArea || selectedTableArea.singleCell === "not-selected") {
            deleteFragment(direction);
            return;
        }
        const headOrBody = selectedTableArea.table.children[0];
        if (!slate_dist/* Element */.W_.isElement(headOrBody) || !slate_dist/* Element */.W_.isElement(headOrBody.children[0])) {
            deleteFragment(direction);
            return;
        }
        const maxRowIdx = selectedTableArea.table.children.reduce((sum, headOrBody)=>sum + (headOrBody.type === "table-head" || headOrBody.type === "table-body" ? headOrBody.children.length : 0), 0) - 1;
        const { row, column, tablePath } = selectedTableArea;
        // note the fact that hasWholeColumnSelected uses row and hasWholeRowSelected uses column
        // is not a mistake. if a whole column has been selected, then the starting row is 0 and the end is the last row
        const hasWholeColumnSelected = row.start === 0 && row.end === maxRowIdx;
        const hasWholeRowSelected = column.start === 0 && column.end === headOrBody.children[0].children.length - 1;
        if (hasWholeColumnSelected && hasWholeRowSelected) {
            slate_dist/* Transforms */.YR.removeNodes(editor, {
                at: tablePath
            });
            return;
        }
        const hasHead = headOrBody.type === "table-head";
        if (hasWholeRowSelected) {
            slate_dist/* Editor */.ML.withoutNormalizing(editor, ()=>{
                for(let i = row.end; i >= row.start; i--){
                    if (hasHead) {
                        if (i === 0) {
                            slate_dist/* Transforms */.YR.removeNodes(editor, {
                                at: [
                                    ...tablePath,
                                    0
                                ]
                            });
                            continue;
                        }
                        slate_dist/* Transforms */.YR.removeNodes(editor, {
                            at: [
                                ...tablePath,
                                1,
                                i - 1
                            ]
                        });
                        continue;
                    }
                    slate_dist/* Transforms */.YR.removeNodes(editor, {
                        at: [
                            ...tablePath,
                            0,
                            i
                        ]
                    });
                }
            });
            return;
        }
        if (hasWholeColumnSelected) {
            slate_dist/* Editor */.ML.withoutNormalizing(editor, ()=>{
                for(let i = column.end; i >= column.start; i--){
                    for(let rowIdx = 0; rowIdx <= maxRowIdx; rowIdx++){
                        slate_dist/* Transforms */.YR.removeNodes(editor, {
                            at: [
                                ...tablePath,
                                ...getRelativeRowPath(hasHead, rowIdx),
                                i
                            ]
                        });
                    }
                }
                const selectionPath = [
                    ...tablePath,
                    0,
                    0,
                    column.start
                ];
                const point = slate_dist/* Editor */.ML.start(editor, column.start === 0 ? selectionPath : slate_dist/* Path */.y$.previous(selectionPath));
                slate_dist/* Transforms */.YR.select(editor, point);
            });
            return;
        }
        const selectionStart = slate_dist/* Editor */.ML.start(editor, editor.selection).path;
        slate_dist/* Editor */.ML.withoutNormalizing(editor, ()=>{
            for(let rowIndex = row.start; rowIndex <= row.end; rowIndex++){
                for(let cellIndex = column.start; cellIndex <= column.end; cellIndex++){
                    const relativeCellPath = [
                        ...getRelativeRowPath(hasHead, rowIndex),
                        cellIndex
                    ];
                    const cell = slate_dist/* Node */.NB.get(selectedTableArea.table, relativeCellPath);
                    if (!slate_dist/* Element */.W_.isElement(cell)) {
                        continue;
                    }
                    const cellPath = [
                        ...tablePath,
                        ...relativeCellPath
                    ];
                    slate_dist/* Transforms */.YR.insertNodes(editor, {
                        type: "paragraph",
                        children: [
                            {
                                text: ""
                            }
                        ]
                    }, {
                        at: [
                            ...cellPath,
                            0
                        ]
                    });
                    for (const childIdx of [
                        ...cell.children.keys()
                    ].reverse()){
                        slate_dist/* Transforms */.YR.removeNodes(editor, {
                            at: [
                                ...cellPath,
                                childIdx + 1
                            ]
                        });
                    }
                }
            }
            slate_dist/* Transforms */.YR.select(editor, selectionStart);
        });
    };
    editor.normalizeNode = (entry)=>{
        const [node, path] = entry;
        if (node.type === "table-head" && node.children.length > 1) {
            (0,utils_2bbfbd32_node_react_server_esm.m)(editor, path, slate_dist/* Path */.y$.next(path), (_, i)=>i !== 0);
            return;
        }
        let didUpdateThings = false;
        for (const parent of [
            "table-body",
            "table-head"
        ]){
            if (node.type === parent) {
                for (const [rowIdx, row] of node.children.entries()){
                    if (row.type === "table-row") {
                        for (const [cellIdx, cell] of row.children.entries()){
                            if (cell.type === "table-cell") {
                                const at = [
                                    ...path,
                                    rowIdx,
                                    cellIdx
                                ];
                                if (cell.header && parent === "table-body") {
                                    slate_dist/* Transforms */.YR.unsetNodes(editor, "header", {
                                        at
                                    });
                                    didUpdateThings = true;
                                }
                                if (!cell.header && parent === "table-head") {
                                    slate_dist/* Transforms */.YR.setNodes(editor, {
                                        header: true
                                    }, {
                                        at
                                    });
                                    didUpdateThings = true;
                                }
                            }
                        }
                    }
                }
            }
        }
        if (didUpdateThings) {
            return;
        }
        if (node.type === "table") {
            const maxRowCount = node.children.reduce((max, node)=>node.type === "table-head" || node.type === "table-body" ? node.children.reduce((max, node)=>node.type === "table-row" ? Math.max(max, node.children.length) : max, max) : max, 0);
            let didInsert = false;
            for (const [idx, child] of node.children.entries()){
                if (child.type === "table-body" || child.type === "table-head") {
                    for (const [rowIdx, row] of child.children.entries()){
                        if (row.type === "table-row" && row.children.length !== maxRowCount) {
                            slate_dist/* Transforms */.YR.insertNodes(editor, Array.from({
                                length: maxRowCount - row.children.length
                            }, ()=>cell(child.type === "table-head")), {
                                at: [
                                    ...path,
                                    idx,
                                    rowIdx,
                                    row.children.length
                                ]
                            });
                            didInsert = true;
                        }
                    }
                }
            }
            if (didInsert) {
                return;
            }
            if (node.children.length === 1 && node.children[0].type === "table-head") {
                slate_dist/* Transforms */.YR.insertNodes(editor, {
                    type: "table-body",
                    children: Array.from({
                        length: node.children[0].children.length
                    }, ()=>cell(false))
                }, {
                    at: [
                        ...path,
                        1
                    ]
                });
                return;
            }
            if (node.children.length === 2 && node.children[1].type === "table-head") {
                slate_dist/* Transforms */.YR.moveNodes(editor, {
                    at: [
                        ...path,
                        1
                    ],
                    to: [
                        ...path,
                        0
                    ]
                });
                return;
            }
            if (node.children.length > 2) {
                (0,utils_2bbfbd32_node_react_server_esm.m)(editor, path, slate_dist/* Path */.y$.next(path), (_, i)=>i !== 0 && i !== 1);
                return;
            }
        }
        normalizeNode(entry);
    };
    return editor;
}
function createDocumentEditorForNormalization(documentFeatures, componentBlocks) {
    return _createDocumentEditor((0,slate_dist/* createEditor */.Jh)(), documentFeatures, componentBlocks);
}
function _createDocumentEditor(baseEditor, documentFeatures, componentBlocks) {
    return withBlocksSchema(withParagraphs(withLink(documentFeatures, componentBlocks, withList(withTable(withComponentBlocks(componentBlocks, documentFeatures, withVoidElements(withLayouts(withCodeBlock(documentFeatures, componentBlocks, withDocumentFeaturesNormalization(documentFeatures, baseEditor))))))))));
}
function withBlocksSchema(editor) {
    const { normalizeNode } = editor;
    editor.normalizeNode = (_ref)=>{
        let [node, path] = _ref;
        if (!slate_dist/* Text */.xv.isText(node) && node.type !== "link") {
            const nodeType = slate_dist/* Editor */.ML.isEditor(node) ? "editor" : node.type;
            if (typeof nodeType !== "string" || utils_2bbfbd32_node_react_server_esm.e[nodeType] === undefined) {
                slate_dist/* Transforms */.YR.unwrapNodes(editor, {
                    at: path
                });
                return;
            }
            const info = utils_2bbfbd32_node_react_server_esm.e[nodeType];
            if (info.kind === "blocks" && node.children.length !== 0 && node.children.every((child)=>!(0,utils_2bbfbd32_node_react_server_esm.i)(child))) {
                slate_dist/* Transforms */.YR.wrapNodes(editor, {
                    type: info.blockToWrapInlinesIn,
                    children: []
                }, {
                    at: path,
                    match: (node)=>!(0,utils_2bbfbd32_node_react_server_esm.i)(node)
                });
                return;
            }
            let didUpdate = false;
            for (const [index, childNode] of [
                ...node.children.entries()
            ].reverse()){
                const childPath = [
                    ...path,
                    index
                ];
                if (info.kind === "inlines") {
                    if (!slate_dist/* Text */.xv.isText(childNode) && (0,utils_2bbfbd32_node_react_server_esm.i)(childNode)) {
                        handleNodeInInvalidPosition(editor, [
                            childNode,
                            childPath
                        ], path);
                        didUpdate = true;
                        continue;
                    }
                } else {
                    if (!(0,utils_2bbfbd32_node_react_server_esm.i)(childNode)) {
                        slate_dist/* Transforms */.YR.wrapNodes(editor, {
                            type: info.blockToWrapInlinesIn,
                            children: []
                        }, {
                            at: childPath
                        });
                        didUpdate = true;
                        continue;
                    }
                    if (!info.allowedChildren.has(childNode.type)) {
                        handleNodeInInvalidPosition(editor, [
                            childNode,
                            childPath
                        ], path);
                        didUpdate = true;
                        continue;
                    }
                }
            }
            if (didUpdate) {
                return;
            }
        }
        normalizeNode([
            node,
            path
        ]);
    };
    return editor;
}
function handleNodeInInvalidPosition(editor, _ref2, ancestorPath) {
    let [node, path] = _ref2;
    const nodeType = node.type;
    const childNodeInfo = utils_2bbfbd32_node_react_server_esm.e[nodeType];
    // the parent of a block will never be an inline so this casting is okay
    const ancestorNode = slate_dist/* Node */.NB.get(editor, ancestorPath);
    const parentNodeType = slate_dist/* Editor */.ML.isEditor(ancestorNode) ? "editor" : ancestorNode.type;
    const parentNodeInfo = utils_2bbfbd32_node_react_server_esm.e[parentNodeType];
    if (!childNodeInfo || childNodeInfo.invalidPositionHandleMode === "unwrap") {
        if (parentNodeInfo.kind === "blocks" && parentNodeInfo.blockToWrapInlinesIn) {
            slate_dist/* Transforms */.YR.setNodes(editor, {
                type: parentNodeInfo.blockToWrapInlinesIn,
                ...Object.fromEntries(Object.keys(node).filter((key)=>key !== "type" && key !== "children").map((key)=>[
                        key,
                        null
                    ])) // the Slate types don't understand that null is allowed and it will unset properties with setNodes
            }, {
                at: path
            });
            return;
        }
        slate_dist/* Transforms */.YR.unwrapNodes(editor, {
            at: path
        });
        return;
    }
    const info = utils_2bbfbd32_node_react_server_esm.e[ancestorNode.type || "editor"];
    if ((info === null || info === void 0 ? void 0 : info.kind) === "blocks" && info.allowedChildren.has(nodeType)) {
        if (ancestorPath.length === 0) {
            slate_dist/* Transforms */.YR.moveNodes(editor, {
                at: path,
                to: [
                    path[0] + 1
                ]
            });
        } else {
            slate_dist/* Transforms */.YR.moveNodes(editor, {
                at: path,
                to: slate_dist/* Path */.y$.next(ancestorPath)
            });
        }
        return;
    }
    if (slate_dist/* Editor */.ML.isEditor(ancestorNode)) {
        slate_dist/* Transforms */.YR.moveNodes(editor, {
            at: path,
            to: [
                path[0] + 1
            ]
        });
        slate_dist/* Transforms */.YR.unwrapNodes(editor, {
            at: [
                path[0] + 1
            ]
        });
        return;
    }
    handleNodeInInvalidPosition(editor, [
        node,
        path
    ], ancestorPath.slice(0, -1));
}
function withVoidElements(editor) {
    const { isVoid } = editor;
    editor.isVoid = (node)=>{
        return node.type === "divider" || node.type === "image" || isVoid(node);
    };
    return editor;
}
const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();
const defaultAltField = (0,index_7a5cd0db_node_react_server_esm.t)({
    label: "Alt text",
    description: "This text will be used by screen readers and search engines."
});
const emptyTitleField = (0,utils_ff285f26_node_react_server_esm.b)({
    Input () {
        return null;
    },
    defaultValue () {
        return "";
    },
    parse (value) {
        if (value === undefined) return "";
        if (typeof value !== "string") {
            throw new error_ca8f88e5_node_react_server_esm.F("Must be string");
        }
        return value;
    },
    validate (value) {
        return value;
    },
    serialize (value) {
        return {
            value
        };
    }
});
function normaliseDocumentFeatures(config) {
    var _config$formatting, _formatting$alignment, _formatting$alignment2, _formatting$blockType, _formatting$inlineMar, _formatting$inlineMar2, _formatting$inlineMar3, _formatting$inlineMar4, _formatting$inlineMar5, _formatting$inlineMar6, _formatting$inlineMar7, _formatting$inlineMar8, _formatting$listTypes, _formatting$listTypes2, _imagesConfig$schema$, _imagesConfig$schema, _imagesConfig$schema$2, _imagesConfig$schema2;
    const formatting = config.formatting === true ? {
        alignment: true,
        blockTypes: true,
        headingLevels: true,
        inlineMarks: true,
        listTypes: true,
        softBreaks: true
    } : (_config$formatting = config.formatting) !== null && _config$formatting !== void 0 ? _config$formatting : {};
    const imagesConfig = config.images === true ? {} : config.images;
    return {
        formatting: {
            alignment: formatting.alignment === true ? {
                center: true,
                end: true
            } : {
                center: !!((_formatting$alignment = formatting.alignment) !== null && _formatting$alignment !== void 0 && _formatting$alignment.center),
                end: !!((_formatting$alignment2 = formatting.alignment) !== null && _formatting$alignment2 !== void 0 && _formatting$alignment2.end)
            },
            blockTypes: (formatting === null || formatting === void 0 ? void 0 : formatting.blockTypes) === true ? {
                blockquote: true,
                code: {
                    schema: (0,utils_677addd9_node_react_server_esm.o)({})
                }
            } : {
                blockquote: !!((_formatting$blockType = formatting.blockTypes) !== null && _formatting$blockType !== void 0 && _formatting$blockType.blockquote),
                code: (()=>{
                    var _formatting$blockType2;
                    if (((_formatting$blockType2 = formatting.blockTypes) === null || _formatting$blockType2 === void 0 ? void 0 : _formatting$blockType2.code) === undefined) {
                        return false;
                    }
                    if (formatting.blockTypes.code === true || !formatting.blockTypes.code.schema) {
                        return {
                            schema: (0,utils_677addd9_node_react_server_esm.o)({})
                        };
                    }
                    for (const key of [
                        "type",
                        "children",
                        "language"
                    ]){
                        if (key in formatting.blockTypes.code.schema) {
                            throw new Error(`"${key}" cannot be a key in the schema for code blocks`);
                        }
                    }
                    return {
                        schema: (0,utils_677addd9_node_react_server_esm.o)(formatting.blockTypes.code.schema)
                    };
                })()
            },
            headings: (()=>{
                var _obj$schema;
                const opt = formatting === null || formatting === void 0 ? void 0 : formatting.headingLevels;
                const obj = typeof opt === "object" && "levels" in opt ? opt : {
                    levels: opt,
                    schema: undefined
                };
                if (obj.schema) {
                    for (const key of [
                        "type",
                        "children",
                        "level",
                        "textAlign"
                    ]){
                        if (key in obj.schema) {
                            throw new Error(`"${key}" cannot be a key in the schema for headings`);
                        }
                    }
                }
                return {
                    levels: [
                        ...new Set(obj.levels === true ? [
                            1,
                            2,
                            3,
                            4,
                            5,
                            6
                        ] : obj.levels)
                    ],
                    schema: (0,utils_677addd9_node_react_server_esm.o)((_obj$schema = obj.schema) !== null && _obj$schema !== void 0 ? _obj$schema : {})
                };
            })(),
            inlineMarks: formatting.inlineMarks === true ? {
                bold: true,
                code: true,
                italic: true,
                keyboard: true,
                strikethrough: true,
                subscript: true,
                superscript: true,
                underline: true
            } : {
                bold: !!((_formatting$inlineMar = formatting.inlineMarks) !== null && _formatting$inlineMar !== void 0 && _formatting$inlineMar.bold),
                code: !!((_formatting$inlineMar2 = formatting.inlineMarks) !== null && _formatting$inlineMar2 !== void 0 && _formatting$inlineMar2.code),
                italic: !!((_formatting$inlineMar3 = formatting.inlineMarks) !== null && _formatting$inlineMar3 !== void 0 && _formatting$inlineMar3.italic),
                strikethrough: !!((_formatting$inlineMar4 = formatting.inlineMarks) !== null && _formatting$inlineMar4 !== void 0 && _formatting$inlineMar4.strikethrough),
                underline: !!((_formatting$inlineMar5 = formatting.inlineMarks) !== null && _formatting$inlineMar5 !== void 0 && _formatting$inlineMar5.underline),
                keyboard: !!((_formatting$inlineMar6 = formatting.inlineMarks) !== null && _formatting$inlineMar6 !== void 0 && _formatting$inlineMar6.keyboard),
                subscript: !!((_formatting$inlineMar7 = formatting.inlineMarks) !== null && _formatting$inlineMar7 !== void 0 && _formatting$inlineMar7.subscript),
                superscript: !!((_formatting$inlineMar8 = formatting.inlineMarks) !== null && _formatting$inlineMar8 !== void 0 && _formatting$inlineMar8.superscript)
            },
            listTypes: formatting.listTypes === true ? {
                ordered: true,
                unordered: true
            } : {
                ordered: !!((_formatting$listTypes = formatting.listTypes) !== null && _formatting$listTypes !== void 0 && _formatting$listTypes.ordered),
                unordered: !!((_formatting$listTypes2 = formatting.listTypes) !== null && _formatting$listTypes2 !== void 0 && _formatting$listTypes2.unordered)
            },
            softBreaks: !!formatting.softBreaks
        },
        links: !!config.links,
        layouts: [
            ...new Set((config.layouts || []).map((x)=>JSON.stringify(x)))
        ].map((x)=>JSON.parse(x)),
        dividers: !!config.dividers,
        images: imagesConfig === undefined ? false : {
            ...imagesConfig,
            schema: {
                alt: (_imagesConfig$schema$ = (_imagesConfig$schema = imagesConfig.schema) === null || _imagesConfig$schema === void 0 ? void 0 : _imagesConfig$schema.alt) !== null && _imagesConfig$schema$ !== void 0 ? _imagesConfig$schema$ : defaultAltField,
                title: (_imagesConfig$schema$2 = (_imagesConfig$schema2 = imagesConfig.schema) === null || _imagesConfig$schema2 === void 0 ? void 0 : _imagesConfig$schema2.title) !== null && _imagesConfig$schema$2 !== void 0 ? _imagesConfig$schema$2 : emptyTitleField
            }
        },
        tables: !!config.tables
    };
}
function index_36a0dcb1_node_react_server_esm_document(_ref) {
    let { label, componentBlocks = {}, description, ...documentFeaturesConfig } = _ref;
    const documentFeatures = normaliseDocumentFeatures(documentFeaturesConfig);
    const parse = (mode)=>(_value, data)=>{
            const markdoc = textDecoder.decode(data.content);
            const document = fromMarkdoc(dist_default().parse(markdoc), componentBlocks);
            const editor = createDocumentEditorForNormalization(documentFeatures, componentBlocks);
            editor.children = document;
            slate_dist/* Editor */.ML.normalize(editor, {
                force: true
            });
            return deserializeFiles(editor.children, componentBlocks, data.other, data.external || new Map(), mode, documentFeatures, data.slug);
        };
    return {
        kind: "form",
        formKind: "content",
        defaultValue () {
            return [
                {
                    type: "paragraph",
                    children: [
                        {
                            text: ""
                        }
                    ]
                }
            ];
        },
        Input (props) {
            return /*#__PURE__*/ (0,jsx_runtime_.jsx)(ui_1f1aa184_node_react_server_esm/* DocumentFieldInput */.d, {
                componentBlocks: componentBlocks,
                description: description,
                label: label,
                documentFeatures: documentFeatures,
                ...props
            });
        },
        parse: parse("edit"),
        contentExtension: ".mdoc",
        validate (value) {
            return value;
        },
        directories: [
            ...(0,utils_677addd9_node_react_server_esm.B)((0,utils_677addd9_node_react_server_esm.o)(Object.fromEntries(Object.entries(componentBlocks).map((_ref2)=>{
                let [name, block] = _ref2;
                return [
                    name,
                    (0,utils_677addd9_node_react_server_esm.o)(block.schema)
                ];
            })))),
            ...typeof documentFeatures.images === "object" && typeof documentFeatures.images.directory === "string" ? [
                documentFeatures.images.directory
            ] : []
        ],
        serialize (value, opts) {
            const { extraFiles, node } = toMarkdocDocument(value, {
                componentBlocks,
                documentFeatures,
                slug: opts.slug
            });
            const other = new Map();
            const external = new Map();
            for (const file of extraFiles){
                if (file.parent === undefined) {
                    other.set(file.path, file.contents);
                    continue;
                }
                if (!external.has(file.parent)) {
                    external.set(file.parent, new Map());
                }
                external.get(file.parent).set(file.path, file.contents);
            }
            return {
                content: textEncoder.encode(dist_default().format(dist_default().parse(dist_default().format(node)))),
                other,
                external,
                value: undefined
            };
        },
        reader: {
            parse: parse("read")
        }
    };
}



/***/ }),

/***/ 32159:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   t: () => (/* binding */ text),
/* harmony export */   v: () => (/* binding */ validateText)
/* harmony export */ });
/* harmony import */ var _error_ca8f88e5_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(79646);
/* harmony import */ var _ui_78a3a4f0_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27449);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56786);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__);



function validateText(val, min, max, fieldLabel, slugInfo) {
    if (val.length < min) {
        if (min === 1) {
            return `${fieldLabel} must not be empty`;
        } else {
            return `${fieldLabel} must be at least ${min} characters long`;
        }
    }
    if (val.length > max) {
        return `${fieldLabel} must be no longer than ${max} characters`;
    }
    if (slugInfo) {
        if (val === "") {
            return `${fieldLabel} must not be empty`;
        }
        if (val === "..") {
            return `${fieldLabel} must not be ..`;
        }
        if (val === ".") {
            return `${fieldLabel} must not be .`;
        }
        if (slugInfo.glob === "**") {
            const split = val.split("/");
            if (split.some((s)=>s === "..")) {
                return `${fieldLabel} must not contain ..`;
            }
            if (split.some((s)=>s === ".")) {
                return `${fieldLabel} must not be .`;
            }
        }
        if ((slugInfo.glob === "*" ? /[\\/]/ : /[\\]/).test(val)) {
            return `${fieldLabel} must not contain slashes`;
        }
        if (slugInfo.slugs.has(val)) {
            return `${fieldLabel} must be unique`;
        }
    }
}
function parseAsNormalField(value) {
    if (value === undefined) {
        return "";
    }
    if (typeof value !== "string") {
        throw new _error_ca8f88e5_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.F("Must be a string");
    }
    return value;
}
const emptySet = new Set();
function text(_ref) {
    let { label, defaultValue = "", validation: { length: { max = Infinity, min = 0 } = {} } = {}, description, multiline = false } = _ref;
    function validate(value, slugField) {
        const message = validateText(value, min, max, label, slugField);
        if (message !== undefined) {
            throw new _error_ca8f88e5_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_2__.F(message);
        }
        return value;
    }
    return {
        kind: "form",
        formKind: "slug",
        Input (props) {
            return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_ui_78a3a4f0_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__/* .TextFieldInput */ .Nl, {
                label: label,
                description: description,
                min: min,
                max: max,
                multiline: multiline,
                ...props
            });
        },
        defaultValue () {
            return typeof defaultValue === "string" ? defaultValue : defaultValue();
        },
        parse (value, args) {
            if ((args === null || args === void 0 ? void 0 : args.slug) !== undefined) {
                return args.slug;
            }
            return parseAsNormalField(value);
        },
        serialize (value) {
            return {
                value: value === "" ? undefined : value
            };
        },
        serializeWithSlug (value) {
            return {
                slug: value,
                value: undefined
            };
        },
        reader: {
            parse (value) {
                const parsed = parseAsNormalField(value);
                return validate(parsed, undefined);
            },
            parseWithSlug (_value, args) {
                validate(parseAsNormalField(args.slug), {
                    glob: args.glob,
                    slugs: emptySet
                });
                return null;
            }
        },
        validate (value, args) {
            return validate(value, args === null || args === void 0 ? void 0 : args.slugField);
        }
    };
}



/***/ }),

/***/ 26136:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ getKeysForArrayValue),
/* harmony export */   b: () => (/* binding */ getInitialPropsValueFromInitializer),
/* harmony export */   c: () => (/* binding */ getNewArrayElementKey),
/* harmony export */   g: () => (/* binding */ getInitialPropsValue),
/* harmony export */   s: () => (/* binding */ setKeysForArrayValue)
/* harmony export */ });
/* unused harmony export u */
/* harmony import */ var emery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45603);

const arrayValuesToElementKeys = new WeakMap();
let counter = 0;
function getKeysForArrayValue(value) {
    if (!arrayValuesToElementKeys.has(value)) {
        arrayValuesToElementKeys.set(value, Array.from({
            length: value.length
        }, getNewArrayElementKey));
    }
    return arrayValuesToElementKeys.get(value);
}
function setKeysForArrayValue(value, elementIds) {
    arrayValuesToElementKeys.set(value, elementIds);
}
function getNewArrayElementKey() {
    return (counter++).toString();
}
const getInitialPropsValue = _getInitialPropsValue;
function _getInitialPropsValue(schema) {
    switch(schema.kind){
        case "form":
            return schema.defaultValue();
        case "child":
            return null;
        case "conditional":
            {
                const defaultValue = schema.discriminant.defaultValue();
                return {
                    discriminant: defaultValue,
                    value: getInitialPropsValue(schema.values[defaultValue.toString()])
                };
            }
        case "object":
            {
                const obj = {};
                for (const key of Object.keys(schema.fields)){
                    obj[key] = getInitialPropsValue(schema.fields[key]);
                }
                return obj;
            }
        case "array":
            {
                return [];
            }
    }
    (0,emery__WEBPACK_IMPORTED_MODULE_0__.assertNever)(schema);
}
function getInitialPropsValueFromInitializer(schema, initializer) {
    switch(schema.kind){
        case "form":
            return initializer === undefined ? schema.defaultValue() : initializer;
        case "child":
            return null;
        case "conditional":
            {
                const defaultValue = initializer === undefined ? schema.discriminant.defaultValue() : initializer.discriminant;
                return {
                    discriminant: defaultValue,
                    value: getInitialPropsValueFromInitializer(schema.values[defaultValue.toString()], initializer === undefined ? undefined : initializer.value)
                };
            }
        case "object":
            {
                const obj = {};
                for (const key of Object.keys(schema.fields)){
                    obj[key] = getInitialPropsValueFromInitializer(schema.fields[key], initializer === undefined ? undefined : initializer[key]);
                }
                return obj;
            }
        case "array":
            {
                return (initializer !== null && initializer !== void 0 ? initializer : []).map((x)=>getInitialPropsValueFromInitializer(schema.element, x.value));
            }
    }
    (0,emery__WEBPACK_IMPORTED_MODULE_0__.assertNever)(schema);
}
function updateValue(schema, currentValue, updater) {
    if (updater === undefined) return currentValue;
    switch(schema.kind){
        case "form":
            return updater;
        case "child":
            return null;
        case "conditional":
            {
                return {
                    discriminant: updater.discriminant,
                    value: updater.discriminant === currentValue.discriminant ? updateValue(schema.values[updater.discriminant.toString()], currentValue.value, updater.value) : getInitialPropsValueFromInitializer(schema.values[updater.discriminant.toString()], updater.value)
                };
            }
        case "object":
            {
                const obj = {};
                for (const key of Object.keys(schema.fields)){
                    obj[key] = updateValue(schema.fields[key], currentValue[key], updater[key]);
                }
                return obj;
            }
        case "array":
            {
                const currentArrVal = currentValue;
                const newVal = updater;
                const uniqueKeys = new Set();
                for (const x of newVal){
                    if (x.key !== undefined) {
                        if (uniqueKeys.has(x.key)) {
                            throw new Error("Array elements must have unique keys");
                        }
                        uniqueKeys.add(x.key);
                    }
                }
                const keys = newVal.map((x)=>{
                    if (x.key !== undefined) return x.key;
                    let elementKey = getNewArrayElementKey();
                    // just in case someone gives a key that is above our counter
                    while(uniqueKeys.has(elementKey)){
                        elementKey = getNewArrayElementKey();
                    }
                    uniqueKeys.add(elementKey);
                    return elementKey;
                });
                const prevKeys = getKeysForArrayValue(currentArrVal);
                const prevValuesByKey = new Map(currentArrVal.map((value, i)=>{
                    return [
                        prevKeys[i],
                        value
                    ];
                }));
                const val = newVal.map((x, i)=>{
                    const id = keys[i];
                    if (prevValuesByKey.has(id)) {
                        return updateValue(schema.element, prevValuesByKey.get(id), x.value);
                    }
                    return getInitialPropsValueFromInitializer(schema.element, x.value);
                });
                setKeysForArrayValue(val, keys);
                return val;
            }
    }
    assertNever(schema);
}



/***/ }),

/***/ 34708:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  hJ: () => (/* binding */ collection),
  vc: () => (/* binding */ config),
  XU: () => (/* binding */ index),
  ri: () => (/* binding */ singleton)
});

// UNUSED EXPORTS: BlockWrapper, NotEditable, ToolbarSeparator, component

// EXTERNAL MODULE: ../node_modules/@keystar/ui/checkbox/dist/keystar-ui-checkbox.esm.js
var keystar_ui_checkbox_esm = __webpack_require__(69286);
// EXTERNAL MODULE: ../node_modules/@keystar/ui/typography/dist/keystar-ui-typography.esm.js
var keystar_ui_typography_esm = __webpack_require__(57646);
// EXTERNAL MODULE: external "next/dist/compiled/react/jsx-runtime"
var jsx_runtime_ = __webpack_require__(56786);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/ui-b1673cee.node.react-server.esm.js
var ui_b1673cee_node_react_server_esm = __webpack_require__(55788);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/index-36a0dcb1.node.react-server.esm.js + 1 modules
var index_36a0dcb1_node_react_server_esm = __webpack_require__(77619);
// EXTERNAL MODULE: ../node_modules/emery/dist/emery.cjs.js
var emery_cjs = __webpack_require__(45603);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/ui-32b334fd.node.react-server.esm.js
var ui_32b334fd_node_react_server_esm = __webpack_require__(90253);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/ui-58f594ec.node.react-server.esm.js
var ui_58f594ec_node_react_server_esm = __webpack_require__(35887);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/ui-1b838e41.node.react-server.esm.js
var ui_1b838e41_node_react_server_esm = __webpack_require__(36034);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/ui-4365cc36.node.react-server.esm.js
var ui_4365cc36_node_react_server_esm = __webpack_require__(78936);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/ui-fa32ff3c.node.react-server.esm.js
var ui_fa32ff3c_node_react_server_esm = __webpack_require__(30227);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/ui-4f76db75.node.react-server.esm.js
var ui_4f76db75_node_react_server_esm = __webpack_require__(69753);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/ui-23d3b9aa.node.react-server.esm.js
var ui_23d3b9aa_node_react_server_esm = __webpack_require__(79097);
// EXTERNAL MODULE: ../node_modules/@sindresorhus/slugify/index.js
var slugify = __webpack_require__(66615);
var slugify_default = /*#__PURE__*/__webpack_require__.n(slugify);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/ui-78a3a4f0.node.react-server.esm.js
var ui_78a3a4f0_node_react_server_esm = __webpack_require__(27449);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/ui-c44da0bc.node.react-server.esm.js
var ui_c44da0bc_node_react_server_esm = __webpack_require__(38566);
// EXTERNAL MODULE: ../node_modules/@braintree/sanitize-url/dist/index.js
var dist = __webpack_require__(69797);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/ui-949db933.node.react-server.esm.js
var ui_949db933_node_react_server_esm = __webpack_require__(45192);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/ui-6ea72555.node.react-server.esm.js
var ui_6ea72555_node_react_server_esm = __webpack_require__(97313);
// EXTERNAL MODULE: ../node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js
var module_proxy = __webpack_require__(21572);
;// CONCATENATED MODULE: ../node_modules/@keystatic/core/dist/index-ec0a153a.node.react-server.esm.js

const proxy = (0,module_proxy.createProxy)(String.raw`/Users/sukhpreetsingh/apps/q1b-v2/node_modules/@keystatic/core/dist/index-ec0a153a.node.react-server.esm.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = proxy["ActiveBlockPopoverProvider"];

const e1 = proxy["BlockPopover"];

const e2 = proxy["BlockPopoverTrigger"];

const e3 = proxy["BlockWrapper"];

const e4 = proxy["NotEditable"];

const e5 = proxy["ToolbarSeparator"];

const e6 = proxy["useActiveBlockPopover"];

// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/error-ca8f88e5.node.react-server.esm.js
var error_ca8f88e5_node_react_server_esm = __webpack_require__(79646);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/utils-ff285f26.node.react-server.esm.js
var utils_ff285f26_node_react_server_esm = __webpack_require__(33794);
;// CONCATENATED MODULE: ../node_modules/@keystatic/core/dist/index-a3fe1512.node.react-server.esm.js




function validateDate(validation, value, label) {
    if (value !== null && !/^\d{4}-\d{2}-\d{2}$/.test(value)) {
        return `${label} is not a valid date`;
    }
    if (validation !== null && validation !== void 0 && validation.isRequired && value === null) {
        return `${label} is required`;
    }
    if ((validation !== null && validation !== void 0 && validation.min || validation !== null && validation !== void 0 && validation.max) && value !== null) {
        const date = new Date(value);
        if ((validation === null || validation === void 0 ? void 0 : validation.min) !== undefined) {
            const min = new Date(validation.min);
            if (date < min) {
                return `${label} must be after ${min.toLocaleDateString()}`;
            }
        }
        if ((validation === null || validation === void 0 ? void 0 : validation.max) !== undefined) {
            const max = new Date(validation.max);
            if (date > max) {
                return `${label} must be no later than ${max.toLocaleDateString()}`;
            }
        }
    }
}
function date(_ref) {
    let { label, defaultValue, validation, description } = _ref;
    return (0,utils_ff285f26_node_react_server_esm.b)({
        Input (props) {
            return /*#__PURE__*/ (0,jsx_runtime_.jsx)(ui_b1673cee_node_react_server_esm/* DateFieldInput */.o, {
                validation: validation,
                label: label,
                description: description,
                ...props
            });
        },
        defaultValue () {
            if (defaultValue === undefined) {
                return null;
            }
            if (typeof defaultValue === "string") {
                return defaultValue;
            }
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, "0");
            const day = String(today.getDate()).padStart(2, "0");
            return `${year}-${month}-${day}`;
        },
        parse (value) {
            if (value === undefined) {
                return null;
            }
            if (typeof value !== "string") {
                throw new error_ca8f88e5_node_react_server_esm.F("Must be a string");
            }
            return value;
        },
        serialize (value) {
            return {
                value: value === null ? undefined : value
            };
        },
        validate (value) {
            const message = validateDate(validation, value, label);
            if (message !== undefined) {
                throw new error_ca8f88e5_node_react_server_esm.F(message);
            }
            (0,utils_ff285f26_node_react_server_esm.a)(value, validation, label);
            return value;
        }
    });
}


// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/utils-677addd9.node.react-server.esm.js
var utils_677addd9_node_react_server_esm = __webpack_require__(32186);
;// CONCATENATED MODULE: ../node_modules/@keystatic/core/dist/index-ca4f7ef7.node.react-server.esm.js




function validateInteger(validation, value, label) {
    if (value !== null && (typeof value !== "number" || !Number.isFinite(value))) {
        return `${label} is not a valid whole number`;
    }
    if (validation !== null && validation !== void 0 && validation.isRequired && value === null) {
        return `${label} is required`;
    }
    if (value !== null) {
        if ((validation === null || validation === void 0 ? void 0 : validation.min) !== undefined && value < validation.min) {
            return `${label} must be at least ${validation.min}`;
        }
        if ((validation === null || validation === void 0 ? void 0 : validation.max) !== undefined && value > validation.max) {
            return `${label} must be at most ${validation.max}`;
        }
    }
}
function integer(_ref) {
    let { label, defaultValue, validation, description } = _ref;
    return (0,utils_ff285f26_node_react_server_esm.b)({
        Input (props) {
            return /*#__PURE__*/ (0,jsx_runtime_.jsx)(ui_1b838e41_node_react_server_esm/* IntegerFieldInput */.E, {
                label: label,
                description: description,
                validation: validation,
                ...props
            });
        },
        defaultValue () {
            return defaultValue !== null && defaultValue !== void 0 ? defaultValue : null;
        },
        parse (value) {
            if (value === undefined) {
                return null;
            }
            if (typeof value === "number") {
                return value;
            }
            throw new error_ca8f88e5_node_react_server_esm.F("Must be a number");
        },
        validate (value) {
            const message = validateInteger(validation, value, label);
            if (message !== undefined) {
                throw new error_ca8f88e5_node_react_server_esm.F(message);
            }
            (0,utils_ff285f26_node_react_server_esm.a)(value, validation, label);
            return value;
        },
        serialize (value) {
            return {
                value: value === null ? undefined : value
            };
        }
    });
}


// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/index-7a5cd0db.node.react-server.esm.js
var index_7a5cd0db_node_react_server_esm = __webpack_require__(32159);
;// CONCATENATED MODULE: ../node_modules/@keystatic/core/dist/isValidURL-02af2848.node.react-server.esm.js

function isValidURL(url) {
    return url === (0,dist/* sanitizeUrl */.N)(url);
}


;// CONCATENATED MODULE: ../node_modules/@keystatic/core/dist/index-27182009.node.react-server.esm.js





function validateUrl(validation, value, label) {
    if (value !== null && (typeof value !== "string" || !isValidURL(value))) {
        return `${label} is not a valid URL`;
    }
    if (validation !== null && validation !== void 0 && validation.isRequired && value === null) {
        return `${label} is required`;
    }
}
function url(_ref) {
    let { label, defaultValue = "", validation, description } = _ref;
    return (0,utils_ff285f26_node_react_server_esm.b)({
        Input (props) {
            return /*#__PURE__*/ (0,jsx_runtime_.jsx)(ui_949db933_node_react_server_esm/* UrlFieldInput */.i, {
                label: label,
                description: description,
                validation: validation,
                ...props
            });
        },
        defaultValue () {
            return defaultValue !== null && defaultValue !== void 0 ? defaultValue : null;
        },
        parse (value) {
            if (value === undefined) {
                return null;
            }
            if (typeof value !== "string") {
                throw new error_ca8f88e5_node_react_server_esm.F("Must be a string");
            }
            return value;
        },
        validate (value) {
            const message = validateUrl(validation, value, label);
            if (message !== undefined) {
                throw new error_ca8f88e5_node_react_server_esm.F(message);
            }
            (0,utils_ff285f26_node_react_server_esm.a)(value, validation, label);
            return value;
        },
        serialize (value) {
            return {
                value: value === null ? undefined : value
            };
        }
    });
}


// EXTERNAL MODULE: ../node_modules/emery/assertions/dist/emery-assertions.cjs.js
var emery_assertions_cjs = __webpack_require__(42220);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/initial-values-25bf35f4.node.react-server.esm.js
var initial_values_25bf35f4_node_react_server_esm = __webpack_require__(26136);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/ui-1f1aa184.node.react-server.esm.js
var ui_1f1aa184_node_react_server_esm = __webpack_require__(63688);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/utils-2bbfbd32.node.react-server.esm.js
var utils_2bbfbd32_node_react_server_esm = __webpack_require__(91001);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/languages-14058067.node.react-server.esm.js
var languages_14058067_node_react_server_esm = __webpack_require__(94438);
// EXTERNAL MODULE: ../node_modules/@keystatic/core/dist/prism-e4e5bc8f.node.react-server.esm.js
var prism_e4e5bc8f_node_react_server_esm = __webpack_require__(48006);
// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6113);
;// CONCATENATED MODULE: ../node_modules/@keystatic/core/dist/keystatic-core.node.react-server.esm.js







































function array(element, opts) {
    var _opts$label;
    return {
        kind: "array",
        element,
        label: (_opts$label = opts === null || opts === void 0 ? void 0 : opts.label) !== null && _opts$label !== void 0 ? _opts$label : "Items",
        description: opts === null || opts === void 0 ? void 0 : opts.description,
        itemLabel: opts === null || opts === void 0 ? void 0 : opts.itemLabel,
        asChildTag: opts === null || opts === void 0 ? void 0 : opts.asChildTag,
        slugField: opts === null || opts === void 0 ? void 0 : opts.slugField,
        validation: opts === null || opts === void 0 ? void 0 : opts.validation
    };
}
function keystatic_core_node_react_server_esm_checkbox(_ref) {
    let { label, defaultValue = false, description } = _ref;
    return (0,utils_ff285f26_node_react_server_esm.b)({
        Input (_ref2) {
            let { value, onChange, autoFocus } = _ref2;
            return /*#__PURE__*/ (0,jsx_runtime_.jsxs)(keystar_ui_checkbox_esm/* Checkbox */.X, {
                isSelected: value,
                onChange: onChange,
                autoFocus: autoFocus,
                children: [
                    /*#__PURE__*/ (0,jsx_runtime_.jsx)(keystar_ui_typography_esm/* Text */.xv, {
                        children: label
                    }),
                    description && /*#__PURE__*/ (0,jsx_runtime_.jsx)(keystar_ui_typography_esm/* Text */.xv, {
                        slot: "description",
                        children: description
                    })
                ]
            });
        },
        defaultValue () {
            return defaultValue;
        },
        parse (value) {
            if (value === undefined) return defaultValue;
            if (typeof value !== "boolean") {
                throw new error_ca8f88e5_node_react_server_esm.F("Must be a boolean");
            }
            return value;
        },
        validate (value) {
            return value;
        },
        serialize (value) {
            return {
                value
            };
        }
    });
}
function child(options) {
    return {
        kind: "child",
        options: options.kind === "block" ? {
            kind: "block",
            placeholder: options.placeholder,
            dividers: options.dividers,
            formatting: options.formatting === "inherit" ? {
                blockTypes: "inherit",
                headingLevels: "inherit",
                inlineMarks: "inherit",
                listTypes: "inherit",
                alignment: "inherit",
                softBreaks: "inherit"
            } : options.formatting,
            links: options.links,
            images: options.images,
            tables: options.tables,
            componentBlocks: options.componentBlocks
        } : {
            kind: "inline",
            placeholder: options.placeholder,
            formatting: options.formatting === "inherit" ? {
                inlineMarks: "inherit",
                softBreaks: "inherit"
            } : options.formatting,
            links: options.links
        }
    };
}
function conditional(discriminant, values) {
    return {
        kind: "conditional",
        discriminant,
        values: values
    };
}
function emptyDocument() {
    return {
        kind: "form",
        formKind: "content",
        Input () {
            return null;
        },
        defaultValue () {
            return null;
        },
        parse () {
            return null;
        },
        contentExtension: ".mdoc",
        serialize () {
            return {
                value: undefined,
                content: new Uint8Array(),
                external: new Map(),
                other: new Map()
            };
        },
        validate (value) {
            return value;
        },
        reader: {
            parse () {
                return null;
            }
        }
    };
}
function empty() {
    return (0,utils_ff285f26_node_react_server_esm.b)({
        Input () {
            return null;
        },
        defaultValue () {
            return null;
        },
        parse () {
            return null;
        },
        serialize () {
            return {
                value: undefined
            };
        },
        validate (value) {
            return value;
        }
    });
}
function file(_ref) {
    let { label, directory, validation, description, publicPath } = _ref;
    return {
        kind: "form",
        formKind: "asset",
        Input (props) {
            return /*#__PURE__*/ (0,jsx_runtime_.jsx)(ui_58f594ec_node_react_server_esm/* FileFieldInput */.n, {
                label: label,
                description: description,
                validation: validation,
                ...props
            });
        },
        defaultValue () {
            return null;
        },
        filename (value, args) {
            if (typeof value === "string") {
                return value.slice(getSrcPrefix(publicPath, args.slug).length);
            }
            return undefined;
        },
        parse (value, args) {
            var _value$match$, _value$match;
            if (value === undefined) {
                return null;
            }
            if (typeof value !== "string") {
                throw new error_ca8f88e5_node_react_server_esm.F("Must be a string");
            }
            if (args.asset === undefined) {
                return null;
            }
            return {
                data: args.asset,
                filename: value.slice(getSrcPrefix(publicPath, args.slug).length),
                extension: (_value$match$ = (_value$match = value.match(/\.([^.]+$)/)) === null || _value$match === void 0 ? void 0 : _value$match[1]) !== null && _value$match$ !== void 0 ? _value$match$ : ""
            };
        },
        validate (value) {
            (0,utils_ff285f26_node_react_server_esm.a)(value, validation, label);
            return value;
        },
        serialize (value, args) {
            if (value === null) {
                return {
                    value: undefined,
                    asset: undefined
                };
            }
            const filename = args.suggestedFilenamePrefix ? args.suggestedFilenamePrefix + "." + value.extension : value.filename;
            return {
                value: `${getSrcPrefix(publicPath, args.slug)}${filename}`,
                asset: {
                    filename,
                    content: value.data
                }
            };
        },
        directory: directory ? (0,utils_677addd9_node_react_server_esm.A)(directory) : undefined,
        reader: {
            parse (value) {
                if (typeof value !== "string" && value !== undefined) {
                    throw new error_ca8f88e5_node_react_server_esm.F("Must be a string");
                }
                const val = value === undefined ? null : value;
                (0,utils_ff285f26_node_react_server_esm.a)(val, validation, label);
                return val;
            }
        }
    };
}
function getSrcPrefix(publicPath, slug) {
    return typeof publicPath === "string" ? `/${(0,utils_677addd9_node_react_server_esm.A)(publicPath)}/${slug === undefined ? "" : slug + "/"}` : "";
}
function multiselect(_ref) {
    let { label, options, defaultValue = [], description } = _ref;
    const valuesToOption = new Map(options.map((x)=>[
            x.value,
            x
        ]));
    const field = (0,utils_ff285f26_node_react_server_esm.b)({
        Input (props) {
            return /*#__PURE__*/ (0,jsx_runtime_.jsx)(ui_4365cc36_node_react_server_esm/* MultiselectFieldInput */.W, {
                label: label,
                description: description,
                options: options,
                ...props
            });
        },
        defaultValue () {
            return defaultValue;
        },
        parse (value) {
            if (value === undefined) {
                return [];
            }
            if (!Array.isArray(value)) {
                throw new error_ca8f88e5_node_react_server_esm.F("Must be an array of options");
            }
            if (!value.every((x)=>typeof x === "string" && valuesToOption.has(x))) {
                throw new error_ca8f88e5_node_react_server_esm.F(`Must be an array with one of ${options.map((x)=>x.value).join(", ")}`);
            }
            return value;
        },
        validate (value) {
            return value;
        },
        serialize (value) {
            return {
                value
            };
        }
    });
    return {
        ...field,
        options
    };
}
function pathReference(_ref) {
    let { label, pattern, validation, description } = _ref;
    return (0,utils_ff285f26_node_react_server_esm.b)({
        Input (props) {
            return /*#__PURE__*/ (0,jsx_runtime_.jsx)(ui_fa32ff3c_node_react_server_esm/* PathReferenceInput */.V, {
                label: label,
                pattern: pattern,
                description: description,
                validation: validation,
                ...props
            });
        },
        defaultValue () {
            return null;
        },
        parse (value) {
            if (value === undefined) {
                return null;
            }
            if (typeof value !== "string") {
                throw new error_ca8f88e5_node_react_server_esm.F("Must be a string");
            }
            return value;
        },
        validate (value) {
            (0,utils_ff285f26_node_react_server_esm.a)(value, validation, label);
            return value;
        },
        serialize (value) {
            return {
                value: value === null ? undefined : value
            };
        }
    });
}
function relationship(_ref) {
    let { label, collection, validation, description } = _ref;
    return (0,utils_ff285f26_node_react_server_esm.b)({
        Input (props) {
            return /*#__PURE__*/ (0,jsx_runtime_.jsx)(ui_4f76db75_node_react_server_esm/* RelationshipInput */.Y, {
                label: label,
                collection: collection,
                description: description,
                validation: validation,
                ...props
            });
        },
        defaultValue () {
            return null;
        },
        parse (value) {
            if (value === undefined) {
                return null;
            }
            if (typeof value !== "string") {
                throw new error_ca8f88e5_node_react_server_esm.F("Must be a string");
            }
            return value;
        },
        validate (value) {
            (0,utils_ff285f26_node_react_server_esm.a)(value, validation, label);
            return value;
        },
        serialize (value) {
            return {
                value: value === null ? undefined : value
            };
        }
    });
}
function keystatic_core_node_react_server_esm_select(_ref) {
    let { label, options, defaultValue, description } = _ref;
    const optionValuesSet = new Set(options.map((x)=>x.value));
    if (!optionValuesSet.has(defaultValue)) {
        throw new Error(`A defaultValue of ${defaultValue} was provided to a select field but it does not match the value of one of the options provided`);
    }
    const field = (0,utils_ff285f26_node_react_server_esm.b)({
        Input (props) {
            return /*#__PURE__*/ (0,jsx_runtime_.jsx)(ui_23d3b9aa_node_react_server_esm/* SelectFieldInput */.W, {
                label: label,
                options: options,
                description: description,
                ...props
            });
        },
        defaultValue () {
            return defaultValue;
        },
        parse (value) {
            if (value === undefined) {
                return defaultValue;
            }
            if (typeof value !== "string") {
                throw new error_ca8f88e5_node_react_server_esm.F("Must be a string");
            }
            if (!optionValuesSet.has(value)) {
                throw new error_ca8f88e5_node_react_server_esm.F("Must be a valid option");
            }
            return value;
        },
        validate (value) {
            return value;
        },
        serialize (value) {
            return {
                value
            };
        }
    });
    return {
        ...field,
        options
    };
}
function parseSlugFieldAsNormalField(value) {
    if (value === undefined) {
        return {
            name: "",
            slug: ""
        };
    }
    if (typeof value !== "object") {
        throw new error_ca8f88e5_node_react_server_esm.F("Must be an object");
    }
    if (Object.keys(value).length !== 2) {
        throw new error_ca8f88e5_node_react_server_esm.F("Unexpected keys");
    }
    if (!("name" in value) || !("slug" in value)) {
        throw new error_ca8f88e5_node_react_server_esm.F("Missing name or slug");
    }
    if (typeof value.name !== "string") {
        throw new error_ca8f88e5_node_react_server_esm.F("name must be a string");
    }
    if (typeof value.slug !== "string") {
        throw new error_ca8f88e5_node_react_server_esm.F("slug must be a string");
    }
    return {
        name: value.name,
        slug: value.slug
    };
}
function parseAsSlugField(value, slug) {
    if (value === undefined) {
        return {
            name: "",
            slug
        };
    }
    if (typeof value !== "string") {
        throw new error_ca8f88e5_node_react_server_esm.F("Must be a string");
    }
    return {
        name: value,
        slug
    };
}
function slug(args) {
    var _args$slug, _args$name$defaultVal, _args$name$defaultVal2;
    const naiveGenerateSlug = ((_args$slug = args.slug) === null || _args$slug === void 0 ? void 0 : _args$slug.generate) || (slugify_default());
    const defaultValue = {
        name: (_args$name$defaultVal = args.name.defaultValue) !== null && _args$name$defaultVal !== void 0 ? _args$name$defaultVal : "",
        slug: naiveGenerateSlug((_args$name$defaultVal2 = args.name.defaultValue) !== null && _args$name$defaultVal2 !== void 0 ? _args$name$defaultVal2 : "")
    };
    function validate(value) {
        var _args$name$validation, _args$name$validation2, _args$name$validation3, _args$name$validation4, _args$name$validation5, _args$name$validation6, _args$slug$validation, _args$slug2, _args$slug2$validatio, _args$slug2$validatio2, _args$slug$validation2, _args$slug3, _args$slug3$validatio, _args$slug3$validatio2, _args$slug$label, _args$slug4;
        let { slugField } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            slugField: undefined
        };
        const nameMessage = (0,index_7a5cd0db_node_react_server_esm.v)(value.name, (_args$name$validation = (_args$name$validation2 = args.name.validation) === null || _args$name$validation2 === void 0 ? void 0 : (_args$name$validation3 = _args$name$validation2.length) === null || _args$name$validation3 === void 0 ? void 0 : _args$name$validation3.min) !== null && _args$name$validation !== void 0 ? _args$name$validation : 0, (_args$name$validation4 = (_args$name$validation5 = args.name.validation) === null || _args$name$validation5 === void 0 ? void 0 : (_args$name$validation6 = _args$name$validation5.length) === null || _args$name$validation6 === void 0 ? void 0 : _args$name$validation6.max) !== null && _args$name$validation4 !== void 0 ? _args$name$validation4 : Infinity, args.name.label, undefined);
        if (nameMessage !== undefined) {
            throw new error_ca8f88e5_node_react_server_esm.F(nameMessage);
        }
        const slugMessage = (0,index_7a5cd0db_node_react_server_esm.v)(value.slug, (_args$slug$validation = (_args$slug2 = args.slug) === null || _args$slug2 === void 0 ? void 0 : (_args$slug2$validatio = _args$slug2.validation) === null || _args$slug2$validatio === void 0 ? void 0 : (_args$slug2$validatio2 = _args$slug2$validatio.length) === null || _args$slug2$validatio2 === void 0 ? void 0 : _args$slug2$validatio2.min) !== null && _args$slug$validation !== void 0 ? _args$slug$validation : 1, (_args$slug$validation2 = (_args$slug3 = args.slug) === null || _args$slug3 === void 0 ? void 0 : (_args$slug3$validatio = _args$slug3.validation) === null || _args$slug3$validatio === void 0 ? void 0 : (_args$slug3$validatio2 = _args$slug3$validatio.length) === null || _args$slug3$validatio2 === void 0 ? void 0 : _args$slug3$validatio2.max) !== null && _args$slug$validation2 !== void 0 ? _args$slug$validation2 : Infinity, (_args$slug$label = (_args$slug4 = args.slug) === null || _args$slug4 === void 0 ? void 0 : _args$slug4.label) !== null && _args$slug$label !== void 0 ? _args$slug$label : "Slug", slugField ? slugField : {
            slugs: emptySet,
            glob: "*"
        });
        if (slugMessage !== undefined) {
            throw new error_ca8f88e5_node_react_server_esm.F(slugMessage);
        }
        return value;
    }
    const emptySet = new Set();
    return {
        kind: "form",
        formKind: "slug",
        Input (props) {
            return /*#__PURE__*/ (0,jsx_runtime_.jsx)(ui_c44da0bc_node_react_server_esm/* SlugFieldInput */.E, {
                args: args,
                naiveGenerateSlug: naiveGenerateSlug,
                defaultValue: defaultValue,
                ...props
            });
        },
        defaultValue () {
            return defaultValue;
        },
        parse (value, args) {
            if ((args === null || args === void 0 ? void 0 : args.slug) !== undefined) {
                return parseAsSlugField(value, args.slug);
            }
            return parseSlugFieldAsNormalField(value);
        },
        validate,
        serialize (value) {
            return {
                value
            };
        },
        serializeWithSlug (value) {
            return {
                value: value.name,
                slug: value.slug
            };
        },
        reader: {
            parse (value) {
                const parsed = parseSlugFieldAsNormalField(value);
                return validate(parsed);
            },
            parseWithSlug (value, args) {
                return validate(parseAsSlugField(value, args.slug), {
                    slugField: {
                        glob: args.glob,
                        slugs: emptySet
                    }
                }).name;
            }
        }
    };
}
function blocks(blocks, opts) {
    const entries = Object.entries(blocks);
    if (!entries.length) {
        throw new Error("fields.blocks must have at least one entry");
    }
    const select$1 = keystatic_core_node_react_server_esm_select({
        label: "Kind",
        defaultValue: entries[0][0],
        options: Object.entries(blocks).map((_ref)=>{
            let [key, { label }] = _ref;
            return {
                label,
                value: key
            };
        })
    });
    const element = conditional(select$1, Object.fromEntries(entries.map((_ref2)=>{
        let [key, { schema }] = _ref2;
        return [
            key,
            schema
        ];
    })));
    return {
        ...array(element, {
            label: opts.label,
            description: opts.description,
            validation: opts.validation,
            itemLabel (props) {
                const kind = props.discriminant;
                const block = blocks[kind];
                if (!block.itemLabel) return block.label;
                return block.itemLabel(props.value);
            }
        }),
        Input: ui_6ea72555_node_react_server_esm/* BlocksFieldInput */.u
    };
}
var index = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    array: array,
    checkbox: keystatic_core_node_react_server_esm_checkbox,
    child: child,
    conditional: conditional,
    date: date,
    document: index_36a0dcb1_node_react_server_esm.d,
    emptyDocument: emptyDocument,
    empty: empty,
    image: index_36a0dcb1_node_react_server_esm.i,
    file: file,
    integer: integer,
    multiselect: multiselect,
    object: utils_677addd9_node_react_server_esm.o,
    pathReference: pathReference,
    relationship: relationship,
    select: keystatic_core_node_react_server_esm_select,
    slug: slug,
    text: index_7a5cd0db_node_react_server_esm.t,
    url: url,
    blocks: blocks
});
// this is written like this rather than ArrayField<ComponentSchema> to avoid TypeScript erroring about circularity
function component(options) {
    return options;
}
function config(config) {
    return config;
}
function collection(collection) {
    return collection;
}
function singleton(collection) {
    return collection;
}



/***/ }),

/***/ 94438:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ aliasesToCanonicalName)
/* harmony export */ });
/* unused harmony exports b, c, d, l */
/* harmony import */ var _prism_e4e5bc8f_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48006);

const languages = [
    {
        label: "C",
        value: "c"
    },
    {
        label: "C++",
        value: "cpp"
    },
    {
        label: "Arduino",
        value: "arduino"
    },
    {
        label: "Bash",
        value: "bash"
    },
    {
        label: "C#",
        value: "csharp"
    },
    {
        label: "CSS",
        value: "css"
    },
    {
        label: "Diff",
        value: "diff"
    },
    {
        label: "Go",
        value: "go"
    },
    {
        label: "INI",
        value: "ini"
    },
    {
        label: "Java",
        value: "java"
    },
    {
        label: "JavaScript",
        value: "javascript"
    },
    {
        label: "JSX",
        value: "jsx"
    },
    {
        label: "JSON",
        value: "json"
    },
    {
        label: "Kotlin",
        value: "kotlin"
    },
    {
        label: "Less",
        value: "less"
    },
    {
        label: "Lua",
        value: "lua"
    },
    {
        label: "Makefile",
        value: "makefile"
    },
    {
        label: "Markdown",
        value: "markdown"
    },
    {
        label: "Objective-C",
        value: "objectivec"
    },
    {
        label: "Perl",
        value: "perl"
    },
    {
        label: "PHP",
        value: "php"
    },
    {
        label: "Python",
        value: "python"
    },
    {
        label: "R",
        value: "r"
    },
    {
        label: "Ruby",
        value: "ruby"
    },
    {
        label: "Rust",
        value: "rust"
    },
    {
        label: "Sass",
        value: "sass"
    },
    {
        label: "SCSS",
        value: "scss"
    },
    {
        label: "SQL",
        value: "sql"
    },
    {
        label: "Swift",
        value: "swift"
    },
    {
        label: "TypeScript",
        value: "typescript"
    },
    {
        label: "TSX",
        value: "tsx"
    },
    {
        label: "VB.NET",
        value: "vbnet"
    },
    {
        label: "YAML",
        value: "yaml"
    }
];
const canonicalNameToLabel = new Map(languages.map((x)=>[
        x.value,
        x.label
    ]));
const labelToCanonicalName = new Map(languages.map((x)=>[
        x.label,
        x.value
    ]));
const languageToCanonicalName = new Map(languages.map((lang)=>[
        _prism_e4e5bc8f_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__.P.languages[lang.value],
        lang.value
    ]));
const aliasesToCanonicalName = new Map(Object.keys(_prism_e4e5bc8f_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__.P.languages).flatMap((lang)=>{
    const canonicalName = languageToCanonicalName.get(_prism_e4e5bc8f_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__.P.languages[lang]);
    if (canonicalName === undefined) {
        return [];
    }
    return [
        [
            lang,
            canonicalName
        ]
    ];
}));
const languagesToAliases = new Map(languages.map((lang)=>[
        lang.value,
        []
    ]));
for (const [alias, canonicalName] of aliasesToCanonicalName){
    languagesToAliases.get(canonicalName).push(alias);
}
const languagesWithAliases = [
    {
        label: "Plain text",
        value: "plain",
        aliases: []
    },
    ...[
        ...languagesToAliases
    ].map((_ref)=>{
        let [canonicalName, aliases] = _ref;
        return {
            label: canonicalNameToLabel.get(canonicalName),
            value: canonicalName,
            aliases
        };
    })
];
const aliasesToLabel = new Map([
    ...aliasesToCanonicalName
].map((_ref2)=>{
    let [alias, canonicalName] = _ref2;
    return [
        alias,
        canonicalNameToLabel.get(canonicalName)
    ];
}));



/***/ }),

/***/ 48006:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   P: () => (/* binding */ Prism)
/* harmony export */ });
/* eslint-disable */ globalThis.Prism = {
    manual: true
};
/* **********************************************
     Begin prism-core.js
********************************************** */ /// <reference lib="WebWorker"/>
var _self = globalThis;
/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */ var Prism = function(_self) {
    // Private helper vars
    var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
    var uniqueId = 0;
    // The grammar object for plaintext
    var plainTextGrammar = {};
    var _ = {
        /**
     * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
     * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
     * additional languages or plugins yourself.
     *
     * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
     *
     * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
     * empty Prism object into the global scope before loading the Prism script like this:
     *
     * ```js
     * window.Prism = window.Prism || {};
     * Prism.manual = true;
     * // add a new <script> to load Prism's script
     * ```
     *
     * @default false
     * @type {boolean}
     * @memberof Prism
     * @public
     */ manual: _self.Prism && _self.Prism.manual,
        /**
     * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
     * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
     * own worker, you don't want it to do this.
     *
     * By setting this value to `true`, Prism will not add its own listeners to the worker.
     *
     * You obviously have to change this value before Prism executes. To do this, you can add an
     * empty Prism object into the global scope before loading the Prism script like this:
     *
     * ```js
     * window.Prism = window.Prism || {};
     * Prism.disableWorkerMessageHandler = true;
     * // Load Prism's script
     * ```
     *
     * @default false
     * @type {boolean}
     * @memberof Prism
     * @public
     */ disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
        /**
     * A namespace for utility methods.
     *
     * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
     * change or disappear at any time.
     *
     * @namespace
     * @memberof Prism
     */ util: {
            encode: function encode(tokens) {
                if (tokens instanceof Token) {
                    return new Token(tokens.type, encode(tokens.content), tokens.alias);
                } else if (Array.isArray(tokens)) {
                    return tokens.map(encode);
                } else {
                    return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
                }
            },
            /**
       * Returns the name of the type of the given value.
       *
       * @param {any} o
       * @returns {string}
       * @example
       * type(null)      === 'Null'
       * type(undefined) === 'Undefined'
       * type(123)       === 'Number'
       * type('foo')     === 'String'
       * type(true)      === 'Boolean'
       * type([1, 2])    === 'Array'
       * type({})        === 'Object'
       * type(String)    === 'Function'
       * type(/abc+/)    === 'RegExp'
       */ type: function(o) {
                return Object.prototype.toString.call(o).slice(8, -1);
            },
            /**
       * Returns a unique number for the given object. Later calls will still return the same number.
       *
       * @param {Object} obj
       * @returns {number}
       */ objId: function(obj) {
                if (!obj["__id"]) {
                    Object.defineProperty(obj, "__id", {
                        value: ++uniqueId
                    });
                }
                return obj["__id"];
            },
            /**
       * Creates a deep clone of the given object.
       *
       * The main intended use of this function is to clone language definitions.
       *
       * @param {T} o
       * @param {Record<number, any>} [visited]
       * @returns {T}
       * @template T
       */ clone: function deepClone(o, visited) {
                visited = visited || {};
                var clone;
                var id;
                switch(_.util.type(o)){
                    case "Object":
                        id = _.util.objId(o);
                        if (visited[id]) {
                            return visited[id];
                        }
                        clone = /** @type {Record<string, any>} */ {};
                        visited[id] = clone;
                        for(var key in o){
                            if (o.hasOwnProperty(key)) {
                                clone[key] = deepClone(o[key], visited);
                            }
                        }
                        return /** @type {any} */ clone;
                    case "Array":
                        id = _.util.objId(o);
                        if (visited[id]) {
                            return visited[id];
                        }
                        clone = [];
                        visited[id] = clone;
                        /** @type {Array} */ /** @type {any} */ o.forEach(function(v, i) {
                            clone[i] = deepClone(v, visited);
                        });
                        return /** @type {any} */ clone;
                    default:
                        return o;
                }
            },
            /**
       * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
       *
       * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
       *
       * @param {Element} element
       * @returns {string}
       */ getLanguage: function(element) {
                while(element){
                    var m = lang.exec(element.className);
                    if (m) {
                        return m[1].toLowerCase();
                    }
                    element = element.parentElement;
                }
                return "none";
            },
            /**
       * Sets the Prism `language-xxxx` class of the given element.
       *
       * @param {Element} element
       * @param {string} language
       * @returns {void}
       */ setLanguage: function(element, language) {
                // remove all `language-xxxx` classes
                // (this might leave behind a leading space)
                element.className = element.className.replace(RegExp(lang, "gi"), "");
                // add the new `language-xxxx` class
                // (using `classList` will automatically clean up spaces for us)
                element.classList.add("language-" + language);
            },
            /**
       * Returns the script element that is currently executing.
       *
       * This does __not__ work for line script element.
       *
       * @returns {HTMLScriptElement | null}
       */ currentScript: function() {
                if (typeof document === "undefined") {
                    return null;
                }
                if ("currentScript" in document && 1 < 2 /* hack to trip TS' flow analysis */ ) {
                    return /** @type {any} */ document.currentScript;
                }
                // IE11 workaround
                // we'll get the src of the current script by parsing IE11's error stack trace
                // this will not work for inline scripts
                try {
                    throw new Error();
                } catch (err) {
                    // Get file src url from stack. Specifically works with the format of stack traces in IE.
                    // A stack will look like this:
                    //
                    // Error
                    //    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
                    //    at Global code (http://localhost/components/prism-core.js:606:1)
                    var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
                    if (src) {
                        var scripts = document.getElementsByTagName("script");
                        for(var i in scripts){
                            if (scripts[i].src == src) {
                                return scripts[i];
                            }
                        }
                    }
                    return null;
                }
            },
            /**
       * Returns whether a given class is active for `element`.
       *
       * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
       * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
       * given class is just the given class with a `no-` prefix.
       *
       * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
       * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
       * ancestors have the given class or the negated version of it, then the default activation will be returned.
       *
       * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
       * version of it, the class is considered active.
       *
       * @param {Element} element
       * @param {string} className
       * @param {boolean} [defaultActivation=false]
       * @returns {boolean}
       */ isActive: function(element, className, defaultActivation) {
                var no = "no-" + className;
                while(element){
                    var classList = element.classList;
                    if (classList.contains(className)) {
                        return true;
                    }
                    if (classList.contains(no)) {
                        return false;
                    }
                    element = element.parentElement;
                }
                return !!defaultActivation;
            }
        },
        /**
     * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
     *
     * @namespace
     * @memberof Prism
     * @public
     */ languages: {
            /**
       * The grammar for plain, unformatted text.
       */ plain: plainTextGrammar,
            plaintext: plainTextGrammar,
            text: plainTextGrammar,
            txt: plainTextGrammar,
            /**
       * Creates a deep copy of the language with the given id and appends the given tokens.
       *
       * If a token in `redef` also appears in the copied language, then the existing token in the copied language
       * will be overwritten at its original position.
       *
       * ## Best practices
       *
       * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
       * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
       * understand the language definition because, normally, the order of tokens matters in Prism grammars.
       *
       * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
       * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
       *
       * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
       * @param {Grammar} redef The new tokens to append.
       * @returns {Grammar} The new language created.
       * @public
       * @example
       * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
       *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
       *     // at its original position
       *     'comment': { ... },
       *     // CSS doesn't have a 'color' token, so this token will be appended
       *     'color': /\b(?:red|green|blue)\b/
       * });
       */ extend: function(id, redef) {
                var lang = _.util.clone(_.languages[id]);
                for(var key in redef){
                    lang[key] = redef[key];
                }
                return lang;
            },
            /**
       * Inserts tokens _before_ another token in a language definition or any other grammar.
       *
       * ## Usage
       *
       * This helper method makes it easy to modify existing languages. For example, the CSS language definition
       * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
       * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
       * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
       * this:
       *
       * ```js
       * Prism.languages.markup.style = {
       *     // token
       * };
       * ```
       *
       * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
       * before existing tokens. For the CSS example above, you would use it like this:
       *
       * ```js
       * Prism.languages.insertBefore('markup', 'cdata', {
       *     'style': {
       *         // token
       *     }
       * });
       * ```
       *
       * ## Special cases
       *
       * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
       * will be ignored.
       *
       * This behavior can be used to insert tokens after `before`:
       *
       * ```js
       * Prism.languages.insertBefore('markup', 'comment', {
       *     'comment': Prism.languages.markup.comment,
       *     // tokens after 'comment'
       * });
       * ```
       *
       * ## Limitations
       *
       * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
       * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
       * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
       * deleting properties which is necessary to insert at arbitrary positions.
       *
       * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
       * Instead, it will create a new object and replace all references to the target object with the new one. This
       * can be done without temporarily deleting properties, so the iteration order is well-defined.
       *
       * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
       * you hold the target object in a variable, then the value of the variable will not change.
       *
       * ```js
       * var oldMarkup = Prism.languages.markup;
       * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
       *
       * assert(oldMarkup !== Prism.languages.markup);
       * assert(newMarkup === Prism.languages.markup);
       * ```
       *
       * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
       * object to be modified.
       * @param {string} before The key to insert before.
       * @param {Grammar} insert An object containing the key-value pairs to be inserted.
       * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
       * object to be modified.
       *
       * Defaults to `Prism.languages`.
       * @returns {Grammar} The new grammar object.
       * @public
       */ insertBefore: function(inside, before, insert, root) {
                root = root || /** @type {any} */ _.languages;
                var grammar = root[inside];
                /** @type {Grammar} */ var ret = {};
                for(var token in grammar){
                    if (grammar.hasOwnProperty(token)) {
                        if (token == before) {
                            for(var newToken in insert){
                                if (insert.hasOwnProperty(newToken)) {
                                    ret[newToken] = insert[newToken];
                                }
                            }
                        }
                        // Do not insert token which also occur in insert. See #1525
                        if (!insert.hasOwnProperty(token)) {
                            ret[token] = grammar[token];
                        }
                    }
                }
                var old = root[inside];
                root[inside] = ret;
                // Update references in other language definitions
                _.languages.DFS(_.languages, function(key, value) {
                    if (value === old && key != inside) {
                        this[key] = ret;
                    }
                });
                return ret;
            },
            // Traverse a language definition with Depth First Search
            DFS: function DFS(o, callback, type, visited) {
                visited = visited || {};
                var objId = _.util.objId;
                for(var i in o){
                    if (o.hasOwnProperty(i)) {
                        callback.call(o, i, o[i], type || i);
                        var property = o[i];
                        var propertyType = _.util.type(property);
                        if (propertyType === "Object" && !visited[objId(property)]) {
                            visited[objId(property)] = true;
                            DFS(property, callback, null, visited);
                        } else if (propertyType === "Array" && !visited[objId(property)]) {
                            visited[objId(property)] = true;
                            DFS(property, callback, i, visited);
                        }
                    }
                }
            }
        },
        plugins: {},
        /**
     * This is the most high-level function in Prisms API.
     * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
     * each one of them.
     *
     * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
     *
     * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
     * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
     * @memberof Prism
     * @public
     */ highlightAll: function(async, callback) {
            _.highlightAllUnder(document, async, callback);
        },
        /**
     * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
     * {@link Prism.highlightElement} on each one of them.
     *
     * The following hooks will be run:
     * 1. `before-highlightall`
     * 2. `before-all-elements-highlight`
     * 3. All hooks of {@link Prism.highlightElement} for each element.
     *
     * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
     * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
     * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
     * @memberof Prism
     * @public
     */ highlightAllUnder: function(container, async, callback) {
            var env = {
                callback: callback,
                container: container,
                selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
            };
            _.hooks.run("before-highlightall", env);
            env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
            _.hooks.run("before-all-elements-highlight", env);
            for(var i = 0, element; element = env.elements[i++];){
                _.highlightElement(element, async === true, env.callback);
            }
        },
        /**
     * Highlights the code inside a single element.
     *
     * The following hooks will be run:
     * 1. `before-sanity-check`
     * 2. `before-highlight`
     * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
     * 4. `before-insert`
     * 5. `after-highlight`
     * 6. `complete`
     *
     * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
     * the element's language.
     *
     * @param {Element} element The element containing the code.
     * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
     * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
     * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
     * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
     *
     * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
     * asynchronous highlighting to work. You can build your own bundle on the
     * [Download page](https://prismjs.com/download.html).
     * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
     * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
     * @memberof Prism
     * @public
     */ highlightElement: function(element, async, callback) {
            // Find language
            var language = _.util.getLanguage(element);
            var grammar = _.languages[language];
            // Set language on the element, if not present
            _.util.setLanguage(element, language);
            // Set language on the parent, for styling
            var parent = element.parentElement;
            if (parent && parent.nodeName.toLowerCase() === "pre") {
                _.util.setLanguage(parent, language);
            }
            var code = element.textContent;
            var env = {
                element: element,
                language: language,
                grammar: grammar,
                code: code
            };
            function insertHighlightedCode(highlightedCode) {
                env.highlightedCode = highlightedCode;
                _.hooks.run("before-insert", env);
                env.element.innerHTML = env.highlightedCode;
                _.hooks.run("after-highlight", env);
                _.hooks.run("complete", env);
                callback && callback.call(env.element);
            }
            _.hooks.run("before-sanity-check", env);
            // plugins may change/add the parent/element
            parent = env.element.parentElement;
            if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
                parent.setAttribute("tabindex", "0");
            }
            if (!env.code) {
                _.hooks.run("complete", env);
                callback && callback.call(env.element);
                return;
            }
            _.hooks.run("before-highlight", env);
            if (!env.grammar) {
                insertHighlightedCode(_.util.encode(env.code));
                return;
            }
            if (async && _self.Worker) {
                var worker = new Worker(_.filename);
                worker.onmessage = function(evt) {
                    insertHighlightedCode(evt.data);
                };
                worker.postMessage(JSON.stringify({
                    language: env.language,
                    code: env.code,
                    immediateClose: true
                }));
            } else {
                insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
            }
        },
        /**
     * Low-level function, only use if you know what youre doing. It accepts a string of text as input
     * and the language definitions to use, and returns a string with the HTML produced.
     *
     * The following hooks will be run:
     * 1. `before-tokenize`
     * 2. `after-tokenize`
     * 3. `wrap`: On each {@link Token}.
     *
     * @param {string} text A string with the code to be highlighted.
     * @param {Grammar} grammar An object containing the tokens to use.
     *
     * Usually a language definition like `Prism.languages.markup`.
     * @param {string} language The name of the language definition passed to `grammar`.
     * @returns {string} The highlighted HTML.
     * @memberof Prism
     * @public
     * @example
     * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
     */ highlight: function(text, grammar, language) {
            var env = {
                code: text,
                grammar: grammar,
                language: language
            };
            _.hooks.run("before-tokenize", env);
            if (!env.grammar) {
                throw new Error('The language "' + env.language + '" has no grammar.');
            }
            env.tokens = _.tokenize(env.code, env.grammar);
            _.hooks.run("after-tokenize", env);
            return Token.stringify(_.util.encode(env.tokens), env.language);
        },
        /**
     * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
     * and the language definitions to use, and returns an array with the tokenized code.
     *
     * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
     *
     * This method could be useful in other contexts as well, as a very crude parser.
     *
     * @param {string} text A string with the code to be highlighted.
     * @param {Grammar} grammar An object containing the tokens to use.
     *
     * Usually a language definition like `Prism.languages.markup`.
     * @returns {TokenStream} An array of strings and tokens, a token stream.
     * @memberof Prism
     * @public
     * @example
     * let code = `var foo = 0;`;
     * let tokens = Prism.tokenize(code, Prism.languages.javascript);
     * tokens.forEach(token => {
     *     if (token instanceof Prism.Token && token.type === 'number') {
     *         console.log(`Found numeric literal: ${token.content}`);
     *     }
     * });
     */ tokenize: function(text, grammar) {
            var rest = grammar.rest;
            if (rest) {
                for(var token in rest){
                    grammar[token] = rest[token];
                }
                delete grammar.rest;
            }
            var tokenList = new LinkedList();
            addAfter(tokenList, tokenList.head, text);
            matchGrammar(text, tokenList, grammar, tokenList.head, 0);
            return toArray(tokenList);
        },
        /**
     * @namespace
     * @memberof Prism
     * @public
     */ hooks: {
            all: {},
            /**
       * Adds the given callback to the list of callbacks for the given hook.
       *
       * The callback will be invoked when the hook it is registered for is run.
       * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
       *
       * One callback function can be registered to multiple hooks and the same hook multiple times.
       *
       * @param {string} name The name of the hook.
       * @param {HookCallback} callback The callback function which is given environment variables.
       * @public
       */ add: function(name, callback) {
                var hooks = _.hooks.all;
                hooks[name] = hooks[name] || [];
                hooks[name].push(callback);
            },
            /**
       * Runs a hook invoking all registered callbacks with the given environment variables.
       *
       * Callbacks will be invoked synchronously and in the order in which they were registered.
       *
       * @param {string} name The name of the hook.
       * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
       * @public
       */ run: function(name, env) {
                var callbacks = _.hooks.all[name];
                if (!callbacks || !callbacks.length) {
                    return;
                }
                for(var i = 0, callback; callback = callbacks[i++];){
                    callback(env);
                }
            }
        },
        Token: Token
    };
    _self.Prism = _;
    // Typescript note:
    // The following can be used to import the Token type in JSDoc:
    //
    //   @typedef {InstanceType<import("./prism-core")["Token"]>} Token
    /**
   * Creates a new token.
   *
   * @param {string} type See {@link Token#type type}
   * @param {string | TokenStream} content See {@link Token#content content}
   * @param {string|string[]} [alias] The alias(es) of the token.
   * @param {string} [matchedStr=""] A copy of the full string this token was created from.
   * @class
   * @global
   * @public
   */ function Token(type, content, alias, matchedStr) {
        /**
     * The type of the token.
     *
     * This is usually the key of a pattern in a {@link Grammar}.
     *
     * @type {string}
     * @see GrammarToken
     * @public
     */ this.type = type;
        /**
     * The strings or tokens contained by this token.
     *
     * This will be a token stream if the pattern matched also defined an `inside` grammar.
     *
     * @type {string | TokenStream}
     * @public
     */ this.content = content;
        /**
     * The alias(es) of the token.
     *
     * @type {string|string[]}
     * @see GrammarToken
     * @public
     */ this.alias = alias;
        // Copy of the full string this token was created from
        this.length = (matchedStr || "").length | 0;
    }
    /**
   * A token stream is an array of strings and {@link Token Token} objects.
   *
   * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
   * them.
   *
   * 1. No adjacent strings.
   * 2. No empty strings.
   *
   *    The only exception here is the token stream that only contains the empty string and nothing else.
   *
   * @typedef {Array<string | Token>} TokenStream
   * @global
   * @public
   */ /**
   * Converts the given token or token stream to an HTML representation.
   *
   * The following hooks will be run:
   * 1. `wrap`: On each {@link Token}.
   *
   * @param {string | Token | TokenStream} o The token or token stream to be converted.
   * @param {string} language The name of current language.
   * @returns {string} The HTML representation of the token or token stream.
   * @memberof Token
   * @static
   */ Token.stringify = function stringify(o, language) {
        if (typeof o == "string") {
            return o;
        }
        if (Array.isArray(o)) {
            var s = "";
            o.forEach(function(e) {
                s += stringify(e, language);
            });
            return s;
        }
        var env = {
            type: o.type,
            content: stringify(o.content, language),
            tag: "span",
            classes: [
                "token",
                o.type
            ],
            attributes: {},
            language: language
        };
        var aliases = o.alias;
        if (aliases) {
            if (Array.isArray(aliases)) {
                Array.prototype.push.apply(env.classes, aliases);
            } else {
                env.classes.push(aliases);
            }
        }
        _.hooks.run("wrap", env);
        var attributes = "";
        for(var name in env.attributes){
            attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
    };
    /**
   * @param {RegExp} pattern
   * @param {number} pos
   * @param {string} text
   * @param {boolean} lookbehind
   * @returns {RegExpExecArray | null}
   */ function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text);
        if (match && lookbehind && match[1]) {
            // change the match to remove the text matched by the Prism lookbehind group
            var lookbehindLength = match[1].length;
            match.index += lookbehindLength;
            match[0] = match[0].slice(lookbehindLength);
        }
        return match;
    }
    /**
   * @param {string} text
   * @param {LinkedList<string | Token>} tokenList
   * @param {any} grammar
   * @param {LinkedListNode<string | Token>} startNode
   * @param {number} startPos
   * @param {RematchOptions} [rematch]
   * @returns {void}
   * @private
   *
   * @typedef RematchOptions
   * @property {string} cause
   * @property {number} reach
   */ function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for(var token in grammar){
            if (!grammar.hasOwnProperty(token) || !grammar[token]) {
                continue;
            }
            var patterns = grammar[token];
            patterns = Array.isArray(patterns) ? patterns : [
                patterns
            ];
            for(var j = 0; j < patterns.length; ++j){
                if (rematch && rematch.cause == token + "," + j) {
                    return;
                }
                var patternObj = patterns[j];
                var inside = patternObj.inside;
                var lookbehind = !!patternObj.lookbehind;
                var greedy = !!patternObj.greedy;
                var alias = patternObj.alias;
                if (greedy && !patternObj.pattern.global) {
                    // Without the global flag, lastIndex won't work
                    var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
                    patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
                }
                /** @type {RegExp} */ var pattern = patternObj.pattern || patternObj;
                for(// iterate the token list and keep track of the current token/string position
                var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next){
                    if (rematch && pos >= rematch.reach) {
                        break;
                    }
                    var str = currentNode.value;
                    if (tokenList.length > text.length) {
                        // Something went terribly wrong, ABORT, ABORT!
                        return;
                    }
                    if (str instanceof Token) {
                        continue;
                    }
                    var removeCount = 1; // this is the to parameter of removeBetween
                    var match;
                    if (greedy) {
                        match = matchPattern(pattern, pos, text, lookbehind);
                        if (!match || match.index >= text.length) {
                            break;
                        }
                        var from = match.index;
                        var to = match.index + match[0].length;
                        var p = pos;
                        // find the node that contains the match
                        p += currentNode.value.length;
                        while(from >= p){
                            currentNode = currentNode.next;
                            p += currentNode.value.length;
                        }
                        // adjust pos (and p)
                        p -= currentNode.value.length;
                        pos = p;
                        // the current node is a Token, then the match starts inside another Token, which is invalid
                        if (currentNode.value instanceof Token) {
                            continue;
                        }
                        // find the last node which is affected by this match
                        for(var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next){
                            removeCount++;
                            p += k.value.length;
                        }
                        removeCount--;
                        // replace with the new match
                        str = text.slice(pos, p);
                        match.index -= pos;
                    } else {
                        match = matchPattern(pattern, 0, str, lookbehind);
                        if (!match) {
                            continue;
                        }
                    }
                    // eslint-disable-next-line no-redeclare
                    var from = match.index;
                    var matchStr = match[0];
                    var before = str.slice(0, from);
                    var after = str.slice(from + matchStr.length);
                    var reach = pos + str.length;
                    if (rematch && reach > rematch.reach) {
                        rematch.reach = reach;
                    }
                    var removeFrom = currentNode.prev;
                    if (before) {
                        removeFrom = addAfter(tokenList, removeFrom, before);
                        pos += before.length;
                    }
                    removeRange(tokenList, removeFrom, removeCount);
                    var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
                    currentNode = addAfter(tokenList, removeFrom, wrapped);
                    if (after) {
                        addAfter(tokenList, currentNode, after);
                    }
                    if (removeCount > 1) {
                        // at least one Token object was removed, so we have to do some rematching
                        // this can only happen if the current pattern is greedy
                        /** @type {RematchOptions} */ var nestedRematch = {
                            cause: token + "," + j,
                            reach: reach
                        };
                        matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                        // the reach might have been extended because of the rematching
                        if (rematch && nestedRematch.reach > rematch.reach) {
                            rematch.reach = nestedRematch.reach;
                        }
                    }
                }
            }
        }
    }
    /**
   * @typedef LinkedListNode
   * @property {T} value
   * @property {LinkedListNode<T> | null} prev The previous node.
   * @property {LinkedListNode<T> | null} next The next node.
   * @template T
   * @private
   */ /**
   * @template T
   * @private
   */ function LinkedList() {
        /** @type {LinkedListNode<T>} */ var head = {
            value: null,
            prev: null,
            next: null
        };
        /** @type {LinkedListNode<T>} */ var tail = {
            value: null,
            prev: head,
            next: null
        };
        head.next = tail;
        /** @type {LinkedListNode<T>} */ this.head = head;
        /** @type {LinkedListNode<T>} */ this.tail = tail;
        this.length = 0;
    }
    /**
   * Adds a new node with the given value to the list.
   *
   * @param {LinkedList<T>} list
   * @param {LinkedListNode<T>} node
   * @param {T} value
   * @returns {LinkedListNode<T>} The added node.
   * @template T
   */ function addAfter(list, node, value) {
        // assumes that node != list.tail && values.length >= 0
        var next = node.next;
        var newNode = {
            value: value,
            prev: node,
            next: next
        };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
    }
    /**
   * Removes `count` nodes after the given node. The given node will not be removed.
   *
   * @param {LinkedList<T>} list
   * @param {LinkedListNode<T>} node
   * @param {number} count
   * @template T
   */ function removeRange(list, node, count) {
        var next = node.next;
        for(var i = 0; i < count && next !== list.tail; i++){
            next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i;
    }
    /**
   * @param {LinkedList<T>} list
   * @returns {T[]}
   * @template T
   */ function toArray(list) {
        var array = [];
        var node = list.head.next;
        while(node !== list.tail){
            array.push(node.value);
            node = node.next;
        }
        return array;
    }
    if (!_self.document) {
        if (!_self.addEventListener) {
            // in Node.js
            return _;
        }
        if (!_.disableWorkerMessageHandler) {
            // In worker
            _self.addEventListener("message", function(evt) {
                var message = JSON.parse(evt.data);
                var lang = message.language;
                var code = message.code;
                var immediateClose = message.immediateClose;
                _self.postMessage(_.highlight(code, _.languages[lang], lang));
                if (immediateClose) {
                    _self.close();
                }
            }, false);
        }
        return _;
    }
    // Get current script and highlight
    var script = _.util.currentScript();
    if (script) {
        _.filename = script.src;
        if (script.hasAttribute("data-manual")) {
            _.manual = true;
        }
    }
    function highlightAutomaticallyCallback() {
        if (!_.manual) {
            _.highlightAll();
        }
    }
    if (!_.manual) {
        // If the document state is "loading", then we'll use DOMContentLoaded.
        // If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
        // DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
        // might take longer one animation frame to execute which can create a race condition where only some plugins have
        // been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
        // See https://github.com/PrismJS/prism/issues/2102
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
            document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
            if (window.requestAnimationFrame) {
                window.requestAnimationFrame(highlightAutomaticallyCallback);
            } else {
                window.setTimeout(highlightAutomaticallyCallback, 16);
            }
        }
    }
    return _;
}(_self);
// some additional documentation/types
/**
 * The expansion of a simple `RegExp` literal to support additional properties.
 *
 * @typedef GrammarToken
 * @property {RegExp} pattern The regular expression of the token.
 * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
 * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
 * @property {boolean} [greedy=false] Whether the token is greedy.
 * @property {string|string[]} [alias] An optional alias or list of aliases.
 * @property {Grammar} [inside] The nested grammar of this token.
 *
 * The `inside` grammar will be used to tokenize the text value of each token of this kind.
 *
 * This can be used to make nested and even recursive language definitions.
 *
 * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
 * each another.
 * @global
 * @public
 */ /**
 * @typedef Grammar
 * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
 * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
 * @global
 * @public
 */ /**
 * A function which will invoked after an element was successfully highlighted.
 *
 * @callback HighlightCallback
 * @param {Element} element The element successfully highlighted.
 * @returns {void}
 * @global
 * @public
 */ /**
 * @callback HookCallback
 * @param {Object<string, any>} env The environment variables of the hook.
 * @returns {void}
 * @global
 * @public
 */ /* **********************************************
     Begin prism-markup.js
********************************************** */ Prism.languages.markup = {
    "comment": {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
    },
    "prolog": {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
    },
    "doctype": {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
            "internal-subset": {
                pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
                lookbehind: true,
                greedy: true,
                inside: null // see below
            },
            "string": {
                pattern: /"[^"]*"|'[^']*'/,
                greedy: true
            },
            "punctuation": /^<!|>$|[[\]]/,
            "doctype-tag": /^DOCTYPE/i,
            "name": /[^\s<>'"]+/
        }
    },
    "cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
    },
    "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
            "tag": {
                pattern: /^<\/?[^\s>\/]+/,
                inside: {
                    "punctuation": /^<\/?/,
                    "namespace": /^[^\s>\/:]+:/
                }
            },
            "special-attr": [],
            "attr-value": {
                pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
                inside: {
                    "punctuation": [
                        {
                            pattern: /^=/,
                            alias: "attr-equals"
                        },
                        {
                            pattern: /^(\s*)["']|["']$/,
                            lookbehind: true
                        }
                    ]
                }
            },
            "punctuation": /\/?>/,
            "attr-name": {
                pattern: /[^\s>\/]+/,
                inside: {
                    "namespace": /^[^\s>\/:]+:/
                }
            }
        }
    },
    "entity": [
        {
            pattern: /&[\da-z]{1,8};/i,
            alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
    ]
};
Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add("wrap", function(env) {
    if (env.type === "entity") {
        env.attributes["title"] = env.content.replace(/&amp;/, "&");
    }
});
Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
    /**
   * Adds an inlined language to markup.
   *
   * An example of an inlined language is CSS with `<style>` tags.
   *
   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addInlined('style', 'css');
   */ value: function addInlined(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
            pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
            lookbehind: true,
            inside: Prism.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
            "included-cdata": {
                pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
                inside: includedCdataInside
            }
        };
        inside["language-" + lang] = {
            pattern: /[\s\S]+/,
            inside: Prism.languages[lang]
        };
        var def = {};
        def[tagName] = {
            pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
                return tagName;
            }), "i"),
            lookbehind: true,
            greedy: true,
            inside: inside
        };
        Prism.languages.insertBefore("markup", "cdata", def);
    }
});
Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
    /**
   * Adds an pattern to highlight languages embedded in HTML attributes.
   *
   * An example of an inlined language is CSS with `style` attributes.
   *
   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addAttribute('style', 'css');
   */ value: function(attrName, lang) {
        Prism.languages.markup.tag.inside["special-attr"].push({
            pattern: RegExp(/(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
            lookbehind: true,
            inside: {
                "attr-name": /^[^\s=]+/,
                "attr-value": {
                    pattern: /=[\s\S]+/,
                    inside: {
                        "value": {
                            pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                            lookbehind: true,
                            alias: [
                                lang,
                                "language-" + lang
                            ],
                            inside: Prism.languages[lang]
                        },
                        "punctuation": [
                            {
                                pattern: /^=/,
                                alias: "attr-equals"
                            },
                            /"|'/
                        ]
                    }
                }
            }
        });
    }
});
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.xml = Prism.languages.extend("markup", {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;
/* **********************************************
     Begin prism-css.js
********************************************** */ (function(Prism) {
    var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    Prism.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
            pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
            inside: {
                "rule": /^@[\w-]+/,
                "selector-function-argument": {
                    pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                    lookbehind: true,
                    alias: "selector"
                },
                "keyword": {
                    pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                    lookbehind: true
                }
            }
        },
        "url": {
            // https://drafts.csswg.org/css-values-3/#urls
            pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
            greedy: true,
            inside: {
                "function": /^url/i,
                "punctuation": /^\(|\)$/,
                "string": {
                    pattern: RegExp("^" + string.source + "$"),
                    alias: "url"
                }
            }
        },
        "selector": {
            pattern: RegExp("(^|[{}\\s])[^{}\\s](?:[^{};\"'\\s]|\\s+(?![\\s{])|" + string.source + ")*(?=\\s*\\{)"),
            lookbehind: true
        },
        "string": {
            pattern: string,
            greedy: true
        },
        "property": {
            pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
            lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
            pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
            lookbehind: true
        },
        "punctuation": /[(){};:,]/
    };
    Prism.languages.css["atrule"].inside.rest = Prism.languages.css;
    var markup = Prism.languages.markup;
    if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
    }
})(Prism);
/* **********************************************
     Begin prism-clike.js
********************************************** */ Prism.languages.clike = {
    "comment": [
        {
            pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
            lookbehind: true,
            greedy: true
        },
        {
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: true,
            greedy: true
        }
    ],
    "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
    },
    "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
            "punctuation": /[.\\]/
        }
    },
    "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    "boolean": /\b(?:false|true)\b/,
    "function": /\b\w+(?=\()/,
    "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    "punctuation": /[{}[\];(),.:]/
};
/* **********************************************
     Begin prism-javascript.js
********************************************** */ Prism.languages.javascript = Prism.languages.extend("clike", {
    "class-name": [
        Prism.languages.clike["class-name"],
        {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
            lookbehind: true
        }
    ],
    "keyword": [
        {
            pattern: /((?:^|\})\s*)catch\b/,
            lookbehind: true
        },
        {
            pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
            lookbehind: true
        }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    "number": {
        pattern: RegExp(/(^|[^\w$])/.source + "(?:" + // constant
        (/NaN|Infinity/.source + "|" + // binary integer
        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
        /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
        lookbehind: true
    },
    "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});
Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
Prism.languages.insertBefore("javascript", "keyword", {
    "regex": {
        pattern: RegExp(// lookbehind
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
        // with the only syntax, so we have to define 2 different regex patterns.
        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source),
        lookbehind: true,
        greedy: true,
        inside: {
            "regex-source": {
                pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
                lookbehind: true,
                alias: "language-regex",
                inside: Prism.languages.regex
            },
            "regex-delimiter": /^\/|\/$/,
            "regex-flags": /^[a-z]+$/
        }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
    },
    "parameter": [
        {
            pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
            lookbehind: true,
            inside: Prism.languages.javascript
        },
        {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
            lookbehind: true,
            inside: Prism.languages.javascript
        },
        {
            pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
            lookbehind: true,
            inside: Prism.languages.javascript
        },
        {
            pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
            lookbehind: true,
            inside: Prism.languages.javascript
        }
    ],
    "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
Prism.languages.insertBefore("javascript", "string", {
    "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
    },
    "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
            "template-punctuation": {
                pattern: /^`|`$/,
                alias: "string"
            },
            "interpolation": {
                pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
                lookbehind: true,
                inside: {
                    "interpolation-punctuation": {
                        pattern: /^\$\{|\}$/,
                        alias: "punctuation"
                    },
                    rest: Prism.languages.javascript
                }
            },
            "string": /[\s\S]+/
        }
    },
    "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
    }
});
Prism.languages.insertBefore("javascript", "operator", {
    "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
    }
});
if (Prism.languages.markup) {
    Prism.languages.markup.tag.addInlined("script", "javascript");
    // add attribute support for all DOM events.
    // https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
    Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
}
Prism.languages.js = Prism.languages.javascript;
/* **********************************************
     Begin prism-file-highlight.js
********************************************** */ (function() {
    if (typeof Prism === "undefined" || typeof document === "undefined") {
        return;
    }
    // https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
    if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    }
    var LOADING_MESSAGE = "Loading";
    var FAILURE_MESSAGE = function(status, message) {
        return " Error " + status + " while fetching file: " + message;
    };
    var FAILURE_EMPTY_MESSAGE = " Error: File does not exist or is empty";
    var EXTENSIONS = {
        "js": "javascript",
        "py": "python",
        "rb": "ruby",
        "ps1": "powershell",
        "psm1": "powershell",
        "sh": "bash",
        "bat": "batch",
        "h": "c",
        "tex": "latex"
    };
    var STATUS_ATTR = "data-src-status";
    var STATUS_LOADING = "loading";
    var STATUS_LOADED = "loaded";
    var STATUS_FAILED = "failed";
    var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"])' + ":not([" + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
    /**
   * Loads the given file.
   *
   * @param {string} src The URL or path of the source file to load.
   * @param {(result: string) => void} success
   * @param {(reason: string) => void} error
   */ function loadFile(src, success, error) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", src, true);
        xhr.onreadystatechange = function() {
            if (xhr.readyState == 4) {
                if (xhr.status < 400 && xhr.responseText) {
                    success(xhr.responseText);
                } else {
                    if (xhr.status >= 400) {
                        error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
                    } else {
                        error(FAILURE_EMPTY_MESSAGE);
                    }
                }
            }
        };
        xhr.send(null);
    }
    /**
   * Parses the given range.
   *
   * This returns a range with inclusive ends.
   *
   * @param {string | null | undefined} range
   * @returns {[number, number | undefined] | undefined}
   */ function parseRange(range) {
        var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
        if (m) {
            var start = Number(m[1]);
            var comma = m[2];
            var end = m[3];
            if (!comma) {
                return [
                    start,
                    start
                ];
            }
            if (!end) {
                return [
                    start,
                    undefined
                ];
            }
            return [
                start,
                Number(end)
            ];
        }
        return undefined;
    }
    Prism.hooks.add("before-highlightall", function(env) {
        env.selector += ", " + SELECTOR;
    });
    Prism.hooks.add("before-sanity-check", function(env) {
        var pre = /** @type {HTMLPreElement} */ env.element;
        if (pre.matches(SELECTOR)) {
            env.code = ""; // fast-path the whole thing and go to complete
            pre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading
            // add code element with loading message
            var code = pre.appendChild(document.createElement("CODE"));
            code.textContent = LOADING_MESSAGE;
            var src = pre.getAttribute("data-src");
            var language = env.language;
            if (language === "none") {
                // the language might be 'none' because there is no language set;
                // in this case, we want to use the extension as the language
                var extension = (/\.(\w+)$/.exec(src) || [
                    ,
                    "none"
                ])[1];
                language = EXTENSIONS[extension] || extension;
            }
            // set language classes
            Prism.util.setLanguage(code, language);
            Prism.util.setLanguage(pre, language);
            // preload the language
            var autoloader = Prism.plugins.autoloader;
            if (autoloader) {
                autoloader.loadLanguages(language);
            }
            // load file
            loadFile(src, function(text) {
                // mark as loaded
                pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
                // handle data-range
                var range = parseRange(pre.getAttribute("data-range"));
                if (range) {
                    var lines = text.split(/\r\n?|\n/g);
                    // the range is one-based and inclusive on both ends
                    var start = range[0];
                    var end = range[1] == null ? lines.length : range[1];
                    if (start < 0) {
                        start += lines.length;
                    }
                    start = Math.max(0, Math.min(start - 1, lines.length));
                    if (end < 0) {
                        end += lines.length;
                    }
                    end = Math.max(0, Math.min(end, lines.length));
                    text = lines.slice(start, end).join("\n");
                    // add data-start for line numbers
                    if (!pre.hasAttribute("data-start")) {
                        pre.setAttribute("data-start", String(start + 1));
                    }
                }
                // highlight code
                code.textContent = text;
                Prism.highlightElement(code);
            }, function(error) {
                // mark as failed
                pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
                code.textContent = error;
            });
        }
    });
    Prism.plugins.fileHighlight = {
        /**
     * Executes the File Highlight plugin for all matching `pre` elements under the given container.
     *
     * Note: Elements which are already loaded or currently loading will not be touched by this method.
     *
     * @param {ParentNode} [container=document]
     */ highlight: function highlight(container) {
            var elements = (container || document).querySelectorAll(SELECTOR);
            for(var i = 0, element; element = elements[i++];){
                Prism.highlightElement(element);
            }
        }
    };
    var logged = false;
    /** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */ Prism.fileHighlight = function() {
        if (!logged) {
            console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
            logged = true;
        }
        Prism.plugins.fileHighlight.highlight.apply(this, arguments);
    };
})();
Prism.languages.clike = {
    "comment": [
        {
            pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
            lookbehind: true,
            greedy: true
        },
        {
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: true,
            greedy: true
        }
    ],
    "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
    },
    "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
            "punctuation": /[.\\]/
        }
    },
    "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    "boolean": /\b(?:false|true)\b/,
    "function": /\b\w+(?=\()/,
    "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    "punctuation": /[{}[\];(),.:]/
};
Prism.languages.c = Prism.languages.extend("clike", {
    "comment": {
        pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
        greedy: true
    },
    "string": {
        // https://en.cppreference.com/w/c/language/string_literal
        pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
        greedy: true
    },
    "class-name": {
        pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
        lookbehind: true
    },
    "keyword": /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
    "function": /\b[a-z_]\w*(?=\s*\()/i,
    "number": /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
    "operator": />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
});
Prism.languages.insertBefore("c", "string", {
    "char": {
        // https://en.cppreference.com/w/c/language/character_constant
        pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
        greedy: true
    }
});
Prism.languages.insertBefore("c", "string", {
    "macro": {
        // allow for multiline macro definitions
        // spaces after the # character compile fine with gcc
        pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
        lookbehind: true,
        greedy: true,
        alias: "property",
        inside: {
            "string": [
                {
                    // highlight the path of the include statement as a string
                    pattern: /^(#\s*include\s*)<[^>]+>/,
                    lookbehind: true
                },
                Prism.languages.c["string"]
            ],
            "char": Prism.languages.c["char"],
            "comment": Prism.languages.c["comment"],
            "macro-name": [
                {
                    pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
                    lookbehind: true
                },
                {
                    pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
                    lookbehind: true,
                    alias: "function"
                }
            ],
            // highlight macro directives as keywords
            "directive": {
                pattern: /^(#\s*)[a-z]+/,
                lookbehind: true,
                alias: "keyword"
            },
            "directive-hash": /^#/,
            "punctuation": /##|\\(?=[\r\n])/,
            "expression": {
                pattern: /\S[\s\S]*/,
                inside: Prism.languages.c
            }
        }
    }
});
Prism.languages.insertBefore("c", "function", {
    // highlight predefined macros as constants
    "constant": /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
});
delete Prism.languages.c["boolean"];
(function(Prism) {
    var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
    var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
        return keyword.source;
    });
    Prism.languages.cpp = Prism.languages.extend("c", {
        "class-name": [
            {
                pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
                    return keyword.source;
                })),
                lookbehind: true
            },
            // This is intended to capture the class name of method implementations like:
            //   void foo::bar() const {}
            // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
            // it starts with an uppercase letter. This approximation should give decent results.
            /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
            // This will capture the class name before destructors like:
            //   Foo::~Foo() {}
            /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
            // This also intends to capture the class name of method implementations but here the class has template
            // parameters, so it can't be a namespace (until C++ adds generic namespaces).
            /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
        ],
        "keyword": keyword,
        "number": {
            pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
            greedy: true
        },
        "operator": />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
        "boolean": /\b(?:false|true)\b/
    });
    Prism.languages.insertBefore("cpp", "string", {
        "module": {
            // https://en.cppreference.com/w/cpp/language/modules
            pattern: RegExp(/(\b(?:import|module)\s+)/.source + "(?:" + // header-name
            /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
            /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
                return modName;
            }) + ")"),
            lookbehind: true,
            greedy: true,
            inside: {
                "string": /^[<"][\s\S]+/,
                "operator": /:/,
                "punctuation": /\./
            }
        },
        "raw-string": {
            pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
            alias: "string",
            greedy: true
        }
    });
    Prism.languages.insertBefore("cpp", "keyword", {
        "generic-function": {
            pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
            inside: {
                "function": /^\w+/,
                "generic": {
                    pattern: /<[\s\S]+/,
                    alias: "class-name",
                    inside: Prism.languages.cpp
                }
            }
        }
    });
    Prism.languages.insertBefore("cpp", "operator", {
        "double-colon": {
            pattern: /::/,
            alias: "punctuation"
        }
    });
    Prism.languages.insertBefore("cpp", "class-name", {
        // the base clause is an optional list of parent classes
        // https://en.cppreference.com/w/cpp/language/class
        "base-clause": {
            pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
            lookbehind: true,
            greedy: true,
            inside: Prism.languages.extend("cpp", {})
        }
    });
    Prism.languages.insertBefore("inside", "double-colon", {
        // All untokenized words that are not namespaces should be class names
        "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
    }, Prism.languages.cpp["base-clause"]);
})(Prism);
Prism.languages.arduino = Prism.languages.extend("cpp", {
    "keyword": /\b(?:String|array|bool|boolean|break|byte|case|catch|continue|default|do|double|else|finally|for|function|goto|if|in|instanceof|int|integer|long|loop|new|null|return|setup|string|switch|throw|try|void|while|word)\b/,
    "constant": /\b(?:ANALOG_MESSAGE|DEFAULT|DIGITAL_MESSAGE|EXTERNAL|FIRMATA_STRING|HIGH|INPUT|INPUT_PULLUP|INTERNAL|INTERNAL1V1|INTERNAL2V56|LED_BUILTIN|LOW|OUTPUT|REPORT_ANALOG|REPORT_DIGITAL|SET_PIN_MODE|SYSEX_START|SYSTEM_RESET)\b/,
    "builtin": /\b(?:Audio|BSSID|Bridge|Client|Console|EEPROM|Esplora|EsploraTFT|Ethernet|EthernetClient|EthernetServer|EthernetUDP|File|FileIO|FileSystem|Firmata|GPRS|GSM|GSMBand|GSMClient|GSMModem|GSMPIN|GSMScanner|GSMServer|GSMVoiceCall|GSM_SMS|HttpClient|IPAddress|IRread|Keyboard|KeyboardController|LiquidCrystal|LiquidCrystal_I2C|Mailbox|Mouse|MouseController|PImage|Process|RSSI|RobotControl|RobotMotor|SD|SPI|SSID|Scheduler|Serial|Server|Servo|SoftwareSerial|Stepper|Stream|TFT|Task|USBHost|WiFi|WiFiClient|WiFiServer|WiFiUDP|Wire|YunClient|YunServer|abs|addParameter|analogRead|analogReadResolution|analogReference|analogWrite|analogWriteResolution|answerCall|attach|attachGPRS|attachInterrupt|attached|autoscroll|available|background|beep|begin|beginPacket|beginSD|beginSMS|beginSpeaker|beginTFT|beginTransmission|beginWrite|bit|bitClear|bitRead|bitSet|bitWrite|blink|blinkVersion|buffer|changePIN|checkPIN|checkPUK|checkReg|circle|cityNameRead|cityNameWrite|clear|clearScreen|click|close|compassRead|config|connect|connected|constrain|cos|countryNameRead|countryNameWrite|createChar|cursor|debugPrint|delay|delayMicroseconds|detach|detachInterrupt|digitalRead|digitalWrite|disconnect|display|displayLogos|drawBMP|drawCompass|encryptionType|end|endPacket|endSMS|endTransmission|endWrite|exists|exitValue|fill|find|findUntil|flush|gatewayIP|get|getAsynchronously|getBand|getButton|getCurrentCarrier|getIMEI|getKey|getModifiers|getOemKey|getPINUsed|getResult|getSignalStrength|getSocket|getVoiceCallStatus|getXChange|getYChange|hangCall|height|highByte|home|image|interrupts|isActionDone|isDirectory|isListening|isPIN|isPressed|isValid|keyPressed|keyReleased|keyboardRead|knobRead|leftToRight|line|lineFollowConfig|listen|listenOnLocalhost|loadImage|localIP|lowByte|macAddress|maintain|map|max|messageAvailable|micros|millis|min|mkdir|motorsStop|motorsWrite|mouseDragged|mouseMoved|mousePressed|mouseReleased|move|noAutoscroll|noBlink|noBuffer|noCursor|noDisplay|noFill|noInterrupts|noListenOnLocalhost|noStroke|noTone|onReceive|onRequest|open|openNextFile|overflow|parseCommand|parseFloat|parseInt|parsePacket|pauseMode|peek|pinMode|playFile|playMelody|point|pointTo|position|pow|prepare|press|print|printFirmwareVersion|printVersion|println|process|processInput|pulseIn|put|random|randomSeed|read|readAccelerometer|readBlue|readButton|readBytes|readBytesUntil|readGreen|readJoystickButton|readJoystickSwitch|readJoystickX|readJoystickY|readLightSensor|readMessage|readMicrophone|readNetworks|readRed|readSlider|readString|readStringUntil|readTemperature|ready|rect|release|releaseAll|remoteIP|remoteNumber|remotePort|remove|requestFrom|retrieveCallingNumber|rewindDirectory|rightToLeft|rmdir|robotNameRead|robotNameWrite|run|runAsynchronously|runShellCommand|runShellCommandAsynchronously|running|scanNetworks|scrollDisplayLeft|scrollDisplayRight|seek|sendAnalog|sendDigitalPortPair|sendDigitalPorts|sendString|sendSysex|serialEvent|setBand|setBitOrder|setClockDivider|setCursor|setDNS|setDataMode|setFirmwareVersion|setMode|setPINUsed|setSpeed|setTextSize|setTimeout|shiftIn|shiftOut|shutdown|sin|size|sqrt|startLoop|step|stop|stroke|subnetMask|switchPIN|tan|tempoWrite|text|tone|transfer|tuneWrite|turn|updateIR|userNameRead|userNameWrite|voiceCall|waitContinue|width|write|writeBlue|writeGreen|writeJSON|writeMessage|writeMicroseconds|writeRGB|writeRed|yield)\b/
});
Prism.languages.ino = Prism.languages.arduino;
(function(Prism) {
    // $ set | grep '^[A-Z][^[:space:]]*=' | cut -d= -f1 | tr '\n' '|'
    // + LC_ALL, RANDOM, REPLY, SECONDS.
    // + make sure PS1..4 are here as they are not always set,
    // - some useless things.
    var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
    var commandAfterHeredoc = {
        pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
        lookbehind: true,
        alias: "punctuation",
        // this looks reasonably well in all themes
        inside: null // see below
    };
    var insideString = {
        "bash": commandAfterHeredoc,
        "environment": {
            pattern: RegExp("\\$" + envVars),
            alias: "constant"
        },
        "variable": [
            // [0]: Arithmetic Environment
            {
                pattern: /\$?\(\([\s\S]+?\)\)/,
                greedy: true,
                inside: {
                    // If there is a $ sign at the beginning highlight $(( and )) as variable
                    "variable": [
                        {
                            pattern: /(^\$\(\([\s\S]+)\)\)/,
                            lookbehind: true
                        },
                        /^\$\(\(/
                    ],
                    "number": /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
                    // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
                    "operator": /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
                    // If there is no $ sign at the beginning highlight (( and )) as punctuation
                    "punctuation": /\(\(?|\)\)?|,|;/
                }
            },
            // [1]: Command Substitution
            {
                pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
                greedy: true,
                inside: {
                    "variable": /^\$\(|^`|\)$|`$/
                }
            },
            // [2]: Brace expansion
            {
                pattern: /\$\{[^}]+\}/,
                greedy: true,
                inside: {
                    "operator": /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
                    "punctuation": /[\[\]]/,
                    "environment": {
                        pattern: RegExp("(\\{)" + envVars),
                        lookbehind: true,
                        alias: "constant"
                    }
                }
            },
            /\$(?:\w+|[#?*!@$])/
        ],
        // Escape sequences from echo and printf's manuals, and escaped quotes.
        "entity": /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
    };
    Prism.languages.bash = {
        "shebang": {
            pattern: /^#!\s*\/.*/,
            alias: "important"
        },
        "comment": {
            pattern: /(^|[^"{\\$])#.*/,
            lookbehind: true
        },
        "function-name": [
            // a) function foo {
            // b) foo() {
            // c) function foo() {
            // but not foo {
            {
                // a) and c)
                pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
                lookbehind: true,
                alias: "function"
            },
            {
                // b)
                pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
                alias: "function"
            }
        ],
        // Highlight variable names as variables in for and select beginnings.
        "for-or-select": {
            pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
            alias: "variable",
            lookbehind: true
        },
        // Highlight variable names as variables in the left-hand part
        // of assignments (= and +=).
        "assign-left": {
            pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
            inside: {
                "environment": {
                    pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
                    lookbehind: true,
                    alias: "constant"
                }
            },
            alias: "variable",
            lookbehind: true
        },
        // Highlight parameter names as variables
        "parameter": {
            pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
            alias: "variable",
            lookbehind: true
        },
        "string": [
            // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
            {
                pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
                lookbehind: true,
                greedy: true,
                inside: insideString
            },
            // Here-document with quotes around the tag
            //  No expansion (so no inside).
            {
                pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
                lookbehind: true,
                greedy: true,
                inside: {
                    "bash": commandAfterHeredoc
                }
            },
            // Normal string
            {
                // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
                pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
                lookbehind: true,
                greedy: true,
                inside: insideString
            },
            {
                // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
                pattern: /(^|[^$\\])'[^']*'/,
                lookbehind: true,
                greedy: true
            },
            {
                // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
                pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
                greedy: true,
                inside: {
                    "entity": insideString.entity
                }
            }
        ],
        "environment": {
            pattern: RegExp("\\$?" + envVars),
            alias: "constant"
        },
        "variable": insideString.variable,
        "function": {
            pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
            lookbehind: true
        },
        "keyword": {
            pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
            lookbehind: true
        },
        // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
        "builtin": {
            pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
            lookbehind: true,
            // Alias added to make those easier to distinguish from strings.
            alias: "class-name"
        },
        "boolean": {
            pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
            lookbehind: true
        },
        "file-descriptor": {
            pattern: /\B&\d\b/,
            alias: "important"
        },
        "operator": {
            // Lots of redirections here, but not just that.
            pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
            inside: {
                "file-descriptor": {
                    pattern: /^\d/,
                    alias: "important"
                }
            }
        },
        "punctuation": /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
        "number": {
            pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
            lookbehind: true
        }
    };
    commandAfterHeredoc.inside = Prism.languages.bash;
    /* Patterns in command substitution. */ var toBeCopied = [
        "comment",
        "function-name",
        "for-or-select",
        "assign-left",
        "parameter",
        "string",
        "environment",
        "function",
        "keyword",
        "builtin",
        "boolean",
        "file-descriptor",
        "operator",
        "punctuation",
        "number"
    ];
    var inside = insideString.variable[1].inside;
    for(var i = 0; i < toBeCopied.length; i++){
        inside[toBeCopied[i]] = Prism.languages.bash[toBeCopied[i]];
    }
    Prism.languages.sh = Prism.languages.bash;
    Prism.languages.shell = Prism.languages.bash;
})(Prism);
(function(Prism) {
    /**
   * Replaces all placeholders "<<n>>" of given pattern with the n-th replacement (zero based).
   *
   * Note: This is a simple text based replacement. Be careful when using backreferences!
   *
   * @param {string} pattern the given pattern.
   * @param {string[]} replacements a list of replacement which can be inserted into the given pattern.
   * @returns {string} the pattern with all placeholders replaced with their corresponding replacements.
   * @example replace(/a<<0>>a/.source, [/b+/.source]) === /a(?:b+)a/.source
   */ function replace(pattern, replacements) {
        return pattern.replace(/<<(\d+)>>/g, function(m, index) {
            return "(?:" + replacements[+index] + ")";
        });
    }
    /**
   * @param {string} pattern
   * @param {string[]} replacements
   * @param {string} [flags]
   * @returns {RegExp}
   */ function re(pattern, replacements, flags) {
        return RegExp(replace(pattern, replacements), flags || "");
    }
    /**
   * Creates a nested pattern where all occurrences of the string `<<self>>` are replaced with the pattern itself.
   *
   * @param {string} pattern
   * @param {number} depthLog2
   * @returns {string}
   */ function nested(pattern, depthLog2) {
        for(var i = 0; i < depthLog2; i++){
            pattern = pattern.replace(/<<self>>/g, function() {
                return "(?:" + pattern + ")";
            });
        }
        return pattern.replace(/<<self>>/g, "[^\\s\\S]");
    }
    // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/
    var keywordKinds = {
        // keywords which represent a return or variable type
        type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
        // keywords which are used to declare a type
        typeDeclaration: "class enum interface record struct",
        // contextual keywords
        // ("var" and "dynamic" are missing because they are used like types)
        contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
        // all other keywords
        other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
    };
    // keywords
    function keywordsToPattern(words) {
        return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
    }
    var typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);
    var keywords = RegExp(keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other));
    var nonTypeKeywords = keywordsToPattern(keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other);
    var nonContextualKeywords = keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.other);
    // types
    var generic = nested(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2); // the idea behind the other forbidden characters is to prevent false positives. Same for tupleElement.
    var nestedRound = nested(/\((?:[^()]|<<self>>)*\)/.source, 2);
    var name = /@?\b[A-Za-z_]\w*\b/.source;
    var genericName = replace(/<<0>>(?:\s*<<1>>)?/.source, [
        name,
        generic
    ]);
    var identifier = replace(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [
        nonTypeKeywords,
        genericName
    ]);
    var array = /\[\s*(?:,\s*)*\]/.source;
    var typeExpressionWithoutTuple = replace(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [
        identifier,
        array
    ]);
    var tupleElement = replace(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [
        generic,
        nestedRound,
        array
    ]);
    var tuple = replace(/\(<<0>>+(?:,<<0>>+)+\)/.source, [
        tupleElement
    ]);
    var typeExpression = replace(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [
        tuple,
        identifier,
        array
    ]);
    var typeInside = {
        "keyword": keywords,
        "punctuation": /[<>()?,.:[\]]/
    };
    // strings & characters
    // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#character-literals
    // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#string-literals
    var character = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source; // simplified pattern
    var regularString = /"(?:\\.|[^\\"\r\n])*"/.source;
    var verbatimString = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
    Prism.languages.csharp = Prism.languages.extend("clike", {
        "string": [
            {
                pattern: re(/(^|[^$\\])<<0>>/.source, [
                    verbatimString
                ]),
                lookbehind: true,
                greedy: true
            },
            {
                pattern: re(/(^|[^@$\\])<<0>>/.source, [
                    regularString
                ]),
                lookbehind: true,
                greedy: true
            }
        ],
        "class-name": [
            {
                // Using static
                // using static System.Math;
                pattern: re(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [
                    identifier
                ]),
                lookbehind: true,
                inside: typeInside
            },
            {
                // Using alias (type)
                // using Project = PC.MyCompany.Project;
                pattern: re(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [
                    name,
                    typeExpression
                ]),
                lookbehind: true,
                inside: typeInside
            },
            {
                // Using alias (alias)
                // using Project = PC.MyCompany.Project;
                pattern: re(/(\busing\s+)<<0>>(?=\s*=)/.source, [
                    name
                ]),
                lookbehind: true
            },
            {
                // Type declarations
                // class Foo<A, B>
                // interface Foo<out A, B>
                pattern: re(/(\b<<0>>\s+)<<1>>/.source, [
                    typeDeclarationKeywords,
                    genericName
                ]),
                lookbehind: true,
                inside: typeInside
            },
            {
                // Single catch exception declaration
                // catch(Foo)
                // (things like catch(Foo e) is covered by variable declaration)
                pattern: re(/(\bcatch\s*\(\s*)<<0>>/.source, [
                    identifier
                ]),
                lookbehind: true,
                inside: typeInside
            },
            {
                // Name of the type parameter of generic constraints
                // where Foo : class
                pattern: re(/(\bwhere\s+)<<0>>/.source, [
                    name
                ]),
                lookbehind: true
            },
            {
                // Casts and checks via as and is.
                // as Foo<A>, is Bar<B>
                // (things like if(a is Foo b) is covered by variable declaration)
                pattern: re(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [
                    typeExpressionWithoutTuple
                ]),
                lookbehind: true,
                inside: typeInside
            },
            {
                // Variable, field and parameter declaration
                // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)
                pattern: re(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [
                    typeExpression,
                    nonContextualKeywords,
                    name
                ]),
                inside: typeInside
            }
        ],
        "keyword": keywords,
        // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals
        "number": /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
        "operator": />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
        "punctuation": /\?\.?|::|[{}[\];(),.:]/
    });
    Prism.languages.insertBefore("csharp", "number", {
        "range": {
            pattern: /\.\./,
            alias: "operator"
        }
    });
    Prism.languages.insertBefore("csharp", "punctuation", {
        "named-parameter": {
            pattern: re(/([(,]\s*)<<0>>(?=\s*:)/.source, [
                name
            ]),
            lookbehind: true,
            alias: "punctuation"
        }
    });
    Prism.languages.insertBefore("csharp", "class-name", {
        "namespace": {
            // namespace Foo.Bar {}
            // using Foo.Bar;
            pattern: re(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [
                name
            ]),
            lookbehind: true,
            inside: {
                "punctuation": /\./
            }
        },
        "type-expression": {
            // default(Foo), typeof(Foo<Bar>), sizeof(int)
            pattern: re(/(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [
                nestedRound
            ]),
            lookbehind: true,
            alias: "class-name",
            inside: typeInside
        },
        "return-type": {
            // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0
            // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];
            // int Foo => 0; int Foo { get; set } = 0;
            pattern: re(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [
                typeExpression,
                identifier
            ]),
            inside: typeInside,
            alias: "class-name"
        },
        "constructor-invocation": {
            // new List<Foo<Bar[]>> { }
            pattern: re(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [
                typeExpression
            ]),
            lookbehind: true,
            inside: typeInside,
            alias: "class-name"
        },
        /*'explicit-implementation': {
    	// int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();
    	pattern: replace(/\b<<0>>(?=\.<<1>>)/, className, methodOrPropertyDeclaration),
    	inside: classNameInside,
    	alias: 'class-name'
    },*/ "generic-method": {
            // foo<Bar>()
            pattern: re(/<<0>>\s*<<1>>(?=\s*\()/.source, [
                name,
                generic
            ]),
            inside: {
                "function": re(/^<<0>>/.source, [
                    name
                ]),
                "generic": {
                    pattern: RegExp(generic),
                    alias: "class-name",
                    inside: typeInside
                }
            }
        },
        "type-list": {
            // The list of types inherited or of generic constraints
            // class Foo<F> : Bar, IList<FooBar>
            // where F : Bar, IList<int>
            pattern: re(/\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source, [
                typeDeclarationKeywords,
                genericName,
                name,
                typeExpression,
                keywords.source,
                nestedRound,
                /\bnew\s*\(\s*\)/.source
            ]),
            lookbehind: true,
            inside: {
                "record-arguments": {
                    pattern: re(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [
                        genericName,
                        nestedRound
                    ]),
                    lookbehind: true,
                    greedy: true,
                    inside: Prism.languages.csharp
                },
                "keyword": keywords,
                "class-name": {
                    pattern: RegExp(typeExpression),
                    greedy: true,
                    inside: typeInside
                },
                "punctuation": /[,()]/
            }
        },
        "preprocessor": {
            pattern: /(^[\t ]*)#.*/m,
            lookbehind: true,
            alias: "property",
            inside: {
                // highlight preprocessor directives as keywords
                "directive": {
                    pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
                    lookbehind: true,
                    alias: "keyword"
                }
            }
        }
    });
    // attributes
    var regularStringOrCharacter = regularString + "|" + character;
    var regularStringCharacterOrComment = replace(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [
        regularStringOrCharacter
    ]);
    var roundExpression = nested(replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [
        regularStringCharacterOrComment
    ]), 2);
    // https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/#attribute-targets
    var attrTarget = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source;
    var attr = replace(/<<0>>(?:\s*\(<<1>>*\))?/.source, [
        identifier,
        roundExpression
    ]);
    Prism.languages.insertBefore("csharp", "class-name", {
        "attribute": {
            // Attributes
            // [Foo], [Foo(1), Bar(2, Prop = "foo")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]
            pattern: re(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [
                attrTarget,
                attr
            ]),
            lookbehind: true,
            greedy: true,
            inside: {
                "target": {
                    pattern: re(/^<<0>>(?=\s*:)/.source, [
                        attrTarget
                    ]),
                    alias: "keyword"
                },
                "attribute-arguments": {
                    pattern: re(/\(<<0>>*\)/.source, [
                        roundExpression
                    ]),
                    inside: Prism.languages.csharp
                },
                "class-name": {
                    pattern: RegExp(identifier),
                    inside: {
                        "punctuation": /\./
                    }
                },
                "punctuation": /[:,]/
            }
        }
    });
    // string interpolation
    var formatString = /:[^}\r\n]+/.source;
    // multi line
    var mInterpolationRound = nested(replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [
        regularStringCharacterOrComment
    ]), 2);
    var mInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [
        mInterpolationRound,
        formatString
    ]);
    // single line
    var sInterpolationRound = nested(replace(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [
        regularStringOrCharacter
    ]), 2);
    var sInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [
        sInterpolationRound,
        formatString
    ]);
    function createInterpolationInside(interpolation, interpolationRound) {
        return {
            "interpolation": {
                pattern: re(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [
                    interpolation
                ]),
                lookbehind: true,
                inside: {
                    "format-string": {
                        pattern: re(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [
                            interpolationRound,
                            formatString
                        ]),
                        lookbehind: true,
                        inside: {
                            "punctuation": /^:/
                        }
                    },
                    "punctuation": /^\{|\}$/,
                    "expression": {
                        pattern: /[\s\S]+/,
                        alias: "language-csharp",
                        inside: Prism.languages.csharp
                    }
                }
            },
            "string": /[\s\S]+/
        };
    }
    Prism.languages.insertBefore("csharp", "string", {
        "interpolation-string": [
            {
                pattern: re(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [
                    mInterpolation
                ]),
                lookbehind: true,
                greedy: true,
                inside: createInterpolationInside(mInterpolation, mInterpolationRound)
            },
            {
                pattern: re(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [
                    sInterpolation
                ]),
                lookbehind: true,
                greedy: true,
                inside: createInterpolationInside(sInterpolation, sInterpolationRound)
            }
        ],
        "char": {
            pattern: RegExp(character),
            greedy: true
        }
    });
    Prism.languages.dotnet = Prism.languages.cs = Prism.languages.csharp;
})(Prism);
Prism.languages.markup = {
    "comment": {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
    },
    "prolog": {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
    },
    "doctype": {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
            "internal-subset": {
                pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
                lookbehind: true,
                greedy: true,
                inside: null // see below
            },
            "string": {
                pattern: /"[^"]*"|'[^']*'/,
                greedy: true
            },
            "punctuation": /^<!|>$|[[\]]/,
            "doctype-tag": /^DOCTYPE/i,
            "name": /[^\s<>'"]+/
        }
    },
    "cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
    },
    "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
            "tag": {
                pattern: /^<\/?[^\s>\/]+/,
                inside: {
                    "punctuation": /^<\/?/,
                    "namespace": /^[^\s>\/:]+:/
                }
            },
            "special-attr": [],
            "attr-value": {
                pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
                inside: {
                    "punctuation": [
                        {
                            pattern: /^=/,
                            alias: "attr-equals"
                        },
                        {
                            pattern: /^(\s*)["']|["']$/,
                            lookbehind: true
                        }
                    ]
                }
            },
            "punctuation": /\/?>/,
            "attr-name": {
                pattern: /[^\s>\/]+/,
                inside: {
                    "namespace": /^[^\s>\/:]+:/
                }
            }
        }
    },
    "entity": [
        {
            pattern: /&[\da-z]{1,8};/i,
            alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
    ]
};
Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism.languages.markup["entity"];
Prism.languages.markup["doctype"].inside["internal-subset"].inside = Prism.languages.markup;
// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add("wrap", function(env) {
    if (env.type === "entity") {
        env.attributes["title"] = env.content.replace(/&amp;/, "&");
    }
});
Object.defineProperty(Prism.languages.markup.tag, "addInlined", {
    /**
   * Adds an inlined language to markup.
   *
   * An example of an inlined language is CSS with `<style>` tags.
   *
   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addInlined('style', 'css');
   */ value: function addInlined(tagName, lang) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang] = {
            pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
            lookbehind: true,
            inside: Prism.languages[lang]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
            "included-cdata": {
                pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
                inside: includedCdataInside
            }
        };
        inside["language-" + lang] = {
            pattern: /[\s\S]+/,
            inside: Prism.languages[lang]
        };
        var def = {};
        def[tagName] = {
            pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
                return tagName;
            }), "i"),
            lookbehind: true,
            greedy: true,
            inside: inside
        };
        Prism.languages.insertBefore("markup", "cdata", def);
    }
});
Object.defineProperty(Prism.languages.markup.tag, "addAttribute", {
    /**
   * Adds an pattern to highlight languages embedded in HTML attributes.
   *
   * An example of an inlined language is CSS with `style` attributes.
   *
   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
   * case insensitive.
   * @param {string} lang The language key.
   * @example
   * addAttribute('style', 'css');
   */ value: function(attrName, lang) {
        Prism.languages.markup.tag.inside["special-attr"].push({
            pattern: RegExp(/(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
            lookbehind: true,
            inside: {
                "attr-name": /^[^\s=]+/,
                "attr-value": {
                    pattern: /=[\s\S]+/,
                    inside: {
                        "value": {
                            pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                            lookbehind: true,
                            alias: [
                                lang,
                                "language-" + lang
                            ],
                            inside: Prism.languages[lang]
                        },
                        "punctuation": [
                            {
                                pattern: /^=/,
                                alias: "attr-equals"
                            },
                            /"|'/
                        ]
                    }
                }
            }
        });
    }
});
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;
Prism.languages.xml = Prism.languages.extend("markup", {});
Prism.languages.ssml = Prism.languages.xml;
Prism.languages.atom = Prism.languages.xml;
Prism.languages.rss = Prism.languages.xml;
(function(Prism) {
    var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    Prism.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
            pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
            inside: {
                "rule": /^@[\w-]+/,
                "selector-function-argument": {
                    pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                    lookbehind: true,
                    alias: "selector"
                },
                "keyword": {
                    pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                    lookbehind: true
                }
            }
        },
        "url": {
            // https://drafts.csswg.org/css-values-3/#urls
            pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
            greedy: true,
            inside: {
                "function": /^url/i,
                "punctuation": /^\(|\)$/,
                "string": {
                    pattern: RegExp("^" + string.source + "$"),
                    alias: "url"
                }
            }
        },
        "selector": {
            pattern: RegExp("(^|[{}\\s])[^{}\\s](?:[^{};\"'\\s]|\\s+(?![\\s{])|" + string.source + ")*(?=\\s*\\{)"),
            lookbehind: true
        },
        "string": {
            pattern: string,
            greedy: true
        },
        "property": {
            pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
            lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
            pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
            lookbehind: true
        },
        "punctuation": /[(){};:,]/
    };
    Prism.languages.css["atrule"].inside.rest = Prism.languages.css;
    var markup = Prism.languages.markup;
    if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
    }
})(Prism);
(function(Prism) {
    Prism.languages.diff = {
        "coord": [
            // Match all kinds of coord lines (prefixed by "+++", "---" or "***").
            /^(?:\*{3}|-{3}|\+{3}).*$/m,
            // Match "@@ ... @@" coord lines in unified diff.
            /^@@.*@@$/m,
            // Match coord lines in normal diff (starts with a number).
            /^\d.*$/m
        ]
    };
    /**
   * A map from the name of a block to its line prefix.
   *
   * @type {Object<string, string>}
   */ var PREFIXES = {
        "deleted-sign": "-",
        "deleted-arrow": "<",
        "inserted-sign": "+",
        "inserted-arrow": ">",
        "unchanged": " ",
        "diff": "!"
    };
    // add a token for each prefix
    Object.keys(PREFIXES).forEach(function(name) {
        var prefix = PREFIXES[name];
        var alias = [];
        if (!/^\w+$/.test(name)) {
            // "deleted-sign" -> "deleted"
            alias.push(/\w+/.exec(name)[0]);
        }
        if (name === "diff") {
            alias.push("bold");
        }
        Prism.languages.diff[name] = {
            pattern: RegExp("^(?:[" + prefix + "].*(?:\r\n?|\n|(?![\\s\\S])))+", "m"),
            alias: alias,
            inside: {
                "line": {
                    pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
                    lookbehind: true
                },
                "prefix": {
                    pattern: /[\s\S]/,
                    alias: /\w+/.exec(name)[0]
                }
            }
        };
    });
    // make prefixes available to Diff plugin
    Object.defineProperty(Prism.languages.diff, "PREFIXES", {
        value: PREFIXES
    });
})(Prism);
Prism.languages.go = Prism.languages.extend("clike", {
    "string": {
        pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
        lookbehind: true,
        greedy: true
    },
    "keyword": /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
    "boolean": /\b(?:_|false|iota|nil|true)\b/,
    "number": [
        // binary and octal integers
        /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
        // hexadecimal integers and floats
        /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
        // decimal integers and floats
        /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
    ],
    "operator": /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
    "builtin": /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
});
Prism.languages.insertBefore("go", "string", {
    "char": {
        pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
        greedy: true
    }
});
delete Prism.languages.go["class-name"];
Prism.languages.ini = {
    /**
   * The component mimics the behavior of the Win32 API parser.
   *
   * @see {@link https://github.com/PrismJS/prism/issues/2775#issuecomment-787477723}
   */ "comment": {
        pattern: /(^[ \f\t\v]*)[#;][^\n\r]*/m,
        lookbehind: true
    },
    "section": {
        pattern: /(^[ \f\t\v]*)\[[^\n\r\]]*\]?/m,
        lookbehind: true,
        inside: {
            "section-name": {
                pattern: /(^\[[ \f\t\v]*)[^ \f\t\v\]]+(?:[ \f\t\v]+[^ \f\t\v\]]+)*/,
                lookbehind: true,
                alias: "selector"
            },
            "punctuation": /\[|\]/
        }
    },
    "key": {
        pattern: /(^[ \f\t\v]*)[^ \f\n\r\t\v=]+(?:[ \f\t\v]+[^ \f\n\r\t\v=]+)*(?=[ \f\t\v]*=)/m,
        lookbehind: true,
        alias: "attr-name"
    },
    "value": {
        pattern: /(=[ \f\t\v]*)[^ \f\n\r\t\v]+(?:[ \f\t\v]+[^ \f\n\r\t\v]+)*/,
        lookbehind: true,
        alias: "attr-value",
        inside: {
            "inner-value": {
                pattern: /^("|').+(?=\1$)/,
                lookbehind: true
            }
        }
    },
    "punctuation": /=/
};
(function(Prism) {
    var keywords = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
    // full package (optional) + parent classes (optional)
    var classNamePrefix = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
    // based on the java naming conventions
    var className = {
        pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
        lookbehind: true,
        inside: {
            "namespace": {
                pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
                inside: {
                    "punctuation": /\./
                }
            },
            "punctuation": /\./
        }
    };
    Prism.languages.java = Prism.languages.extend("clike", {
        "string": {
            pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
            lookbehind: true,
            greedy: true
        },
        "class-name": [
            className,
            {
                // variables, parameters, and constructor references
                // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
                pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
                lookbehind: true,
                inside: className.inside
            },
            {
                // class names based on keyword
                // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
                pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + classNamePrefix + /[A-Z]\w*\b/.source),
                lookbehind: true,
                inside: className.inside
            }
        ],
        "keyword": keywords,
        "function": [
            Prism.languages.clike.function,
            {
                pattern: /(::\s*)[a-z_]\w*/,
                lookbehind: true
            }
        ],
        "number": /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
        "operator": {
            pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
            lookbehind: true
        },
        "constant": /\b[A-Z][A-Z_\d]+\b/
    });
    Prism.languages.insertBefore("java", "string", {
        "triple-quoted-string": {
            // http://openjdk.java.net/jeps/355#Description
            pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
            greedy: true,
            alias: "string"
        },
        "char": {
            pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
            greedy: true
        }
    });
    Prism.languages.insertBefore("java", "class-name", {
        "annotation": {
            pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
            lookbehind: true,
            alias: "punctuation"
        },
        "generics": {
            pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
            inside: {
                "class-name": className,
                "keyword": keywords,
                "punctuation": /[<>(),.:]/,
                "operator": /[?&|]/
            }
        },
        "import": [
            {
                pattern: RegExp(/(\bimport\s+)/.source + classNamePrefix + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
                lookbehind: true,
                inside: {
                    "namespace": className.inside.namespace,
                    "punctuation": /\./,
                    "operator": /\*/,
                    "class-name": /\w+/
                }
            },
            {
                pattern: RegExp(/(\bimport\s+static\s+)/.source + classNamePrefix + /(?:\w+|\*)(?=\s*;)/.source),
                lookbehind: true,
                alias: "static",
                inside: {
                    "namespace": className.inside.namespace,
                    "static": /\b\w+$/,
                    "punctuation": /\./,
                    "operator": /\*/,
                    "class-name": /\w+/
                }
            }
        ],
        "namespace": {
            pattern: RegExp(/(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
                return keywords.source;
            })),
            lookbehind: true,
            inside: {
                "punctuation": /\./
            }
        }
    });
})(Prism);
(function(Prism) {
    var specialEscape = {
        pattern: /\\[\\(){}[\]^$+*?|.]/,
        alias: "escape"
    };
    var escape = /\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/;
    var charSet = {
        pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i,
        alias: "class-name"
    };
    var charSetWithoutDot = {
        pattern: /\\[wsd]|\\p\{[^{}]+\}/i,
        alias: "class-name"
    };
    var rangeChar = "(?:[^\\\\-]|" + escape.source + ")";
    var range = RegExp(rangeChar + "-" + rangeChar);
    // the name of a capturing group
    var groupName = {
        pattern: /(<|')[^<>']+(?=[>']$)/,
        lookbehind: true,
        alias: "variable"
    };
    Prism.languages.regex = {
        "char-class": {
            pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/,
            lookbehind: true,
            inside: {
                "char-class-negation": {
                    pattern: /(^\[)\^/,
                    lookbehind: true,
                    alias: "operator"
                },
                "char-class-punctuation": {
                    pattern: /^\[|\]$/,
                    alias: "punctuation"
                },
                "range": {
                    pattern: range,
                    inside: {
                        "escape": escape,
                        "range-punctuation": {
                            pattern: /-/,
                            alias: "operator"
                        }
                    }
                },
                "special-escape": specialEscape,
                "char-set": charSetWithoutDot,
                "escape": escape
            }
        },
        "special-escape": specialEscape,
        "char-set": charSet,
        "backreference": [
            {
                // a backreference which is not an octal escape
                pattern: /\\(?![123][0-7]{2})[1-9]/,
                alias: "keyword"
            },
            {
                pattern: /\\k<[^<>']+>/,
                alias: "keyword",
                inside: {
                    "group-name": groupName
                }
            }
        ],
        "anchor": {
            pattern: /[$^]|\\[ABbGZz]/,
            alias: "function"
        },
        "escape": escape,
        "group": [
            {
                // https://docs.oracle.com/javase/10/docs/api/java/util/regex/Pattern.html
                // https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference?view=netframework-4.7.2#grouping-constructs
                // (), (?<name>), (?'name'), (?>), (?:), (?=), (?!), (?<=), (?<!), (?is-m), (?i-m:)
                pattern: /\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,
                alias: "punctuation",
                inside: {
                    "group-name": groupName
                }
            },
            {
                pattern: /\)/,
                alias: "punctuation"
            }
        ],
        "quantifier": {
            pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/,
            alias: "number"
        },
        "alternation": {
            pattern: /\|/,
            alias: "keyword"
        }
    };
})(Prism);
Prism.languages.javascript = Prism.languages.extend("clike", {
    "class-name": [
        Prism.languages.clike["class-name"],
        {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
            lookbehind: true
        }
    ],
    "keyword": [
        {
            pattern: /((?:^|\})\s*)catch\b/,
            lookbehind: true
        },
        {
            pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
            lookbehind: true
        }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    "number": {
        pattern: RegExp(/(^|[^\w$])/.source + "(?:" + // constant
        (/NaN|Infinity/.source + "|" + // binary integer
        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
        /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
        lookbehind: true
    },
    "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});
Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
Prism.languages.insertBefore("javascript", "keyword", {
    "regex": {
        pattern: RegExp(// lookbehind
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
        // with the only syntax, so we have to define 2 different regex patterns.
        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source),
        lookbehind: true,
        greedy: true,
        inside: {
            "regex-source": {
                pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
                lookbehind: true,
                alias: "language-regex",
                inside: Prism.languages.regex
            },
            "regex-delimiter": /^\/|\/$/,
            "regex-flags": /^[a-z]+$/
        }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
    },
    "parameter": [
        {
            pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
            lookbehind: true,
            inside: Prism.languages.javascript
        },
        {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
            lookbehind: true,
            inside: Prism.languages.javascript
        },
        {
            pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
            lookbehind: true,
            inside: Prism.languages.javascript
        },
        {
            pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
            lookbehind: true,
            inside: Prism.languages.javascript
        }
    ],
    "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
Prism.languages.insertBefore("javascript", "string", {
    "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
    },
    "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
            "template-punctuation": {
                pattern: /^`|`$/,
                alias: "string"
            },
            "interpolation": {
                pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
                lookbehind: true,
                inside: {
                    "interpolation-punctuation": {
                        pattern: /^\$\{|\}$/,
                        alias: "punctuation"
                    },
                    rest: Prism.languages.javascript
                }
            },
            "string": /[\s\S]+/
        }
    },
    "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
    }
});
Prism.languages.insertBefore("javascript", "operator", {
    "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
    }
});
if (Prism.languages.markup) {
    Prism.languages.markup.tag.addInlined("script", "javascript");
    // add attribute support for all DOM events.
    // https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events
    Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
}
Prism.languages.js = Prism.languages.javascript;
(function(Prism) {
    var javascript = Prism.util.clone(Prism.languages.javascript);
    var space = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
    var braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
    var spread = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
    /**
   * @param {string} source
   * @param {string} [flags]
   */ function re(source, flags) {
        source = source.replace(/<S>/g, function() {
            return space;
        }).replace(/<BRACES>/g, function() {
            return braces;
        }).replace(/<SPREAD>/g, function() {
            return spread;
        });
        return RegExp(source, flags);
    }
    spread = re(spread).source;
    Prism.languages.jsx = Prism.languages.extend("markup", javascript);
    Prism.languages.jsx.tag.pattern = re(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source);
    Prism.languages.jsx.tag.inside["tag"].pattern = /^<\/?[^\s>\/]*/;
    Prism.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
    Prism.languages.jsx.tag.inside["tag"].inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
    Prism.languages.jsx.tag.inside["comment"] = javascript["comment"];
    Prism.languages.insertBefore("inside", "attr-name", {
        "spread": {
            pattern: re(/<SPREAD>/.source),
            inside: Prism.languages.jsx
        }
    }, Prism.languages.jsx.tag);
    Prism.languages.insertBefore("inside", "special-attr", {
        "script": {
            // Allow for two levels of nesting
            pattern: re(/=<BRACES>/.source),
            alias: "language-javascript",
            inside: {
                "script-punctuation": {
                    pattern: /^=(?=\{)/,
                    alias: "punctuation"
                },
                rest: Prism.languages.jsx
            }
        }
    }, Prism.languages.jsx.tag);
    // The following will handle plain text inside tags
    var stringifyToken = function(token) {
        if (!token) {
            return "";
        }
        if (typeof token === "string") {
            return token;
        }
        if (typeof token.content === "string") {
            return token.content;
        }
        return token.content.map(stringifyToken).join("");
    };
    var walkTokens = function(tokens) {
        var openedTags = [];
        for(var i = 0; i < tokens.length; i++){
            var token = tokens[i];
            var notTagNorBrace = false;
            if (typeof token !== "string") {
                if (token.type === "tag" && token.content[0] && token.content[0].type === "tag") {
                    // We found a tag, now find its kind
                    if (token.content[0].content[0].content === "</") {
                        // Closing tag
                        if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {
                            // Pop matching opening tag
                            openedTags.pop();
                        }
                    } else {
                        if (token.content[token.content.length - 1].content === "/>") ;
                        else {
                            // Opening tag
                            openedTags.push({
                                tagName: stringifyToken(token.content[0].content[1]),
                                openedBraces: 0
                            });
                        }
                    }
                } else if (openedTags.length > 0 && token.type === "punctuation" && token.content === "{") {
                    // Here we might have entered a JSX context inside a tag
                    openedTags[openedTags.length - 1].openedBraces++;
                } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === "punctuation" && token.content === "}") {
                    // Here we might have left a JSX context inside a tag
                    openedTags[openedTags.length - 1].openedBraces--;
                } else {
                    notTagNorBrace = true;
                }
            }
            if (notTagNorBrace || typeof token === "string") {
                if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
                    // Here we are inside a tag, and not inside a JSX context.
                    // That's plain text: drop any tokens matched.
                    var plainText = stringifyToken(token);
                    // And merge text with adjacent text
                    if (i < tokens.length - 1 && (typeof tokens[i + 1] === "string" || tokens[i + 1].type === "plain-text")) {
                        plainText += stringifyToken(tokens[i + 1]);
                        tokens.splice(i + 1, 1);
                    }
                    if (i > 0 && (typeof tokens[i - 1] === "string" || tokens[i - 1].type === "plain-text")) {
                        plainText = stringifyToken(tokens[i - 1]) + plainText;
                        tokens.splice(i - 1, 1);
                        i--;
                    }
                    tokens[i] = new Prism.Token("plain-text", plainText, null, plainText);
                }
            }
            if (token.content && typeof token.content !== "string") {
                walkTokens(token.content);
            }
        }
    };
    Prism.hooks.add("after-tokenize", function(env) {
        if (env.language !== "jsx" && env.language !== "tsx") {
            return;
        }
        walkTokens(env.tokens);
    });
})(Prism);
// https://www.json.org/json-en.html
Prism.languages.json = {
    "property": {
        pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
        lookbehind: true,
        greedy: true
    },
    "string": {
        pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
        lookbehind: true,
        greedy: true
    },
    "comment": {
        pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
        greedy: true
    },
    "number": /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
    "punctuation": /[{}[\],]/,
    "operator": /:/,
    "boolean": /\b(?:false|true)\b/,
    "null": {
        pattern: /\bnull\b/,
        alias: "keyword"
    }
};
Prism.languages.webmanifest = Prism.languages.json;
(function(Prism) {
    Prism.languages.kotlin = Prism.languages.extend("clike", {
        "keyword": {
            // The lookbehind prevents wrong highlighting of e.g. kotlin.properties.get
            pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/,
            lookbehind: true
        },
        "function": [
            {
                pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/,
                greedy: true
            },
            {
                pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/,
                lookbehind: true,
                greedy: true
            }
        ],
        "number": /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/,
        "operator": /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/
    });
    delete Prism.languages.kotlin["class-name"];
    var interpolationInside = {
        "interpolation-punctuation": {
            pattern: /^\$\{?|\}$/,
            alias: "punctuation"
        },
        "expression": {
            pattern: /[\s\S]+/,
            inside: Prism.languages.kotlin
        }
    };
    Prism.languages.insertBefore("kotlin", "string", {
        // https://kotlinlang.org/spec/expressions.html#string-interpolation-expressions
        "string-literal": [
            {
                pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/,
                alias: "multiline",
                inside: {
                    "interpolation": {
                        pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i,
                        inside: interpolationInside
                    },
                    "string": /[\s\S]+/
                }
            },
            {
                pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/,
                alias: "singleline",
                inside: {
                    "interpolation": {
                        pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i,
                        lookbehind: true,
                        inside: interpolationInside
                    },
                    "string": /[\s\S]+/
                }
            }
        ],
        "char": {
            // https://kotlinlang.org/spec/expressions.html#character-literals
            pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/,
            greedy: true
        }
    });
    delete Prism.languages.kotlin["string"];
    Prism.languages.insertBefore("kotlin", "keyword", {
        "annotation": {
            pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/,
            alias: "builtin"
        }
    });
    Prism.languages.insertBefore("kotlin", "function", {
        "label": {
            pattern: /\b\w+@|@\w+\b/,
            alias: "symbol"
        }
    });
    Prism.languages.kt = Prism.languages.kotlin;
    Prism.languages.kts = Prism.languages.kotlin;
})(Prism);
/* FIXME :
 :extend() is not handled specifically : its highlighting is buggy.
 Mixin usage must be inside a ruleset to be highlighted.
 At-rules (e.g. import) containing interpolations are buggy.
 Detached rulesets are highlighted as at-rules.
 A comment before a mixin usage prevents the latter to be properly highlighted.
 */ Prism.languages.less = Prism.languages.extend("css", {
    "comment": [
        /\/\*[\s\S]*?\*\//,
        {
            pattern: /(^|[^\\])\/\/.*/,
            lookbehind: true
        }
    ],
    "atrule": {
        pattern: /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
        inside: {
            "punctuation": /[:()]/
        }
    },
    // selectors and mixins are considered the same
    "selector": {
        pattern: /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
        inside: {
            // mixin parameters
            "variable": /@+[\w-]+/
        }
    },
    "property": /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
    "operator": /[+\-*\/]/
});
Prism.languages.insertBefore("less", "property", {
    "variable": [
        // Variable declaration (the colon must be consumed!)
        {
            pattern: /@[\w-]+\s*:/,
            inside: {
                "punctuation": /:/
            }
        },
        // Variable usage
        /@@?[\w-]+/
    ],
    "mixin-usage": {
        pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
        lookbehind: true,
        alias: "function"
    }
});
Prism.languages.lua = {
    "comment": /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
    // \z may be used to skip the following space
    "string": {
        pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
        greedy: true
    },
    "number": /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
    "keyword": /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
    "function": /(?!\d)\w+(?=\s*(?:[({]))/,
    "operator": [
        /[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/,
        {
            // Match ".." but don't break "..."
            pattern: /(^|[^.])\.\.(?!\.)/,
            lookbehind: true
        }
    ],
    "punctuation": /[\[\](){},;]|\.+|:+/
};
Prism.languages.makefile = {
    "comment": {
        pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
        lookbehind: true
    },
    "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
    },
    "builtin-target": {
        pattern: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
        alias: "builtin"
    },
    "target": {
        pattern: /^(?:[^:=\s]|[ \t]+(?![\s:]))+(?=\s*:(?!=))/m,
        alias: "symbol",
        inside: {
            "variable": /\$+(?:(?!\$)[^(){}:#=\s]+|(?=[({]))/
        }
    },
    "variable": /\$+(?:(?!\$)[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
    // Directives
    "keyword": /-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
    "function": {
        pattern: /(\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \t])/,
        lookbehind: true
    },
    "operator": /(?:::|[?:+!])?=|[|@]/,
    "punctuation": /[:;(){}]/
};
(function(Prism) {
    // https://yaml.org/spec/1.2/spec.html#c-ns-anchor-property
    // https://yaml.org/spec/1.2/spec.html#c-ns-alias-node
    var anchorOrAlias = /[*&][^\s[\]{},]+/;
    // https://yaml.org/spec/1.2/spec.html#c-ns-tag-property
    var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
    // https://yaml.org/spec/1.2/spec.html#c-ns-properties(n,c)
    var properties = "(?:" + tag.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag.source + ")?)";
    // https://yaml.org/spec/1.2/spec.html#ns-plain(n,c)
    // This is a simplified version that doesn't support "#" and multiline keys
    // All these long scarry character classes are simplified versions of YAML's characters
    var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
        return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
    });
    var string = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
    /**
   *
   * @param {string} value
   * @param {string} [flags]
   * @returns {RegExp}
   */ function createValuePattern(value, flags) {
        flags = (flags || "").replace(/m/g, "") + "m"; // add m flag
        var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
            return properties;
        }).replace(/<<value>>/g, function() {
            return value;
        });
        return RegExp(pattern, flags);
    }
    Prism.languages.yaml = {
        "scalar": {
            pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
                return properties;
            })),
            lookbehind: true,
            alias: "string"
        },
        "comment": /#.*/,
        "key": {
            pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
                return properties;
            }).replace(/<<key>>/g, function() {
                return "(?:" + plainKey + "|" + string + ")";
            })),
            lookbehind: true,
            greedy: true,
            alias: "atrule"
        },
        "directive": {
            pattern: /(^[ \t]*)%.+/m,
            lookbehind: true,
            alias: "important"
        },
        "datetime": {
            pattern: createValuePattern(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
            lookbehind: true,
            alias: "number"
        },
        "boolean": {
            pattern: createValuePattern(/false|true/.source, "i"),
            lookbehind: true,
            alias: "important"
        },
        "null": {
            pattern: createValuePattern(/null|~/.source, "i"),
            lookbehind: true,
            alias: "important"
        },
        "string": {
            pattern: createValuePattern(string),
            lookbehind: true,
            greedy: true
        },
        "number": {
            pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
            lookbehind: true
        },
        "tag": tag,
        "important": anchorOrAlias,
        "punctuation": /---|[:[\]{}\-,|>?]|\.\.\./
    };
    Prism.languages.yml = Prism.languages.yaml;
})(Prism);
(function(Prism) {
    // Allow only one line break
    var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
    /**
   * This function is intended for the creation of the bold or italic pattern.
   *
   * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.
   *
   * _Note:_ Keep in mind that this adds a capturing group.
   *
   * @param {string} pattern
   * @returns {RegExp}
   */ function createInline(pattern) {
        pattern = pattern.replace(/<inner>/g, function() {
            return inner;
        });
        return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
    }
    var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
    var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
        return tableCell;
    });
    var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
    Prism.languages.markdown = Prism.languages.extend("markup", {});
    Prism.languages.insertBefore("markdown", "prolog", {
        "front-matter-block": {
            pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
            lookbehind: true,
            greedy: true,
            inside: {
                "punctuation": /^---|---$/,
                "front-matter": {
                    pattern: /\S+(?:\s+\S+)*/,
                    alias: [
                        "yaml",
                        "language-yaml"
                    ],
                    inside: Prism.languages.yaml
                }
            }
        },
        "blockquote": {
            // > ...
            pattern: /^>(?:[\t ]*>)*/m,
            alias: "punctuation"
        },
        "table": {
            pattern: RegExp("^" + tableRow + tableLine + "(?:" + tableRow + ")*", "m"),
            inside: {
                "table-data-rows": {
                    pattern: RegExp("^(" + tableRow + tableLine + ")(?:" + tableRow + ")*$"),
                    lookbehind: true,
                    inside: {
                        "table-data": {
                            pattern: RegExp(tableCell),
                            inside: Prism.languages.markdown
                        },
                        "punctuation": /\|/
                    }
                },
                "table-line": {
                    pattern: RegExp("^(" + tableRow + ")" + tableLine + "$"),
                    lookbehind: true,
                    inside: {
                        "punctuation": /\||:?-{3,}:?/
                    }
                },
                "table-header-row": {
                    pattern: RegExp("^" + tableRow + "$"),
                    inside: {
                        "table-header": {
                            pattern: RegExp(tableCell),
                            alias: "important",
                            inside: Prism.languages.markdown
                        },
                        "punctuation": /\|/
                    }
                }
            }
        },
        "code": [
            {
                // Prefixed by 4 spaces or 1 tab and preceded by an empty line
                pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
                lookbehind: true,
                alias: "keyword"
            },
            {
                // ```optional language
                // code block
                // ```
                pattern: /^```[\s\S]*?^```$/m,
                greedy: true,
                inside: {
                    "code-block": {
                        pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
                        lookbehind: true
                    },
                    "code-language": {
                        pattern: /^(```).+/,
                        lookbehind: true
                    },
                    "punctuation": /```/
                }
            }
        ],
        "title": [
            {
                // title 1
                // =======
                // title 2
                // -------
                pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
                alias: "important",
                inside: {
                    punctuation: /==+$|--+$/
                }
            },
            {
                // # title 1
                // ###### title 6
                pattern: /(^\s*)#.+/m,
                lookbehind: true,
                alias: "important",
                inside: {
                    punctuation: /^#+|#+$/
                }
            }
        ],
        "hr": {
            // ***
            // ---
            // * * *
            // -----------
            pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
            lookbehind: true,
            alias: "punctuation"
        },
        "list": {
            // * item
            // + item
            // - item
            // 1. item
            pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
            lookbehind: true,
            alias: "punctuation"
        },
        "url-reference": {
            // [id]: http://example.com "Optional title"
            // [id]: http://example.com 'Optional title'
            // [id]: http://example.com (Optional title)
            // [id]: <http://example.com> "Optional title"
            pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
            inside: {
                "variable": {
                    pattern: /^(!?\[)[^\]]+/,
                    lookbehind: true
                },
                "string": /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
                "punctuation": /^[\[\]!:]|[<>]/
            },
            alias: "url"
        },
        "bold": {
            // **strong**
            // __strong__
            // allow one nested instance of italic text using the same delimiter
            pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
            lookbehind: true,
            greedy: true,
            inside: {
                "content": {
                    pattern: /(^..)[\s\S]+(?=..$)/,
                    lookbehind: true,
                    inside: {} // see below
                },
                "punctuation": /\*\*|__/
            }
        },
        "italic": {
            // *em*
            // _em_
            // allow one nested instance of bold text using the same delimiter
            pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
            lookbehind: true,
            greedy: true,
            inside: {
                "content": {
                    pattern: /(^.)[\s\S]+(?=.$)/,
                    lookbehind: true,
                    inside: {} // see below
                },
                "punctuation": /[*_]/
            }
        },
        "strike": {
            // ~~strike through~~
            // ~strike~
            // eslint-disable-next-line regexp/strict
            pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
            lookbehind: true,
            greedy: true,
            inside: {
                "content": {
                    pattern: /(^~~?)[\s\S]+(?=\1$)/,
                    lookbehind: true,
                    inside: {} // see below
                },
                "punctuation": /~~?/
            }
        },
        "code-snippet": {
            // `code`
            // ``code``
            pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
            lookbehind: true,
            greedy: true,
            alias: [
                "code",
                "keyword"
            ]
        },
        "url": {
            // [example](http://example.com "Optional title")
            // [example][id]
            // [example] [id]
            pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
            lookbehind: true,
            greedy: true,
            inside: {
                "operator": /^!/,
                "content": {
                    pattern: /(^\[)[^\]]+(?=\])/,
                    lookbehind: true,
                    inside: {} // see below
                },
                "variable": {
                    pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
                    lookbehind: true
                },
                "url": {
                    pattern: /(^\]\()[^\s)]+/,
                    lookbehind: true
                },
                "string": {
                    pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
                    lookbehind: true
                }
            }
        }
    });
    [
        "url",
        "bold",
        "italic",
        "strike"
    ].forEach(function(token) {
        [
            "url",
            "bold",
            "italic",
            "strike",
            "code-snippet"
        ].forEach(function(inside) {
            if (token !== inside) {
                Prism.languages.markdown[token].inside.content.inside[inside] = Prism.languages.markdown[inside];
            }
        });
    });
    Prism.hooks.add("after-tokenize", function(env) {
        if (env.language !== "markdown" && env.language !== "md") {
            return;
        }
        function walkTokens(tokens) {
            if (!tokens || typeof tokens === "string") {
                return;
            }
            for(var i = 0, l = tokens.length; i < l; i++){
                var token = tokens[i];
                if (token.type !== "code") {
                    walkTokens(token.content);
                    continue;
                }
                /*
         * Add the correct `language-xxxx` class to this code block. Keep in mind that the `code-language` token
         * is optional. But the grammar is defined so that there is only one case we have to handle:
         *
         * token.content = [
         *     <span class="punctuation">```</span>,
         *     <span class="code-language">xxxx</span>,
         *     '\n', // exactly one new lines (\r or \n or \r\n)
         *     <span class="code-block">...</span>,
         *     '\n', // exactly one new lines again
         *     <span class="punctuation">```</span>
         * ];
         */ var codeLang = token.content[1];
                var codeBlock = token.content[3];
                if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
                    // this might be a language that Prism does not support
                    // do some replacements to support C++, C#, and F#
                    var lang = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
                    // only use the first word
                    lang = (/[a-z][\w-]*/i.exec(lang) || [
                        ""
                    ])[0].toLowerCase();
                    var alias = "language-" + lang;
                    // add alias
                    if (!codeBlock.alias) {
                        codeBlock.alias = [
                            alias
                        ];
                    } else if (typeof codeBlock.alias === "string") {
                        codeBlock.alias = [
                            codeBlock.alias,
                            alias
                        ];
                    } else {
                        codeBlock.alias.push(alias);
                    }
                }
            }
        }
        walkTokens(env.tokens);
    });
    Prism.hooks.add("wrap", function(env) {
        if (env.type !== "code-block") {
            return;
        }
        var codeLang = "";
        for(var i = 0, l = env.classes.length; i < l; i++){
            var cls = env.classes[i];
            var match = /language-(.+)/.exec(cls);
            if (match) {
                codeLang = match[1];
                break;
            }
        }
        var grammar = Prism.languages[codeLang];
        if (!grammar) {
            if (codeLang && codeLang !== "none" && Prism.plugins.autoloader) {
                var id = "md-" + new Date().valueOf() + "-" + Math.floor(Math.random() * 1e16);
                env.attributes["id"] = id;
                Prism.plugins.autoloader.loadLanguages(codeLang, function() {
                    var ele = document.getElementById(id);
                    if (ele) {
                        ele.innerHTML = Prism.highlight(ele.textContent, Prism.languages[codeLang], codeLang);
                    }
                });
            }
        } else {
            env.content = Prism.highlight(textContent(env.content), grammar, codeLang);
        }
    });
    var tagPattern = RegExp(Prism.languages.markup.tag.pattern.source, "gi");
    /**
   * A list of known entity names.
   *
   * This will always be incomplete to save space. The current list is the one used by lowdash's unescape function.
   *
   * @see {@link https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/unescape.js#L2}
   */ var KNOWN_ENTITY_NAMES = {
        "amp": "&",
        "lt": "<",
        "gt": ">",
        "quot": '"'
    };
    // IE 11 doesn't support `String.fromCodePoint`
    var fromCodePoint = String.fromCodePoint || String.fromCharCode;
    /**
   * Returns the text content of a given HTML source code string.
   *
   * @param {string} html
   * @returns {string}
   */ function textContent(html) {
        // remove all tags
        var text = html.replace(tagPattern, "");
        // decode known entities
        text = text.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m, code) {
            code = code.toLowerCase();
            if (code[0] === "#") {
                var value;
                if (code[1] === "x") {
                    value = parseInt(code.slice(2), 16);
                } else {
                    value = Number(code.slice(1));
                }
                return fromCodePoint(value);
            } else {
                var known = KNOWN_ENTITY_NAMES[code];
                if (known) {
                    return known;
                }
                // unable to decode
                return m;
            }
        });
        return text;
    }
    Prism.languages.md = Prism.languages.markdown;
})(Prism);
Prism.languages.objectivec = Prism.languages.extend("c", {
    "string": {
        pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
        greedy: true
    },
    "keyword": /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
    "operator": /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
});
delete Prism.languages.objectivec["class-name"];
Prism.languages.objc = Prism.languages.objectivec;
(function(Prism) {
    var brackets = /(?:\((?:[^()\\]|\\[\s\S])*\)|\{(?:[^{}\\]|\\[\s\S])*\}|\[(?:[^[\]\\]|\\[\s\S])*\]|<(?:[^<>\\]|\\[\s\S])*>)/.source;
    Prism.languages.perl = {
        "comment": [
            {
                // POD
                pattern: /(^\s*)=\w[\s\S]*?=cut.*/m,
                lookbehind: true,
                greedy: true
            },
            {
                pattern: /(^|[^\\$])#.*/,
                lookbehind: true,
                greedy: true
            }
        ],
        // TODO Could be nice to handle Heredoc too.
        "string": [
            {
                pattern: RegExp(/\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
                    // q/.../
                    /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
                    // q a...a
                    // eslint-disable-next-line regexp/strict
                    /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
                    // q(...)
                    // q{...}
                    // q[...]
                    // q<...>
                    brackets
                ].join("|") + ")"),
                greedy: true
            },
            // "...", `...`
            {
                pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/,
                greedy: true
            },
            // '...'
            // FIXME Multi-line single-quoted strings are not supported as they would break variables containing '
            {
                pattern: /'(?:[^'\\\r\n]|\\.)*'/,
                greedy: true
            }
        ],
        "regex": [
            {
                pattern: RegExp(/\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
                    // m/.../
                    /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
                    // m a...a
                    // eslint-disable-next-line regexp/strict
                    /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
                    // m(...)
                    // m{...}
                    // m[...]
                    // m<...>
                    brackets
                ].join("|") + ")" + /[msixpodualngc]*/.source),
                greedy: true
            },
            // The lookbehinds prevent -s from breaking
            {
                pattern: RegExp(/(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
                    // s/.../.../
                    // eslint-disable-next-line regexp/strict
                    /([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
                    // s a...a...a
                    // eslint-disable-next-line regexp/strict
                    /([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/.source,
                    // s(...)(...)
                    // s{...}{...}
                    // s[...][...]
                    // s<...><...>
                    // s(...)[...]
                    brackets + /\s*/.source + brackets
                ].join("|") + ")" + /[msixpodualngcer]*/.source),
                lookbehind: true,
                greedy: true
            },
            // /.../
            // The look-ahead tries to prevent two divisions on
            // the same line from being highlighted as regex.
            // This does not support multi-line regex.
            {
                pattern: /\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\b))/,
                greedy: true
            }
        ],
        // FIXME Not sure about the handling of ::, ', and #
        "variable": [
            // ${^POSTMATCH}
            /[&*$@%]\{\^[A-Z]+\}/,
            // $^V
            /[&*$@%]\^[A-Z_]/,
            // ${...}
            /[&*$@%]#?(?=\{)/,
            // $foo
            /[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+(?![\w$]))+(?:::)*/,
            // $1
            /[&*$@%]\d+/,
            // $_, @_, %!
            // The negative lookahead prevents from breaking the %= operator
            /(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
        ],
        "filehandle": {
            // <>, <FOO>, _
            pattern: /<(?![<=])\S*?>|\b_\b/,
            alias: "symbol"
        },
        "v-string": {
            // v1.2, 1.2.3
            pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
            alias: "string"
        },
        "function": {
            pattern: /(\bsub[ \t]+)\w+/,
            lookbehind: true
        },
        "keyword": /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
        "number": /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
        "operator": /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\b/,
        "punctuation": /[{}[\];(),:]/
    };
})(Prism);
(function(Prism) {
    /**
   * Returns the placeholder for the given language id and index.
   *
   * @param {string} language
   * @param {string|number} index
   * @returns {string}
   */ function getPlaceholder(language, index) {
        return "___" + language.toUpperCase() + index + "___";
    }
    Object.defineProperties(Prism.languages["markup-templating"] = {}, {
        buildPlaceholders: {
            /**
       * Tokenize all inline templating expressions matching `placeholderPattern`.
       *
       * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
       * `true` will be replaced.
       *
       * @param {object} env The environment of the `before-tokenize` hook.
       * @param {string} language The language id.
       * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
       * @param {(match: string) => boolean} [replaceFilter]
       */ value: function(env, language, placeholderPattern, replaceFilter) {
                if (env.language !== language) {
                    return;
                }
                var tokenStack = env.tokenStack = [];
                env.code = env.code.replace(placeholderPattern, function(match) {
                    if (typeof replaceFilter === "function" && !replaceFilter(match)) {
                        return match;
                    }
                    var i = tokenStack.length;
                    var placeholder;
                    // Check for existing strings
                    while(env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1){
                        ++i;
                    }
                    // Create a sparse array
                    tokenStack[i] = match;
                    return placeholder;
                });
                // Switch the grammar to markup
                env.grammar = Prism.languages.markup;
            }
        },
        tokenizePlaceholders: {
            /**
       * Replace placeholders with proper tokens after tokenizing.
       *
       * @param {object} env The environment of the `after-tokenize` hook.
       * @param {string} language The language id.
       */ value: function(env, language) {
                if (env.language !== language || !env.tokenStack) {
                    return;
                }
                // Switch the grammar back
                env.grammar = Prism.languages[language];
                var j = 0;
                var keys = Object.keys(env.tokenStack);
                function walkTokens(tokens) {
                    for(var i = 0; i < tokens.length; i++){
                        // all placeholders are replaced already
                        if (j >= keys.length) {
                            break;
                        }
                        var token = tokens[i];
                        if (typeof token === "string" || token.content && typeof token.content === "string") {
                            var k = keys[j];
                            var t = env.tokenStack[k];
                            var s = typeof token === "string" ? token : token.content;
                            var placeholder = getPlaceholder(language, k);
                            var index = s.indexOf(placeholder);
                            if (index > -1) {
                                ++j;
                                var before = s.substring(0, index);
                                var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), "language-" + language, t);
                                var after = s.substring(index + placeholder.length);
                                var replacement = [];
                                if (before) {
                                    replacement.push.apply(replacement, walkTokens([
                                        before
                                    ]));
                                }
                                replacement.push(middle);
                                if (after) {
                                    replacement.push.apply(replacement, walkTokens([
                                        after
                                    ]));
                                }
                                if (typeof token === "string") {
                                    tokens.splice.apply(tokens, [
                                        i,
                                        1
                                    ].concat(replacement));
                                } else {
                                    token.content = replacement;
                                }
                            }
                        } else if (token.content /* && typeof token.content !== 'string' */ ) {
                            walkTokens(token.content);
                        }
                    }
                    return tokens;
                }
                walkTokens(env.tokens);
            }
        }
    });
})(Prism);
/**
 * Original by Aaron Harun: http://aahacreative.com/2012/07/31/php-syntax-highlighting-prism/
 * Modified by Miles Johnson: http://milesj.me
 * Rewritten by Tom Pavelec
 *
 * Supports PHP 5.3 - 8.0
 */ (function(Prism) {
    var comment = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/;
    var constant = [
        {
            pattern: /\b(?:false|true)\b/i,
            alias: "boolean"
        },
        {
            pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
            greedy: true,
            lookbehind: true
        },
        {
            pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
            greedy: true,
            lookbehind: true
        },
        /\b(?:null)\b/i,
        /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/
    ];
    var number = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i;
    var operator = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/;
    var punctuation = /[{}\[\](),:;]/;
    Prism.languages.php = {
        "delimiter": {
            pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
            alias: "important"
        },
        "comment": comment,
        "variable": /\$+(?:\w+\b|(?=\{))/,
        "package": {
            pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
            lookbehind: true,
            inside: {
                "punctuation": /\\/
            }
        },
        "class-name-definition": {
            pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
            lookbehind: true,
            alias: "class-name"
        },
        "function-definition": {
            pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
            lookbehind: true,
            alias: "function"
        },
        "keyword": [
            {
                pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
                alias: "type-casting",
                greedy: true,
                lookbehind: true
            },
            {
                pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
                alias: "type-hint",
                greedy: true,
                lookbehind: true
            },
            {
                pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|never|object|self|static|string|void)\b/i,
                alias: "return-type",
                greedy: true,
                lookbehind: true
            },
            {
                pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
                alias: "type-declaration",
                greedy: true
            },
            {
                pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
                alias: "type-declaration",
                greedy: true,
                lookbehind: true
            },
            {
                pattern: /\b(?:parent|self|static)(?=\s*::)/i,
                alias: "static-context",
                greedy: true
            },
            {
                // yield from
                pattern: /(\byield\s+)from\b/i,
                lookbehind: true
            },
            // `class` is always a keyword unlike other keywords
            /\bclass\b/i,
            {
                // https://www.php.net/manual/en/reserved.keywords.php
                //
                // keywords cannot be preceded by "->"
                // the complex lookbehind means `(?<!(?:->|::)\s*)`
                pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
                lookbehind: true
            }
        ],
        "argument-name": {
            pattern: /([(,]\s*)\b[a-z_]\w*(?=\s*:(?!:))/i,
            lookbehind: true
        },
        "class-name": [
            {
                pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
                greedy: true,
                lookbehind: true
            },
            {
                pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
                greedy: true,
                lookbehind: true
            },
            {
                pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
                greedy: true
            },
            {
                pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
                alias: "class-name-fully-qualified",
                greedy: true,
                lookbehind: true,
                inside: {
                    "punctuation": /\\/
                }
            },
            {
                pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
                alias: "class-name-fully-qualified",
                greedy: true,
                inside: {
                    "punctuation": /\\/
                }
            },
            {
                pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
                alias: "class-name-fully-qualified",
                greedy: true,
                lookbehind: true,
                inside: {
                    "punctuation": /\\/
                }
            },
            {
                pattern: /\b[a-z_]\w*(?=\s*\$)/i,
                alias: "type-declaration",
                greedy: true
            },
            {
                pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
                alias: [
                    "class-name-fully-qualified",
                    "type-declaration"
                ],
                greedy: true,
                inside: {
                    "punctuation": /\\/
                }
            },
            {
                pattern: /\b[a-z_]\w*(?=\s*::)/i,
                alias: "static-context",
                greedy: true
            },
            {
                pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
                alias: [
                    "class-name-fully-qualified",
                    "static-context"
                ],
                greedy: true,
                inside: {
                    "punctuation": /\\/
                }
            },
            {
                pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
                alias: "type-hint",
                greedy: true,
                lookbehind: true
            },
            {
                pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
                alias: [
                    "class-name-fully-qualified",
                    "type-hint"
                ],
                greedy: true,
                lookbehind: true,
                inside: {
                    "punctuation": /\\/
                }
            },
            {
                pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
                alias: "return-type",
                greedy: true,
                lookbehind: true
            },
            {
                pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
                alias: [
                    "class-name-fully-qualified",
                    "return-type"
                ],
                greedy: true,
                lookbehind: true,
                inside: {
                    "punctuation": /\\/
                }
            }
        ],
        "constant": constant,
        "function": {
            pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
            lookbehind: true,
            inside: {
                "punctuation": /\\/
            }
        },
        "property": {
            pattern: /(->\s*)\w+/,
            lookbehind: true
        },
        "number": number,
        "operator": operator,
        "punctuation": punctuation
    };
    var string_interpolation = {
        pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
        lookbehind: true,
        inside: Prism.languages.php
    };
    var string = [
        {
            pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
            alias: "nowdoc-string",
            greedy: true,
            inside: {
                "delimiter": {
                    pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
                    alias: "symbol",
                    inside: {
                        "punctuation": /^<<<'?|[';]$/
                    }
                }
            }
        },
        {
            pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
            alias: "heredoc-string",
            greedy: true,
            inside: {
                "delimiter": {
                    pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
                    alias: "symbol",
                    inside: {
                        "punctuation": /^<<<"?|[";]$/
                    }
                },
                "interpolation": string_interpolation
            }
        },
        {
            pattern: /`(?:\\[\s\S]|[^\\`])*`/,
            alias: "backtick-quoted-string",
            greedy: true
        },
        {
            pattern: /'(?:\\[\s\S]|[^\\'])*'/,
            alias: "single-quoted-string",
            greedy: true
        },
        {
            pattern: /"(?:\\[\s\S]|[^\\"])*"/,
            alias: "double-quoted-string",
            greedy: true,
            inside: {
                "interpolation": string_interpolation
            }
        }
    ];
    Prism.languages.insertBefore("php", "variable", {
        "string": string,
        "attribute": {
            pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
            greedy: true,
            inside: {
                "attribute-content": {
                    pattern: /^(#\[)[\s\S]+(?=\]$)/,
                    lookbehind: true,
                    // inside can appear subset of php
                    inside: {
                        "comment": comment,
                        "string": string,
                        "attribute-class-name": [
                            {
                                pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
                                alias: "class-name",
                                greedy: true,
                                lookbehind: true
                            },
                            {
                                pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
                                alias: [
                                    "class-name",
                                    "class-name-fully-qualified"
                                ],
                                greedy: true,
                                lookbehind: true,
                                inside: {
                                    "punctuation": /\\/
                                }
                            }
                        ],
                        "constant": constant,
                        "number": number,
                        "operator": operator,
                        "punctuation": punctuation
                    }
                },
                "delimiter": {
                    pattern: /^#\[|\]$/,
                    alias: "punctuation"
                }
            }
        }
    });
    Prism.hooks.add("before-tokenize", function(env) {
        if (!/<\?/.test(env.code)) {
            return;
        }
        var phpPattern = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
        Prism.languages["markup-templating"].buildPlaceholders(env, "php", phpPattern);
    });
    Prism.hooks.add("after-tokenize", function(env) {
        Prism.languages["markup-templating"].tokenizePlaceholders(env, "php");
    });
})(Prism);
Prism.languages.python = {
    "comment": {
        pattern: /(^|[^\\])#.*/,
        lookbehind: true,
        greedy: true
    },
    "string-interpolation": {
        pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
        greedy: true,
        inside: {
            "interpolation": {
                // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
                pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
                lookbehind: true,
                inside: {
                    "format-spec": {
                        pattern: /(:)[^:(){}]+(?=\}$)/,
                        lookbehind: true
                    },
                    "conversion-option": {
                        pattern: /![sra](?=[:}]$)/,
                        alias: "punctuation"
                    },
                    rest: null
                }
            },
            "string": /[\s\S]+/
        }
    },
    "triple-quoted-string": {
        pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
        greedy: true,
        alias: "string"
    },
    "string": {
        pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
        greedy: true
    },
    "function": {
        pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
        lookbehind: true
    },
    "class-name": {
        pattern: /(\bclass\s+)\w+/i,
        lookbehind: true
    },
    "decorator": {
        pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
        lookbehind: true,
        alias: [
            "annotation",
            "punctuation"
        ],
        inside: {
            "punctuation": /\./
        }
    },
    "keyword": /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
    "builtin": /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
    "boolean": /\b(?:False|None|True)\b/,
    "number": /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
    "operator": /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
    "punctuation": /[{}[\];(),.:]/
};
Prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism.languages.python;
Prism.languages.py = Prism.languages.python;
Prism.languages.r = {
    "comment": /#.*/,
    "string": {
        pattern: /(['"])(?:\\.|(?!\1)[^\\\r\n])*\1/,
        greedy: true
    },
    "percent-operator": {
        // Includes user-defined operators
        // and %%, %*%, %/%, %in%, %o%, %x%
        pattern: /%[^%\s]*%/,
        alias: "operator"
    },
    "boolean": /\b(?:FALSE|TRUE)\b/,
    "ellipsis": /\.\.(?:\.|\d+)/,
    "number": [
        /\b(?:Inf|NaN)\b/,
        /(?:\b0x[\dA-Fa-f]+(?:\.\d*)?|\b\d+(?:\.\d*)?|\B\.\d+)(?:[EePp][+-]?\d+)?[iL]?/
    ],
    "keyword": /\b(?:NA|NA_character_|NA_complex_|NA_integer_|NA_real_|NULL|break|else|for|function|if|in|next|repeat|while)\b/,
    "operator": /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\|\|?|[+*\/^$@~]/,
    "punctuation": /[(){}\[\],;]/
};
/**
 * Original by Samuel Flores
 *
 * Adds the following new token classes:
 *     constant, builtin, variable, symbol, regex
 */ (function(Prism) {
    Prism.languages.ruby = Prism.languages.extend("clike", {
        "comment": {
            pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
            greedy: true
        },
        "class-name": {
            pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
            lookbehind: true,
            inside: {
                "punctuation": /[.\\]/
            }
        },
        "keyword": /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
        "operator": /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
        "punctuation": /[(){}[\].,;]/
    });
    Prism.languages.insertBefore("ruby", "operator", {
        "double-colon": {
            pattern: /::/,
            alias: "punctuation"
        }
    });
    var interpolation = {
        pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
        lookbehind: true,
        inside: {
            "content": {
                pattern: /^(#\{)[\s\S]+(?=\}$)/,
                lookbehind: true,
                inside: Prism.languages.ruby
            },
            "delimiter": {
                pattern: /^#\{|\}$/,
                alias: "punctuation"
            }
        }
    };
    delete Prism.languages.ruby.function;
    var percentExpression = "(?:" + [
        /([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
        /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source,
        /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source,
        /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source,
        /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source
    ].join("|") + ")";
    var symbolName = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
    Prism.languages.insertBefore("ruby", "keyword", {
        "regex-literal": [
            {
                pattern: RegExp(/%r/.source + percentExpression + /[egimnosux]{0,6}/.source),
                greedy: true,
                inside: {
                    "interpolation": interpolation,
                    "regex": /[\s\S]+/
                }
            },
            {
                pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
                lookbehind: true,
                greedy: true,
                inside: {
                    "interpolation": interpolation,
                    "regex": /[\s\S]+/
                }
            }
        ],
        "variable": /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
        "symbol": [
            {
                pattern: RegExp(/(^|[^:]):/.source + symbolName),
                lookbehind: true,
                greedy: true
            },
            {
                pattern: RegExp(/([\r\n{(,][ \t]*)/.source + symbolName + /(?=:(?!:))/.source),
                lookbehind: true,
                greedy: true
            }
        ],
        "method-definition": {
            pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
            lookbehind: true,
            inside: {
                "function": /\b\w+$/,
                "keyword": /^self\b/,
                "class-name": /^\w+/,
                "punctuation": /\./
            }
        }
    });
    Prism.languages.insertBefore("ruby", "string", {
        "string-literal": [
            {
                pattern: RegExp(/%[qQiIwWs]?/.source + percentExpression),
                greedy: true,
                inside: {
                    "interpolation": interpolation,
                    "string": /[\s\S]+/
                }
            },
            {
                pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
                greedy: true,
                inside: {
                    "interpolation": interpolation,
                    "string": /[\s\S]+/
                }
            },
            {
                pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
                alias: "heredoc-string",
                greedy: true,
                inside: {
                    "delimiter": {
                        pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
                        inside: {
                            "symbol": /\b\w+/,
                            "punctuation": /^<<[-~]?/
                        }
                    },
                    "interpolation": interpolation,
                    "string": /[\s\S]+/
                }
            },
            {
                pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
                alias: "heredoc-string",
                greedy: true,
                inside: {
                    "delimiter": {
                        pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
                        inside: {
                            "symbol": /\b\w+/,
                            "punctuation": /^<<[-~]?'|'$/
                        }
                    },
                    "string": /[\s\S]+/
                }
            }
        ],
        "command-literal": [
            {
                pattern: RegExp(/%x/.source + percentExpression),
                greedy: true,
                inside: {
                    "interpolation": interpolation,
                    "command": {
                        pattern: /[\s\S]+/,
                        alias: "string"
                    }
                }
            },
            {
                pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
                greedy: true,
                inside: {
                    "interpolation": interpolation,
                    "command": {
                        pattern: /[\s\S]+/,
                        alias: "string"
                    }
                }
            }
        ]
    });
    delete Prism.languages.ruby.string;
    Prism.languages.insertBefore("ruby", "number", {
        "builtin": /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
        "constant": /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
    });
    Prism.languages.rb = Prism.languages.ruby;
})(Prism);
(function(Prism) {
    var multilineComment = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source;
    for(var i = 0; i < 2; i++){
        // support 4 levels of nested comments
        multilineComment = multilineComment.replace(/<self>/g, function() {
            return multilineComment;
        });
    }
    multilineComment = multilineComment.replace(/<self>/g, function() {
        return /[^\s\S]/.source;
    });
    Prism.languages.rust = {
        "comment": [
            {
                pattern: RegExp(/(^|[^\\])/.source + multilineComment),
                lookbehind: true,
                greedy: true
            },
            {
                pattern: /(^|[^\\:])\/\/.*/,
                lookbehind: true,
                greedy: true
            }
        ],
        "string": {
            pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
            greedy: true
        },
        "char": {
            pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
            greedy: true
        },
        "attribute": {
            pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
            greedy: true,
            alias: "attr-name",
            inside: {
                "string": null // see below
            }
        },
        // Closure params should not be confused with bitwise OR |
        "closure-params": {
            pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
            lookbehind: true,
            greedy: true,
            inside: {
                "closure-punctuation": {
                    pattern: /^\||\|$/,
                    alias: "punctuation"
                },
                rest: null // see below
            }
        },
        "lifetime-annotation": {
            pattern: /'\w+/,
            alias: "symbol"
        },
        "fragment-specifier": {
            pattern: /(\$\w+:)[a-z]+/,
            lookbehind: true,
            alias: "punctuation"
        },
        "variable": /\$\w+/,
        "function-definition": {
            pattern: /(\bfn\s+)\w+/,
            lookbehind: true,
            alias: "function"
        },
        "type-definition": {
            pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
            lookbehind: true,
            alias: "class-name"
        },
        "module-declaration": [
            {
                pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
                lookbehind: true,
                alias: "namespace"
            },
            {
                pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
                lookbehind: true,
                alias: "namespace",
                inside: {
                    "punctuation": /::/
                }
            }
        ],
        "keyword": [
            // https://github.com/rust-lang/reference/blob/master/src/keywords.md
            /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
            // primitives and str
            // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
            /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
        ],
        // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
        // and Rust's naming conventions recommend snake_case anyway.
        // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
        "function": /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
        "macro": {
            pattern: /\b\w+!/,
            alias: "property"
        },
        "constant": /\b[A-Z_][A-Z_\d]+\b/,
        "class-name": /\b[A-Z]\w*\b/,
        "namespace": {
            pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
            inside: {
                "punctuation": /::/
            }
        },
        // Hex, oct, bin, dec numbers with visual separators and type suffix
        "number": /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
        "boolean": /\b(?:false|true)\b/,
        "punctuation": /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
        "operator": /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
    };
    Prism.languages.rust["closure-params"].inside.rest = Prism.languages.rust;
    Prism.languages.rust["attribute"].inside["string"] = Prism.languages.rust["string"];
})(Prism);
(function(Prism) {
    Prism.languages.sass = Prism.languages.extend("css", {
        // Sass comments don't need to be closed, only indented
        "comment": {
            pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t].+)*/m,
            lookbehind: true,
            greedy: true
        }
    });
    Prism.languages.insertBefore("sass", "atrule", {
        // We want to consume the whole line
        "atrule-line": {
            // Includes support for = and + shortcuts
            pattern: /^(?:[ \t]*)[@+=].+/m,
            greedy: true,
            inside: {
                "atrule": /(?:@[\w-]+|[+=])/
            }
        }
    });
    delete Prism.languages.sass.atrule;
    var variable = /\$[-\w]+|#\{\$[-\w]+\}/;
    var operator = [
        /[+*\/%]|[=!]=|<=?|>=?|\b(?:and|not|or)\b/,
        {
            pattern: /(\s)-(?=\s)/,
            lookbehind: true
        }
    ];
    Prism.languages.insertBefore("sass", "property", {
        // We want to consume the whole line
        "variable-line": {
            pattern: /^[ \t]*\$.+/m,
            greedy: true,
            inside: {
                "punctuation": /:/,
                "variable": variable,
                "operator": operator
            }
        },
        // We want to consume the whole line
        "property-line": {
            pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s].*)/m,
            greedy: true,
            inside: {
                "property": [
                    /[^:\s]+(?=\s*:)/,
                    {
                        pattern: /(:)[^:\s]+/,
                        lookbehind: true
                    }
                ],
                "punctuation": /:/,
                "variable": variable,
                "operator": operator,
                "important": Prism.languages.sass.important
            }
        }
    });
    delete Prism.languages.sass.property;
    delete Prism.languages.sass.important;
    // Now that whole lines for other patterns are consumed,
    // what's left should be selectors
    Prism.languages.insertBefore("sass", "punctuation", {
        "selector": {
            pattern: /^([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/m,
            lookbehind: true,
            greedy: true
        }
    });
})(Prism);
Prism.languages.scss = Prism.languages.extend("css", {
    "comment": {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
        lookbehind: true
    },
    "atrule": {
        pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
        inside: {
            "rule": /@[\w-]+/
        }
    },
    // url, compassified
    "url": /(?:[-a-z]+-)?url(?=\()/i,
    // CSS selector regex is not appropriate for Sass
    // since there can be lot more things (var, @ directive, nesting..)
    // a selector must start at the end of a property or after a brace (end of other rules or nesting)
    // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable
    // the end of a selector is found when there is no rules in it ( {} or {\s}) or if there is a property (because an interpolated var
    // can "pass" as a selector- e.g: proper#{$erty})
    // this one was hard to do, so please be careful if you edit this one :)
    "selector": {
        // Initial look-ahead is used to prevent matching of blank selectors
        pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
        inside: {
            "parent": {
                pattern: /&/,
                alias: "important"
            },
            "placeholder": /%[-\w]+/,
            "variable": /\$[-\w]+|#\{\$[-\w]+\}/
        }
    },
    "property": {
        pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
        inside: {
            "variable": /\$[-\w]+|#\{\$[-\w]+\}/
        }
    }
});
Prism.languages.insertBefore("scss", "atrule", {
    "keyword": [
        /@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i,
        {
            pattern: /( )(?:from|through)(?= )/,
            lookbehind: true
        }
    ]
});
Prism.languages.insertBefore("scss", "important", {
    // var and interpolated vars
    "variable": /\$[-\w]+|#\{\$[-\w]+\}/
});
Prism.languages.insertBefore("scss", "function", {
    "module-modifier": {
        pattern: /\b(?:as|hide|show|with)\b/i,
        alias: "keyword"
    },
    "placeholder": {
        pattern: /%[-\w]+/,
        alias: "selector"
    },
    "statement": {
        pattern: /\B!(?:default|optional)\b/i,
        alias: "keyword"
    },
    "boolean": /\b(?:false|true)\b/,
    "null": {
        pattern: /\bnull\b/,
        alias: "keyword"
    },
    "operator": {
        pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
        lookbehind: true
    }
});
Prism.languages.scss["atrule"].inside.rest = Prism.languages.scss;
Prism.languages.sql = {
    "comment": {
        pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
        lookbehind: true
    },
    "variable": [
        {
            pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
            greedy: true
        },
        /@[\w.$]+/
    ],
    "string": {
        pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
        greedy: true,
        lookbehind: true
    },
    "identifier": {
        pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
        greedy: true,
        lookbehind: true,
        inside: {
            "punctuation": /^`|`$/
        }
    },
    "function": /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
    // Should we highlight user defined functions too?
    "keyword": /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
    "boolean": /\b(?:FALSE|NULL|TRUE)\b/i,
    "number": /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
    "operator": /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
    "punctuation": /[;[\]()`,.]/
};
Prism.languages.swift = {
    "comment": {
        // Nested comments are supported up to 2 levels
        pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
        lookbehind: true,
        greedy: true
    },
    "string-literal": [
        // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
        {
            pattern: RegExp(/(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source),
            lookbehind: true,
            greedy: true,
            inside: {
                "interpolation": {
                    pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
                    lookbehind: true,
                    inside: null // see below
                },
                "interpolation-punctuation": {
                    pattern: /^\)|\\\($/,
                    alias: "punctuation"
                },
                "punctuation": /\\(?=[\r\n])/,
                "string": /[\s\S]+/
            }
        },
        {
            pattern: RegExp(/(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")" + "\\2"),
            lookbehind: true,
            greedy: true,
            inside: {
                "interpolation": {
                    pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
                    lookbehind: true,
                    inside: null // see below
                },
                "interpolation-punctuation": {
                    pattern: /^\)|\\#+\($/,
                    alias: "punctuation"
                },
                "string": /[\s\S]+/
            }
        }
    ],
    "directive": {
        // directives with conditions
        pattern: RegExp(/#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"),
        alias: "property",
        inside: {
            "directive-name": /^#\w+/,
            "boolean": /\b(?:false|true)\b/,
            "number": /\b\d+(?:\.\d+)*\b/,
            "operator": /!|&&|\|\||[<>]=?/,
            "punctuation": /[(),]/
        }
    },
    "literal": {
        pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
        alias: "constant"
    },
    "other-directive": {
        pattern: /#\w+\b/,
        alias: "property"
    },
    "attribute": {
        pattern: /@\w+/,
        alias: "atrule"
    },
    "function-definition": {
        pattern: /(\bfunc\s+)\w+/,
        lookbehind: true,
        alias: "function"
    },
    "label": {
        // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
        pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
        lookbehind: true,
        alias: "important"
    },
    "keyword": /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
    "boolean": /\b(?:false|true)\b/,
    "nil": {
        pattern: /\bnil\b/,
        alias: "constant"
    },
    "short-argument": /\$\d+\b/,
    "omit": {
        pattern: /\b_\b/,
        alias: "keyword"
    },
    "number": /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
    // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
    "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
    "function": /\b[a-z_]\w*(?=\s*\()/i,
    "constant": /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
    // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
    // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
    // This regex only supports ASCII operators.
    "operator": /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
    "punctuation": /[{}[\]();,.:\\]/
};
Prism.languages.swift["string-literal"].forEach(function(rule) {
    rule.inside["interpolation"].inside = Prism.languages.swift;
});
(function(Prism) {
    Prism.languages.typescript = Prism.languages.extend("javascript", {
        "class-name": {
            pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
            lookbehind: true,
            greedy: true,
            inside: null // see below
        },
        "builtin": /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
    });
    // The keywords TypeScript adds to JavaScript
    Prism.languages.typescript.keyword.push(/\b(?:abstract|declare|is|keyof|readonly|require)\b/, // keywords that have to be followed by an identifier
    /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/, // This is for `import type *, {}`
    /\btype\b(?=\s*(?:[\{*]|$))/);
    // doesn't work with TS because TS is too complex
    delete Prism.languages.typescript["parameter"];
    delete Prism.languages.typescript["literal-property"];
    // a version of typescript specifically for highlighting types
    var typeInside = Prism.languages.extend("typescript", {});
    delete typeInside["class-name"];
    Prism.languages.typescript["class-name"].inside = typeInside;
    Prism.languages.insertBefore("typescript", "function", {
        "decorator": {
            pattern: /@[$\w\xA0-\uFFFF]+/,
            inside: {
                "at": {
                    pattern: /^@/,
                    alias: "operator"
                },
                "function": /^[\s\S]+/
            }
        },
        "generic-function": {
            // e.g. foo<T extends "bar" | "baz">( ...
            pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
            greedy: true,
            inside: {
                "function": /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
                "generic": {
                    pattern: /<[\s\S]+/,
                    // everything after the first <
                    alias: "class-name",
                    inside: typeInside
                }
            }
        }
    });
    Prism.languages.ts = Prism.languages.typescript;
})(Prism);
(function(Prism) {
    var typescript = Prism.util.clone(Prism.languages.typescript);
    Prism.languages.tsx = Prism.languages.extend("jsx", typescript);
    // doesn't work with TS because TS is too complex
    delete Prism.languages.tsx["parameter"];
    delete Prism.languages.tsx["literal-property"];
    // This will prevent collisions between TSX tags and TS generic types.
    // Idea by https://github.com/karlhorky
    // Discussion: https://github.com/PrismJS/prism/issues/2594#issuecomment-710666928
    var tag = Prism.languages.tsx.tag;
    tag.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + tag.pattern.source + ")", tag.pattern.flags);
    tag.lookbehind = true;
})(Prism);
Prism.languages.basic = {
    "comment": {
        pattern: /(?:!|REM\b).+/i,
        inside: {
            "keyword": /^REM/i
        }
    },
    "string": {
        pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
        greedy: true
    },
    "number": /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
    "keyword": /\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SELECT CASE|SHARED|SHELL|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\$|\b)/i,
    "function": /\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\$|\b)/i,
    "operator": /<[=>]?|>=?|[+\-*\/^=&]|\b(?:AND|EQV|IMP|NOT|OR|XOR)\b/i,
    "punctuation": /[,;:()]/
};
Prism.languages.vbnet = Prism.languages.extend("basic", {
    "comment": [
        {
            pattern: /(?:!|REM\b).+/i,
            inside: {
                "keyword": /^REM/i
            }
        },
        {
            pattern: /(^|[^\\:])'.*/,
            lookbehind: true,
            greedy: true
        }
    ],
    "string": {
        pattern: /(^|[^"])"(?:""|[^"])*"(?!")/,
        lookbehind: true,
        greedy: true
    },
    "keyword": /(?:\b(?:ADDHANDLER|ADDRESSOF|ALIAS|AND|ANDALSO|AS|BEEP|BLOAD|BOOLEAN|BSAVE|BYREF|BYTE|BYVAL|CALL(?: ABSOLUTE)?|CASE|CATCH|CBOOL|CBYTE|CCHAR|CDATE|CDBL|CDEC|CHAIN|CHAR|CHDIR|CINT|CLASS|CLEAR|CLNG|CLOSE|CLS|COBJ|COM|COMMON|CONST|CONTINUE|CSBYTE|CSHORT|CSNG|CSTR|CTYPE|CUINT|CULNG|CUSHORT|DATA|DATE|DECIMAL|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DEFAULT|DELEGATE|DIM|DIRECTCAST|DO|DOUBLE|ELSE|ELSEIF|END|ENUM|ENVIRON|ERASE|ERROR|EVENT|EXIT|FALSE|FIELD|FILES|FINALLY|FOR(?: EACH)?|FRIEND|FUNCTION|GET|GETTYPE|GETXMLNAMESPACE|GLOBAL|GOSUB|GOTO|HANDLES|IF|IMPLEMENTS|IMPORTS|IN|INHERITS|INPUT|INTEGER|INTERFACE|IOCTL|IS|ISNOT|KEY|KILL|LET|LIB|LIKE|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|ME|MKDIR|MOD|MODULE|MUSTINHERIT|MUSTOVERRIDE|MYBASE|MYCLASS|NAME|NAMESPACE|NARROWING|NEW|NEXT|NOT|NOTHING|NOTINHERITABLE|NOTOVERRIDABLE|OBJECT|OF|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPERATOR|OPTION(?: BASE)?|OPTIONAL|OR|ORELSE|OUT|OVERLOADS|OVERRIDABLE|OVERRIDES|PARAMARRAY|PARTIAL|POKE|PRIVATE|PROPERTY|PROTECTED|PUBLIC|PUT|RAISEEVENT|READ|READONLY|REDIM|REM|REMOVEHANDLER|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SBYTE|SELECT(?: CASE)?|SET|SHADOWS|SHARED|SHELL|SHORT|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|STRUCTURE|SUB|SWAP|SYNCLOCK|SYSTEM|THEN|THROW|TIMER|TO|TROFF|TRON|TRUE|TRY|TRYCAST|TYPE|TYPEOF|UINTEGER|ULONG|UNLOCK|UNTIL|USHORT|USING|VIEW PRINT|WAIT|WEND|WHEN|WHILE|WIDENING|WITH|WITHEVENTS|WRITE|WRITEONLY|XOR)|\B(?:#CONST|#ELSE|#ELSEIF|#END|#IF))(?:\$|\b)/i,
    "punctuation": /[,;:(){}]/
});



/***/ }),

/***/ 36034:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ e0)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21572);

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/sukhpreetsingh/apps/q1b-v2/node_modules/@keystatic/core/dist/ui-1b838e41.node.react-server.esm.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = proxy["IntegerFieldInput"];


/***/ }),

/***/ 63688:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   d: () => (/* binding */ e0)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21572);

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/sukhpreetsingh/apps/q1b-v2/node_modules/@keystatic/core/dist/ui-1f1aa184.node.react-server.esm.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = proxy["DocumentFieldInput"];


/***/ }),

/***/ 79097:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   W: () => (/* binding */ e0)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21572);

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/sukhpreetsingh/apps/q1b-v2/node_modules/@keystatic/core/dist/ui-23d3b9aa.node.react-server.esm.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = proxy["SelectFieldInput"];


/***/ }),

/***/ 90253:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Sd: () => (/* binding */ e0)
/* harmony export */ });
/* unused harmony exports getUploadedFile, getUploadedImage, useObjectURL */
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21572);

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/sukhpreetsingh/apps/q1b-v2/node_modules/@keystatic/core/dist/ui-32b334fd.node.react-server.esm.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = proxy["ImageFieldInput"];

const e1 = proxy["getUploadedFile"];

const e2 = proxy["getUploadedImage"];

const e3 = proxy["useObjectURL"];


/***/ }),

/***/ 78936:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   W: () => (/* binding */ e0)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21572);

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/sukhpreetsingh/apps/q1b-v2/node_modules/@keystatic/core/dist/ui-4365cc36.node.react-server.esm.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = proxy["MultiselectFieldInput"];


/***/ }),

/***/ 69753:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Y: () => (/* binding */ e0)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21572);

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/sukhpreetsingh/apps/q1b-v2/node_modules/@keystatic/core/dist/ui-4f76db75.node.react-server.esm.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = proxy["RelationshipInput"];


/***/ }),

/***/ 35887:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   n: () => (/* binding */ e0)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21572);

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/sukhpreetsingh/apps/q1b-v2/node_modules/@keystatic/core/dist/ui-58f594ec.node.react-server.esm.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = proxy["FileFieldInput"];


/***/ }),

/***/ 97313:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ e0)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21572);

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/sukhpreetsingh/apps/q1b-v2/node_modules/@keystatic/core/dist/ui-6ea72555.node.react-server.esm.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = proxy["BlocksFieldInput"];


/***/ }),

/***/ 27449:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Nl: () => (/* binding */ e5)
/* harmony export */ });
/* unused harmony exports AddToPathProvider, PathContext, PathContextProvider, SlugFieldContext, SlugFieldProvider */
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21572);

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/sukhpreetsingh/apps/q1b-v2/node_modules/@keystatic/core/dist/ui-78a3a4f0.node.react-server.esm.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = proxy["AddToPathProvider"];

const e1 = proxy["PathContext"];

const e2 = proxy["PathContextProvider"];

const e3 = proxy["SlugFieldContext"];

const e4 = proxy["SlugFieldProvider"];

const e5 = proxy["TextFieldInput"];


/***/ }),

/***/ 45192:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i: () => (/* binding */ e0)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21572);

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/sukhpreetsingh/apps/q1b-v2/node_modules/@keystatic/core/dist/ui-949db933.node.react-server.esm.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = proxy["UrlFieldInput"];


/***/ }),

/***/ 55788:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   o: () => (/* binding */ e0)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21572);

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/sukhpreetsingh/apps/q1b-v2/node_modules/@keystatic/core/dist/ui-b1673cee.node.react-server.esm.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = proxy["DateFieldInput"];


/***/ }),

/***/ 38566:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ e0)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21572);

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/sukhpreetsingh/apps/q1b-v2/node_modules/@keystatic/core/dist/ui-c44da0bc.node.react-server.esm.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = proxy["SlugFieldInput"];


/***/ }),

/***/ 30227:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   V: () => (/* binding */ e0)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21572);

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/sukhpreetsingh/apps/q1b-v2/node_modules/@keystatic/core/dist/ui-fa32ff3c.node.react-server.esm.js`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = proxy["PathReferenceInput"];


/***/ }),

/***/ 91001:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   E: () => (/* binding */ EditorAfterButIgnoringingPointsWithNoContent),
/* harmony export */   a: () => (/* binding */ getDocumentFeaturesForChildField),
/* harmony export */   b: () => (/* binding */ getAncestorSchemas),
/* harmony export */   c: () => (/* binding */ isInlineContainer),
/* harmony export */   e: () => (/* binding */ editorSchema),
/* harmony export */   g: () => (/* binding */ getAncestorComponentChildFieldDocumentFeatures),
/* harmony export */   i: () => (/* binding */ isBlock),
/* harmony export */   m: () => (/* binding */ moveChildren),
/* harmony export */   n: () => (/* binding */ nodeTypeMatcher)
/* harmony export */ });
/* unused harmony exports d, f, h, j */
/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7859);
/* harmony import */ var emery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45603);


const tableCellChildren = [
    "paragraph",
    "code",
    "heading",
    "ordered-list",
    "unordered-list",
    "divider",
    "image"
];
const blockquoteChildren = [
    ...tableCellChildren,
    "table"
];
const paragraphLike = [
    ...blockquoteChildren,
    "blockquote"
];
const insideOfLayouts = [
    ...paragraphLike,
    "component-block"
];
function blockContainer(args) {
    return {
        kind: "blocks",
        allowedChildren: new Set(args.allowedChildren),
        blockToWrapInlinesIn: args.allowedChildren[0],
        invalidPositionHandleMode: args.invalidPositionHandleMode
    };
}
function inlineContainer(args) {
    return {
        kind: "inlines",
        invalidPositionHandleMode: args.invalidPositionHandleMode
    };
}
// a user land version of https://github.com/microsoft/TypeScript/issues/47920
function satisfies() {
    return function(value) {
        return value;
    };
}
const editorSchema = satisfies()({
    editor: blockContainer({
        allowedChildren: [
            ...insideOfLayouts,
            "layout"
        ],
        invalidPositionHandleMode: "move"
    }),
    layout: blockContainer({
        allowedChildren: [
            "layout-area"
        ],
        invalidPositionHandleMode: "move"
    }),
    "layout-area": blockContainer({
        allowedChildren: insideOfLayouts,
        invalidPositionHandleMode: "unwrap"
    }),
    blockquote: blockContainer({
        allowedChildren: blockquoteChildren,
        invalidPositionHandleMode: "move"
    }),
    paragraph: inlineContainer({
        invalidPositionHandleMode: "unwrap"
    }),
    code: inlineContainer({
        invalidPositionHandleMode: "move"
    }),
    divider: inlineContainer({
        invalidPositionHandleMode: "move"
    }),
    heading: inlineContainer({
        invalidPositionHandleMode: "unwrap"
    }),
    "component-block": blockContainer({
        allowedChildren: [
            "component-block-prop",
            "component-inline-prop"
        ],
        invalidPositionHandleMode: "move"
    }),
    "component-inline-prop": inlineContainer({
        invalidPositionHandleMode: "unwrap"
    }),
    "component-block-prop": blockContainer({
        allowedChildren: [
            ...paragraphLike,
            "component-block"
        ],
        invalidPositionHandleMode: "unwrap"
    }),
    "ordered-list": blockContainer({
        allowedChildren: [
            "list-item"
        ],
        invalidPositionHandleMode: "move"
    }),
    "unordered-list": blockContainer({
        allowedChildren: [
            "list-item"
        ],
        invalidPositionHandleMode: "move"
    }),
    "list-item": blockContainer({
        allowedChildren: [
            "list-item-content",
            "ordered-list",
            "unordered-list"
        ],
        invalidPositionHandleMode: "unwrap"
    }),
    "list-item-content": inlineContainer({
        invalidPositionHandleMode: "unwrap"
    }),
    image: inlineContainer({
        invalidPositionHandleMode: "move"
    }),
    table: blockContainer({
        invalidPositionHandleMode: "move",
        allowedChildren: [
            "table-head",
            "table-body"
        ]
    }),
    "table-body": blockContainer({
        invalidPositionHandleMode: "move",
        allowedChildren: [
            "table-row"
        ]
    }),
    "table-row": blockContainer({
        invalidPositionHandleMode: "move",
        allowedChildren: [
            "table-cell"
        ]
    }),
    "table-cell": blockContainer({
        invalidPositionHandleMode: "move",
        allowedChildren: tableCellChildren
    }),
    "table-head": blockContainer({
        invalidPositionHandleMode: "move",
        allowedChildren: [
            "table-row"
        ]
    })
});
const inlineContainerTypes = new Set(Object.entries(editorSchema).filter((_ref)=>{
    let [, value] = _ref;
    return value.kind === "inlines";
}).map((_ref2)=>{
    let [type] = _ref2;
    return type;
}));
function isInlineContainer(node) {
    return node.type !== undefined && inlineContainerTypes.has(node.type);
}
const blockTypes = new Set(Object.keys(editorSchema).filter((x)=>x !== "editor"));
function isBlock(node) {
    return blockTypes.has(node.type);
}
// to print the editor schema in Graphviz if you want to visualize it
// function printEditorSchema(editorSchema: EditorSchema) {
//   return `digraph G {
//   concentrate=true;
//   ${Object.keys(editorSchema)
//     .map(key => {
//       let val = editorSchema[key];
//       if (val.kind === 'inlines') {
//         return `"${key}" -> inlines`;
//       }
//       if (val.kind === 'blocks') {
//         return `"${key}" -> {${[...val.allowedChildren].map(x => JSON.stringify(x)).join(' ')}}`;
//       }
//     })
//     .join('\n  ')}
// }`;
// }
function getDocumentFeaturesForChildField(editorDocumentFeatures, options) {
    var _options$formatting, _options$formatting3, _options$formatting4, _options$formatting5, _options$formatting6, _options$formatting7;
    // an important note for this: normalization based on document features
    // is done based on the document features returned here
    // and the editor document features
    // so the result for any given child prop will be the things that are
    // allowed by both these document features
    // AND the editor document features
    const inlineMarksFromOptions = (_options$formatting = options.formatting) === null || _options$formatting === void 0 ? void 0 : _options$formatting.inlineMarks;
    const inlineMarks = inlineMarksFromOptions === "inherit" ? "inherit" : Object.fromEntries(Object.keys(editorDocumentFeatures.formatting.inlineMarks).map((mark)=>{
        return [
            mark,
            !!(inlineMarksFromOptions || {})[mark]
        ];
    }));
    if (options.kind === "inline") {
        var _options$formatting2;
        return {
            kind: "inline",
            inlineMarks,
            documentFeatures: {
                links: options.links === "inherit"
            },
            softBreaks: ((_options$formatting2 = options.formatting) === null || _options$formatting2 === void 0 ? void 0 : _options$formatting2.softBreaks) === "inherit"
        };
    }
    const headingLevels = (_options$formatting3 = options.formatting) === null || _options$formatting3 === void 0 ? void 0 : _options$formatting3.headingLevels;
    return {
        kind: "block",
        inlineMarks,
        softBreaks: ((_options$formatting4 = options.formatting) === null || _options$formatting4 === void 0 ? void 0 : _options$formatting4.softBreaks) === "inherit",
        documentFeatures: {
            layouts: [],
            dividers: options.dividers === "inherit" ? editorDocumentFeatures.dividers : false,
            formatting: {
                alignment: ((_options$formatting5 = options.formatting) === null || _options$formatting5 === void 0 ? void 0 : _options$formatting5.alignment) === "inherit" ? editorDocumentFeatures.formatting.alignment : {
                    center: false,
                    end: false
                },
                blockTypes: ((_options$formatting6 = options.formatting) === null || _options$formatting6 === void 0 ? void 0 : _options$formatting6.blockTypes) === "inherit" ? editorDocumentFeatures.formatting.blockTypes : {
                    blockquote: false,
                    code: false
                },
                headings: headingLevels === "inherit" ? editorDocumentFeatures.formatting.headings : {
                    levels: headingLevels ? editorDocumentFeatures.formatting.headings.levels.filter((level)=>headingLevels.includes(level)) : [],
                    schema: editorDocumentFeatures.formatting.headings.schema
                },
                listTypes: ((_options$formatting7 = options.formatting) === null || _options$formatting7 === void 0 ? void 0 : _options$formatting7.listTypes) === "inherit" ? editorDocumentFeatures.formatting.listTypes : {
                    ordered: false,
                    unordered: false
                }
            },
            links: options.links === "inherit",
            images: options.images === "inherit" ? editorDocumentFeatures.images : false,
            tables: options.tables === "inherit"
        },
        componentBlocks: options.componentBlocks === "inherit"
    };
}
function getSchemaAtPropPathInner(path, value, schema) {
    // because we're checking the length here
    // the non-null asserts on shift below are fine
    if (path.length === 0) {
        return schema;
    }
    if (schema.kind === "child" || schema.kind === "form") {
        return;
    }
    if (schema.kind === "conditional") {
        const key = path.shift();
        if (key === "discriminant") {
            return getSchemaAtPropPathInner(path, value.discriminant, schema.discriminant);
        }
        if (key === "value") {
            const propVal = schema.values[value.discriminant];
            return getSchemaAtPropPathInner(path, value.value, propVal);
        }
        return;
    }
    if (schema.kind === "object") {
        const key = path.shift();
        return getSchemaAtPropPathInner(path, value[key], schema.fields[key]);
    }
    if (schema.kind === "array") {
        const index = path.shift();
        return getSchemaAtPropPathInner(path, value[index], schema.element);
    }
    (0,emery__WEBPACK_IMPORTED_MODULE_0__.assertNever)(schema);
}
function getSchemaAtPropPath(path, value, props) {
    return getSchemaAtPropPathInner([
        ...path
    ], value, {
        kind: "object",
        fields: props
    });
}
function getAncestorSchemas(rootSchema, path, value) {
    const ancestors = [];
    const currentPath = [
        ...path
    ];
    let currentProp = rootSchema;
    let currentValue = value;
    while(currentPath.length){
        ancestors.push(currentProp);
        const key = currentPath.shift(); // this code only runs when path.length is truthy so this non-null assertion is fine
        if (currentProp.kind === "array") {
            currentProp = currentProp.element;
            currentValue = currentValue[key];
        } else if (currentProp.kind === "conditional") {
            currentProp = currentProp.values[value.discriminant];
            currentValue = currentValue.value;
        } else if (currentProp.kind === "object") {
            currentValue = currentValue[key];
            currentProp = currentProp.fields[key];
        } else if (currentProp.kind === "child" || currentProp.kind === "form") {
            throw new Error(`unexpected prop "${key}"`);
        } else {
            (0,emery__WEBPACK_IMPORTED_MODULE_0__.assertNever)(currentProp);
        }
    }
    return ancestors;
}
function getPlaceholderTextForPropPath(propPath, fields, formProps) {
    const field = getSchemaAtPropPath(propPath, formProps, fields);
    if ((field === null || field === void 0 ? void 0 : field.kind) === "child") {
        return field.options.placeholder;
    }
    return "";
}
const allMarks = (/* unused pure expression or super */ null && ([
    "bold",
    "italic",
    "underline",
    "strikethrough",
    "code",
    "superscript",
    "subscript",
    "keyboard"
]));
const isElementActive = (editor, format)=>{
    const [match] = Editor.nodes(editor, {
        match: (n)=>n.type === format
    });
    return !!match;
};
function clearFormatting(editor) {
    Transforms.unwrapNodes(editor, {
        match: (node)=>node.type === "heading" || node.type === "blockquote" || node.type === "code"
    });
    Transforms.unsetNodes(editor, allMarks, {
        match: Text.isText
    });
}
function moveChildren(editor, parent, to) {
    let shouldMoveNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ()=>true;
    const parentPath = slate__WEBPACK_IMPORTED_MODULE_1__/* .Path */ .y$.isPath(parent) ? parent : parent[1];
    const parentNode = slate__WEBPACK_IMPORTED_MODULE_1__/* .Path */ .y$.isPath(parent) ? slate__WEBPACK_IMPORTED_MODULE_1__/* .Node */ .NB.get(editor, parentPath) : parent[0];
    if (!isBlock(parentNode)) return;
    for(let i = parentNode.children.length - 1; i >= 0; i--){
        if (shouldMoveNode(parentNode.children[i], i)) {
            const childPath = [
                ...parentPath,
                i
            ];
            slate__WEBPACK_IMPORTED_MODULE_1__/* .Transforms */ .YR.moveNodes(editor, {
                at: childPath,
                to
            });
        }
    }
}
/**
 * This is equivalent to Editor.after except that it ignores points that have no content
 * like the point in a void text node, an empty text node and the last point in a text node
 */ // TODO: this would probably break if you were trying to get the last point in the editor?
function EditorAfterButIgnoringingPointsWithNoContent(editor, at) {
    let { distance = 1 } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const anchor = slate__WEBPACK_IMPORTED_MODULE_1__/* .Editor */ .ML.point(editor, at, {
        edge: "end"
    });
    const focus = slate__WEBPACK_IMPORTED_MODULE_1__/* .Editor */ .ML.end(editor, []);
    const range = {
        anchor,
        focus
    };
    let d = 0;
    let target;
    for (const p of slate__WEBPACK_IMPORTED_MODULE_1__/* .Editor */ .ML.positions(editor, {
        at: range
    })){
        if (d > distance) {
            break;
        }
        // this is the important change
        const node = slate__WEBPACK_IMPORTED_MODULE_1__/* .Node */ .NB.get(editor, p.path);
        if (node.text.length === p.offset) {
            continue;
        }
        if (d !== 0) {
            target = p;
        }
        d++;
    }
    return target;
}
function nodeTypeMatcher() {
    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
        args[_key] = arguments[_key];
    }
    if (args.length === 1) {
        const type = args[0];
        return (node)=>node.type === type;
    }
    const set = new Set(args);
    return (node)=>typeof node.type === "string" && set.has(node.type);
}
function getAncestorComponentChildFieldDocumentFeatures(editor, editorDocumentFeatures, componentBlocks) {
    const ancestorComponentProp = slate__WEBPACK_IMPORTED_MODULE_1__/* .Editor */ .ML.above(editor, {
        match: nodeTypeMatcher("component-block-prop", "component-inline-prop")
    });
    if (ancestorComponentProp) {
        const propPath = ancestorComponentProp[0].propPath;
        const ancestorComponent = slate__WEBPACK_IMPORTED_MODULE_1__/* .Editor */ .ML.parent(editor, ancestorComponentProp[1]);
        if (ancestorComponent[0].type === "component-block") {
            const component = ancestorComponent[0].component;
            const componentBlock = componentBlocks[component];
            if (componentBlock && propPath) {
                const childField = getSchemaAtPropPath(propPath, ancestorComponent[0].props, componentBlock.schema);
                if ((childField === null || childField === void 0 ? void 0 : childField.kind) === "child") {
                    return getDocumentFeaturesForChildField(editorDocumentFeatures, childField.options);
                }
            }
        }
    }
}



/***/ }),

/***/ 32186:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ fixPath),
/* harmony export */   B: () => (/* binding */ collectDirectoriesUsedInSchema),
/* harmony export */   C: () => (/* binding */ sha1),
/* harmony export */   c: () => (/* binding */ getCollectionPath),
/* harmony export */   e: () => (/* binding */ getDirectoriesForTreeKey),
/* harmony export */   j: () => (/* binding */ getEntryDataFilepath),
/* harmony export */   m: () => (/* binding */ getSlugFromState),
/* harmony export */   n: () => (/* binding */ getCollectionFormat),
/* harmony export */   o: () => (/* binding */ object),
/* harmony export */   q: () => (/* binding */ getSlugGlobForCollection),
/* harmony export */   s: () => (/* binding */ getCollectionItemPath),
/* harmony export */   v: () => (/* binding */ getDataFileExtension),
/* harmony export */   x: () => (/* binding */ getSingletonFormat),
/* harmony export */   y: () => (/* binding */ getSingletonPath)
/* harmony export */ });
/* unused harmony exports K, a, b, d, f, g, h, i, k, l, p, r, t, u, w, z */
/* harmony import */ var emery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45603);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6113);
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);



function fixPath(path) {
    return path.replace(/^\.?\/+/, "").replace(/\/*$/, "");
}
const collectionPath = /\/\*\*?(?:$|\/)/;
function getConfiguredCollectionPath(config, collection) {
    var _collectionConfig$pat;
    const collectionConfig = config.collections[collection];
    const path = (_collectionConfig$pat = collectionConfig.path) !== null && _collectionConfig$pat !== void 0 ? _collectionConfig$pat : `${collection}/*/`;
    if (!collectionPath.test(path)) {
        throw new Error(`Collection path must end with /* or /** or include /*/ or /**/ but ${collection} has ${path}`);
    }
    return path;
}
function getCollectionPath(config, collection) {
    const configuredPath = getConfiguredCollectionPath(config, collection);
    const path = fixPath(configuredPath.replace(/\*\*?.*$/, ""));
    return path;
}
function getCollectionFormat(config, collection) {
    var _collectionConfig$for;
    const collectionConfig = config.collections[collection];
    return getFormatInfo((_collectionConfig$for = collectionConfig.format) !== null && _collectionConfig$for !== void 0 ? _collectionConfig$for : "yaml", collectionConfig.schema, getConfiguredCollectionPath(config, collection));
}
function getSingletonFormat(config, singleton) {
    var _singletonConfig$form, _singletonConfig$path;
    const singletonConfig = config.singletons[singleton];
    return getFormatInfo((_singletonConfig$form = singletonConfig.format) !== null && _singletonConfig$form !== void 0 ? _singletonConfig$form : "yaml", singletonConfig.schema, (_singletonConfig$path = singletonConfig.path) !== null && _singletonConfig$path !== void 0 ? _singletonConfig$path : `${singleton}/`);
}
function getCollectionItemPath(config, collection, slug) {
    const basePath = getCollectionPath(config, collection);
    const suffix = getCollectionItemSlugSuffix(config, collection);
    return `${basePath}/${slug}${suffix}`;
}
function getEntryDataFilepath(dir, formatInfo) {
    return `${dir}${formatInfo.dataLocation === "index" ? "/index" : ""}${getDataFileExtension(formatInfo)}`;
}
function getSlugGlobForCollection(config, collection) {
    const collectionPath = getConfiguredCollectionPath(config, collection);
    return collectionPath.includes("**") ? "**" : "*";
}
function getCollectionItemSlugSuffix(config, collection) {
    const configuredPath = getConfiguredCollectionPath(config, collection);
    const path = fixPath(configuredPath.replace(/^[^*]+\*\*?/, ""));
    return path ? `/${path}` : "";
}
function getSingletonPath(config, singleton) {
    var _singleton$path, _singleton$path2;
    if ((_singleton$path = config.singletons[singleton].path) !== null && _singleton$path !== void 0 && _singleton$path.includes("*")) {
        throw new Error(`Singleton paths cannot include * but ${singleton} has ${config.singletons[singleton].path}`);
    }
    return fixPath((_singleton$path2 = config.singletons[singleton].path) !== null && _singleton$path2 !== void 0 ? _singleton$path2 : singleton);
}
function getDataFileExtension(formatInfo) {
    return formatInfo.contentField ? formatInfo.contentField.config.contentExtension : "." + formatInfo.data;
}
function getFormatInfo(format, schema, path) {
    var _format$data;
    const dataLocation = path.endsWith("/") ? "index" : "outer";
    if (typeof format === "string") {
        return {
            dataLocation,
            contentField: undefined,
            data: format
        };
    }
    let contentField;
    if (format.contentField) {
        const field = schema[format.contentField];
        (0,emery__WEBPACK_IMPORTED_MODULE_0__.assert)((field === null || field === void 0 ? void 0 : field.kind) === "form", `${format.contentField} is not a form field`);
        (0,emery__WEBPACK_IMPORTED_MODULE_0__.assert)(field.formKind === "content", `${format.contentField} is not a content field`);
        contentField = {
            key: format.contentField,
            config: field
        };
    }
    return {
        data: (_format$data = format.data) !== null && _format$data !== void 0 ? _format$data : "yaml",
        contentField,
        dataLocation
    };
}
async function sha1(content) {
    return (0,crypto__WEBPACK_IMPORTED_MODULE_1__.createHash)("sha1").update(content).digest("hex");
}
const textEncoder$1 = new TextEncoder();
function blobSha(contents) {
    const blobPrefix = textEncoder$1.encode("blob " + contents.length + "\x00");
    const array = new Uint8Array(blobPrefix.byteLength + contents.byteLength);
    array.set(blobPrefix, 0);
    array.set(contents, blobPrefix.byteLength);
    return sha1(array);
}
function getTreeNodeAtPath(root, path) {
    const parts = path.split("/");
    let node = root.get(parts[0]);
    for (const part of parts.slice(1)){
        if (!node) return undefined;
        if (!node.children) return undefined;
        node = node.children.get(part);
    }
    return node;
}
function getNodeAtPath(tree, path) {
    let node = tree;
    for (const part of path.split("/")){
        if (!node.has(part)) {
            node.set(part, new Map());
        }
        const innerNode = node.get(part);
        assert(innerNode instanceof Map, "expected tree");
        node = innerNode;
    }
    return node;
}
function getFilename(path) {
    return path.replace(/.*\//, "");
}
function getDirname(path) {
    return path.replace(/\/[^/]+$/, "");
}
function toTreeChanges(changes) {
    const changesRoot = new Map();
    for (const deletion of changes.deletions){
        const parentTree = getNodeAtPath(changesRoot, getDirname(deletion));
        parentTree.set(getFilename(deletion), "delete");
    }
    for (const addition of changes.additions){
        const parentTree = getNodeAtPath(changesRoot, getDirname(addition.path));
        parentTree.set(getFilename(addition.path), addition.contents);
    }
    return changesRoot;
}
const SPACE_CHAR_CODE = 32;
const space = new Uint8Array([
    SPACE_CHAR_CODE
]);
const nullchar = new Uint8Array([
    0
]);
const tree = textEncoder$1.encode("tree ");
// based on https://github.com/isomorphic-git/isomorphic-git/blob/c09dfa20ffe0ab9e6602e0fa172d72ba8994e443/src/models/GitTree.js#L108-L122
function treeSha(children) {
    const entries = [
        ...children
    ].map((_ref)=>{
        let [name, node] = _ref;
        return {
            name,
            sha: node.entry.sha,
            mode: node.entry.mode
        };
    });
    entries.sort((a, b)=>{
        const aName = a.mode === "040000" ? a.name + "/" : a.name;
        const bName = b.mode === "040000" ? b.name + "/" : b.name;
        return aName === bName ? 0 : aName < bName ? -1 : 1;
    });
    const treeObject = entries.flatMap((entry)=>{
        const mode = textEncoder$1.encode(entry.mode.replace(/^0/, ""));
        const name = textEncoder$1.encode(entry.name);
        const sha = hexToBytes(entry.sha);
        return [
            mode,
            space,
            name,
            nullchar,
            sha
        ];
    });
    return sha1(concatBytes([
        tree,
        textEncoder$1.encode(treeObject.reduce((sum, val)=>sum + val.byteLength, 0).toString()),
        nullchar,
        ...treeObject
    ]));
}
function concatBytes(byteArrays) {
    const totalLength = byteArrays.reduce((sum, arr)=>sum + arr.byteLength, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const arr of byteArrays){
        result.set(arr, offset);
        offset += arr.byteLength;
    }
    return result;
}
function hexToBytes(str) {
    const bytes = new Uint8Array(str.length / 2);
    for(var i = 0; i < bytes.byteLength; i += 1){
        const start = i * 2;
        bytes[i] = parseInt(str.slice(start, start + 2), 16);
    }
    return bytes;
}
async function createTreeNodeEntry(path, children) {
    const sha = await treeSha(children);
    return {
        path,
        mode: "040000",
        type: "tree",
        sha
    };
}
async function createBlobNodeEntry(path, contents) {
    const sha = "sha" in contents ? contents.sha : await blobSha(contents);
    return {
        path,
        mode: "100644",
        type: "blob",
        sha,
        size: contents.byteLength
    };
}
async function updateTreeWithChanges(tree, changes) {
    var _await$updateTree;
    const newTree = (_await$updateTree = await updateTree(tree, toTreeChanges(changes), [])) !== null && _await$updateTree !== void 0 ? _await$updateTree : new Map();
    return {
        entries: treeToEntries(newTree),
        sha: await treeSha(newTree !== null && newTree !== void 0 ? newTree : new Map())
    };
}
function treeToEntries(tree) {
    return [
        ...tree.values()
    ].flatMap((x)=>x.children ? [
            x.entry,
            ...treeToEntries(x.children)
        ] : [
            x.entry
        ]);
}
async function updateTree(tree, changedTree, path) {
    const newTree = new Map(tree);
    for (const [key, value] of changedTree){
        if (value === "delete") {
            newTree.delete(key);
        }
        if (value instanceof Map) {
            var _newTree$get$children, _newTree$get;
            const existingChildren = (_newTree$get$children = (_newTree$get = newTree.get(key)) === null || _newTree$get === void 0 ? void 0 : _newTree$get.children) !== null && _newTree$get$children !== void 0 ? _newTree$get$children : new Map();
            const children = await updateTree(existingChildren, value, path.concat(key));
            if (children === undefined) {
                newTree.delete(key);
                continue;
            }
            const entry = await createTreeNodeEntry(path.concat(key).join("/"), children);
            newTree.set(key, {
                entry,
                children
            });
        }
        if (value instanceof Uint8Array || typeof value === "object" && "sha" in value) {
            const entry = await createBlobNodeEntry(path.concat(key).join("/"), value);
            newTree.set(key, {
                entry
            });
        }
    }
    if (newTree.size === 0) {
        return undefined;
    }
    return newTree;
}
function treeEntriesToTreeNodes(entries) {
    const root = new Map();
    const getChildrenAtPath = (parts)=>{
        var _node;
        if (parts.length === 0) {
            return root;
        }
        let node = root.get(parts[0]);
        for (const part of parts.slice(1)){
            if (!node) return undefined;
            if (!node.children) return undefined;
            node = node.children.get(part);
        }
        return (_node = node) === null || _node === void 0 ? void 0 : _node.children;
    };
    for (const entry of entries){
        const split = entry.path.split("/");
        const children = getChildrenAtPath(split.slice(0, -1));
        if (children) {
            children.set(split[split.length - 1], {
                entry,
                children: entry.type === "tree" ? new Map() : undefined
            });
        }
    }
    return root;
}
function collectDirectoriesUsedInSchemaInner(schema, directories, seenSchemas) {
    if (seenSchemas.has(schema)) {
        return;
    }
    seenSchemas.add(schema);
    if (schema.kind === "array") {
        return collectDirectoriesUsedInSchemaInner(schema.element, directories, seenSchemas);
    }
    if (schema.kind === "child") {
        return;
    }
    if (schema.kind === "form") {
        if (schema.formKind === "asset" && schema.directory !== undefined) {
            directories.add(fixPath(schema.directory));
        }
        if (schema.formKind === "content" && schema.directories !== undefined) {
            for (const directory of schema.directories){
                directories.add(fixPath(directory));
            }
        }
        return;
    }
    if (schema.kind === "object") {
        for (const field of Object.values(schema.fields)){
            collectDirectoriesUsedInSchemaInner(field, directories, seenSchemas);
        }
        return;
    }
    if (schema.kind === "conditional") {
        for (const innerSchema of Object.values(schema.values)){
            collectDirectoriesUsedInSchemaInner(innerSchema, directories, seenSchemas);
        }
        return;
    }
    (0,emery__WEBPACK_IMPORTED_MODULE_0__.assertNever)(schema);
}
function collectDirectoriesUsedInSchema(schema) {
    const directories = new Set();
    collectDirectoriesUsedInSchemaInner(schema, directories, new Set());
    return directories;
}
function getDirectoriesForTreeKey(schema, directory, slug, format) {
    const directories = [
        fixPath(directory)
    ];
    if (format.dataLocation === "outer") {
        directories.push(fixPath(directory) + getDataFileExtension(format));
    }
    const toAdd = slug === undefined ? "" : `/${slug}`;
    for (const directory of collectDirectoriesUsedInSchema(schema)){
        directories.push(directory + toAdd);
    }
    return directories;
}
function getTreeKey(directories, tree) {
    return directories.map((d)=>{
        var _getTreeNodeAtPath;
        return (_getTreeNodeAtPath = getTreeNodeAtPath(tree, d)) === null || _getTreeNodeAtPath === void 0 ? void 0 : _getTreeNodeAtPath.entry.sha;
    }).join("-");
}
var pkgJson = {
    name: "@keystatic/core",
    version: "0.0.111",
    license: "MIT",
    repository: {
        type: "git",
        url: "https://github.com/Thinkmill/keystatic/",
        directory: "packages/keystatic"
    },
    exports: {
        "./ui": {
            types: "./ui/dist/keystatic-core-ui.cjs.js",
            node: {
                "react-server": {
                    module: "./ui/dist/keystatic-core-ui.node.react-server.esm.js",
                    "default": "./ui/dist/keystatic-core-ui.node.react-server.cjs.js"
                },
                module: "./ui/dist/keystatic-core-ui.node.esm.js",
                "default": "./ui/dist/keystatic-core-ui.node.cjs.js"
            },
            "react-server": {
                module: "./ui/dist/keystatic-core-ui.react-server.esm.js",
                "default": "./ui/dist/keystatic-core-ui.react-server.cjs.js"
            },
            module: "./ui/dist/keystatic-core-ui.esm.js",
            "default": "./ui/dist/keystatic-core-ui.cjs.js"
        },
        ".": {
            types: "./dist/keystatic-core.cjs.js",
            node: {
                "react-server": {
                    module: "./dist/keystatic-core.node.react-server.esm.js",
                    "default": "./dist/keystatic-core.node.react-server.cjs.js"
                },
                module: "./dist/keystatic-core.node.esm.js",
                "default": "./dist/keystatic-core.node.cjs.js"
            },
            "react-server": {
                module: "./dist/keystatic-core.react-server.esm.js",
                "default": "./dist/keystatic-core.react-server.cjs.js"
            },
            module: "./dist/keystatic-core.esm.js",
            "default": "./dist/keystatic-core.cjs.js"
        },
        "./api/utils": {
            types: "./api/utils/dist/keystatic-core-api-utils.cjs.js",
            node: {
                "react-server": {
                    module: "./api/utils/dist/keystatic-core-api-utils.node.react-server.esm.js",
                    "default": "./api/utils/dist/keystatic-core-api-utils.node.react-server.cjs.js"
                },
                module: "./api/utils/dist/keystatic-core-api-utils.node.esm.js",
                "default": "./api/utils/dist/keystatic-core-api-utils.node.cjs.js"
            },
            "react-server": {
                module: "./api/utils/dist/keystatic-core-api-utils.react-server.esm.js",
                "default": "./api/utils/dist/keystatic-core-api-utils.react-server.cjs.js"
            },
            module: "./api/utils/dist/keystatic-core-api-utils.esm.js",
            "default": "./api/utils/dist/keystatic-core-api-utils.cjs.js"
        },
        "./renderer": {
            types: "./renderer/dist/keystatic-core-renderer.cjs.js",
            node: {
                "react-server": {
                    module: "./renderer/dist/keystatic-core-renderer.node.react-server.esm.js",
                    "default": "./renderer/dist/keystatic-core-renderer.node.react-server.cjs.js"
                },
                module: "./renderer/dist/keystatic-core-renderer.node.esm.js",
                "default": "./renderer/dist/keystatic-core-renderer.node.cjs.js"
            },
            "react-server": {
                module: "./renderer/dist/keystatic-core-renderer.react-server.esm.js",
                "default": "./renderer/dist/keystatic-core-renderer.react-server.cjs.js"
            },
            module: "./renderer/dist/keystatic-core-renderer.esm.js",
            "default": "./renderer/dist/keystatic-core-renderer.cjs.js"
        },
        "./api/generic": {
            types: "./api/generic/dist/keystatic-core-api-generic.cjs.js",
            node: {
                "react-server": {
                    module: "./api/generic/dist/keystatic-core-api-generic.node.react-server.esm.js",
                    "default": "./api/generic/dist/keystatic-core-api-generic.node.react-server.cjs.js"
                },
                module: "./api/generic/dist/keystatic-core-api-generic.node.esm.js",
                "default": "./api/generic/dist/keystatic-core-api-generic.node.cjs.js"
            },
            "react-server": {
                module: "./api/generic/dist/keystatic-core-api-generic.react-server.esm.js",
                "default": "./api/generic/dist/keystatic-core-api-generic.react-server.cjs.js"
            },
            module: "./api/generic/dist/keystatic-core-api-generic.esm.js",
            "default": "./api/generic/dist/keystatic-core-api-generic.cjs.js"
        },
        "./reader": {
            types: "./reader/dist/keystatic-core-reader.cjs.js",
            node: {
                "react-server": {
                    module: "./reader/dist/keystatic-core-reader.node.react-server.esm.js",
                    "default": "./reader/dist/keystatic-core-reader.node.react-server.cjs.js"
                },
                module: "./reader/dist/keystatic-core-reader.node.esm.js",
                "default": "./reader/dist/keystatic-core-reader.node.cjs.js"
            },
            "react-server": {
                module: "./reader/dist/keystatic-core-reader.react-server.esm.js",
                "default": "./reader/dist/keystatic-core-reader.react-server.cjs.js"
            },
            module: "./reader/dist/keystatic-core-reader.esm.js",
            "default": "./reader/dist/keystatic-core-reader.cjs.js"
        },
        "./form/fields/markdoc": {
            types: "./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.cjs.js",
            node: {
                "react-server": {
                    module: "./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.node.react-server.esm.js",
                    "default": "./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.node.react-server.cjs.js"
                },
                module: "./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.node.esm.js",
                "default": "./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.node.cjs.js"
            },
            "react-server": {
                module: "./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.react-server.esm.js",
                "default": "./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.react-server.cjs.js"
            },
            module: "./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.esm.js",
            "default": "./form/fields/markdoc/dist/keystatic-core-form-fields-markdoc.cjs.js"
        },
        "./package.json": "./package.json"
    },
    main: "dist/keystatic-core.cjs.js",
    module: "dist/keystatic-core.esm.js",
    files: [
        "dist",
        "api",
        "reader",
        "renderer",
        "ui",
        "form"
    ],
    scripts: {
        setup: "ts-gql build && tsx scripts/l10n.ts && tsx scripts/build-prism.ts",
        build: "pnpm run setup && next build",
        dev: "next dev",
        start: "next start"
    },
    dependencies: {
        "@babel/runtime": "^7.18.3",
        "@braintree/sanitize-url": "^6.0.2",
        "@emotion/css": "^11.9.0",
        "@emotion/weak-memoize": "^0.3.0",
        "@floating-ui/react": "^0.24.0",
        "@hapi/iron": "^7.0.0",
        "@internationalized/string": "^3.1.1",
        "@keystar/ui": "^0.1.4",
        "@markdoc/markdoc": "^0.3.0",
        "@react-aria/focus": "^3.13.0",
        "@react-aria/i18n": "^3.8.0",
        "@react-aria/interactions": "^3.16.0",
        "@react-aria/overlays": "^3.15.0",
        "@react-aria/selection": "^3.16.0",
        "@react-aria/utils": "^3.18.0",
        "@react-aria/visually-hidden": "^3.8.2",
        "@react-stately/collections": "^3.9.0",
        "@react-stately/list": "^3.9.0",
        "@react-stately/overlays": "^3.6.0",
        "@react-stately/utils": "^3.7.0",
        "@react-types/shared": "^3.18.0",
        "@sindresorhus/slugify": "^1.1.2",
        "@ts-gql/tag": "^0.7.0",
        "@types/node": "16.11.13",
        "@types/react": "^18.2.8",
        "@types/react-dom": "^18.0.11",
        "@urql/core": "^4.0.4",
        "@urql/exchange-auth": "^2.1.0",
        "@urql/exchange-graphcache": "^6.0.1",
        "@urql/exchange-persisted": "^3.0.0",
        "apply-ref": "^1.0.0",
        cookie: "^0.5.0",
        emery: "^1.4.1",
        "escape-string-regexp": "^4.0.0",
        "fast-deep-equal": "^3.1.3",
        graphql: "^16.6.0",
        ignore: "^5.2.4",
        "is-hotkey": "^0.2.0",
        "js-base64": "^3.7.5",
        "js-yaml": "^4.1.0",
        "lru-cache": "^7.14.1",
        "match-sorter": "^6.3.1",
        "mdast-util-from-markdown": "^0.8.5",
        "mdast-util-gfm-autolink-literal": "^0.1.3",
        "mdast-util-gfm-strikethrough": "^0.2.3",
        "micromark-extension-gfm-autolink-literal": "0.5.7",
        "micromark-extension-gfm-strikethrough": "0.6.5",
        mime: "^3.0.0",
        minimatch: "^7.1.0",
        "pretty-format": "^29.0.1",
        prismjs: "^1.29.0",
        "prosemirror-commands": "^1.5.1",
        "prosemirror-history": "^1.3.0",
        "prosemirror-keymap": "^1.2.1",
        "prosemirror-model": "^1.19.0",
        "prosemirror-state": "^1.4.2",
        "prosemirror-transform": "^1.7.1",
        "prosemirror-view": "^1.30.2",
        "react-resizable-panels": "^0.0.53",
        "scroll-into-view-if-needed": "^3.0.3",
        slate: "^0.91.4",
        "slate-history": "^0.86.0",
        "slate-hyperscript": "^0.77.0",
        "slate-react": "^0.91.9",
        urql: "^4.0.0",
        zod: "^3.20.2"
    },
    devDependencies: {
        "@testing-library/user-event": "^14.4.3",
        "@ts-gql/compiler": "^0.16.1",
        "@ts-gql/eslint-plugin": "^0.8.5",
        "@ts-gql/next": "^17.0.0",
        "@types/cookie": "^0.5.1",
        "@types/is-hotkey": "^0.1.7",
        "@types/js-yaml": "^4.0.5",
        "@types/prismjs": "^1.26.0",
        "@types/signal-exit": "^3.0.1",
        eslint: "^8.18.0",
        "fast-glob": "^3.2.12",
        "jest-diff": "^29.0.1",
        outdent: "^0.8.0",
        react: "^18.2.0",
        "react-dom": "^18.2.0",
        "react-element-to-jsx-string": "^15.0.0",
        "resize-observer-polyfill": "^1.5.1",
        "signal-exit": "^3.0.7",
        tsx: "^3.8.0",
        typescript: "^5.1.3"
    },
    peerDependencies: {
        react: "^18.2.0",
        "react-dom": "^18.2.0"
    },
    preconstruct: {
        entrypoints: [
            "index.ts",
            "api/generic.ts",
            "api/utils.ts",
            "reader/index.ts",
            "renderer.tsx",
            "ui.tsx",
            "form/fields/markdoc/index.tsx"
        ]
    },
    "ts-gql": {
        schema: "./github.graphql",
        mode: "no-transform",
        addTypename: false,
        scalars: {
            GitObjectID: "string"
        }
    },
    imports: {
        "#react-cache-in-react-server": {
            "react-server": "./src/reader/react-server-cache.ts",
            "default": "./src/reader/noop-cache.ts"
        },
        "#sha1": {
            node: "./src/sha1/node.ts",
            "default": "./src/sha1/webcrypto.ts"
        }
    }
};
function object(fields, opts) {
    return {
        ...opts,
        kind: "object",
        fields
    };
}
function pluralize(count, options) {
    const { singular, plural = singular + "s", inclusive = true } = options;
    const variant = count === 1 ? singular : plural;
    return inclusive ? `${count} ${variant}` : variant;
}
function keyedEntries(obj) {
    return Object.entries(obj).map((_ref)=>{
        let [key, value] = _ref;
        return {
            key,
            ...value
        };
    });
}
function isGitHubConfig(config) {
    return config.storage.kind === "github";
}
function isLocalConfig(config) {
    return config.storage.kind === "local";
}
function isCloudConfig(config) {
    return config.storage.kind === "cloud";
}
function getRepoPath(config) {
    return `${config.mainOwner}/${config.mainRepo}`;
}
function getRepoUrl(config) {
    return `https://github.com/${getRepoPath(config)}`;
}
function getSlugFromState(collectionConfig, state) {
    const value = state[collectionConfig.slugField];
    const field = collectionConfig.schema[collectionConfig.slugField];
    if (field.kind !== "form" || field.formKind !== "slug") {
        throw new Error(`slugField is not a slug field`);
    }
    return field.serializeWithSlug(value).slug;
}
function getEntriesInCollectionWithTreeKey(config, collection, rootTree) {
    var _getTreeNodeAtPath$ch, _getTreeNodeAtPath;
    const collectionConfig = config.collections[collection];
    const schema = object(collectionConfig.schema);
    const formatInfo = getCollectionFormat(config, collection);
    const extension = getDataFileExtension(formatInfo);
    const glob = getSlugGlobForCollection(config, collection);
    const collectionPath = getCollectionPath(config, collection);
    const directory = (_getTreeNodeAtPath$ch = (_getTreeNodeAtPath = getTreeNodeAtPath(rootTree, collectionPath)) === null || _getTreeNodeAtPath === void 0 ? void 0 : _getTreeNodeAtPath.children) !== null && _getTreeNodeAtPath$ch !== void 0 ? _getTreeNodeAtPath$ch : new Map();
    const entries = [];
    const directoriesUsedInSchema = [
        ...collectDirectoriesUsedInSchema(schema)
    ];
    const suffix = getCollectionItemSlugSuffix(config, collection);
    const possibleEntries = new Map(directory);
    if (glob === "**") {
        const handleDirectory = (dir, prefix)=>{
            for (const [key, entry] of dir){
                if (entry.children) {
                    possibleEntries.set(`${prefix}${key}`, entry);
                    handleDirectory(entry.children, `${prefix}${key}/`);
                } else {
                    possibleEntries.set(`${prefix}${key}`, entry);
                }
            }
        };
        handleDirectory(directory, "");
    }
    for (const [key, entry] of possibleEntries){
        if (formatInfo.dataLocation === "index") {
            var _actualEntry$children;
            const actualEntry = getTreeNodeAtPath(rootTree, getCollectionItemPath(config, collection, key));
            if (!(actualEntry !== null && actualEntry !== void 0 && (_actualEntry$children = actualEntry.children) !== null && _actualEntry$children !== void 0 && _actualEntry$children.has("index" + extension))) continue;
            entries.push({
                key: getTreeKey([
                    actualEntry.entry.path,
                    ...directoriesUsedInSchema.map((x)=>`${x}/${key}`)
                ], rootTree),
                slug: key
            });
        } else {
            if (suffix) {
                const newEntry = getTreeNodeAtPath(rootTree, getCollectionItemPath(config, collection, key) + extension);
                if (!newEntry || newEntry.children) continue;
                entries.push({
                    key: getTreeKey([
                        entry.entry.path,
                        getCollectionItemPath(config, collection, key),
                        ...directoriesUsedInSchema.map((x)=>`${x}/${key}`)
                    ], rootTree),
                    slug: key
                });
            }
            if (entry.children || !key.endsWith(extension)) continue;
            const slug = key.slice(0, -extension.length);
            entries.push({
                key: getTreeKey([
                    entry.entry.path,
                    getCollectionItemPath(config, collection, slug),
                    ...directoriesUsedInSchema.map((x)=>`${x}/${slug}`)
                ], rootTree),
                slug
            });
        }
    }
    return entries;
}
const KEYSTATIC_CLOUD_API_URL = "https://api.keystatic.cloud";
const KEYSTATIC_CLOUD_HEADERS = {
    "x-keystatic-version": pkgJson.version
};
const textEncoder = new TextEncoder();
async function redirectToCloudAuth(from, config) {
    if (config.storage.kind !== "cloud") {
        throw new Error("Not a cloud config");
    }
    const code_verifier = fromUint8Array(crypto.getRandomValues(new Uint8Array(32)), true);
    const code_challenge = fromUint8Array(new Uint8Array(await crypto.subtle.digest("SHA-256", textEncoder.encode(code_verifier))), true);
    const state = fromUint8Array(crypto.getRandomValues(new Uint8Array(32)), true);
    localStorage.setItem("keystatic-cloud-state", JSON.stringify({
        state,
        from,
        code_verifier
    }));
    const url = new URL(`${KEYSTATIC_CLOUD_API_URL}/oauth/authorize`);
    url.searchParams.set("state", state);
    url.searchParams.set("client_id", config.storage.project);
    url.searchParams.set("redirect_uri", `${window.location.origin}/keystatic/cloud/oauth/callback`);
    url.searchParams.set("response_type", "code");
    url.searchParams.set("code_challenge_method", "S256");
    url.searchParams.set("code_challenge", code_challenge);
    url.searchParams.set("keystatic_version", pkgJson.version);
    window.location.href = url.toString();
}



/***/ }),

/***/ 33794:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   a: () => (/* binding */ assertRequired),
/* harmony export */   b: () => (/* binding */ basicFormFieldWithSimpleReaderParse)
/* harmony export */ });
/* harmony import */ var _error_ca8f88e5_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(79646);

function assertRequired(value, validation, label) {
    if (value === null && validation !== null && validation !== void 0 && validation.isRequired) {
        throw new _error_ca8f88e5_node_react_server_esm_js__WEBPACK_IMPORTED_MODULE_0__.F(`${label} is required`);
    }
}
function basicFormFieldWithSimpleReaderParse(config) {
    return {
        kind: "form",
        Input: config.Input,
        defaultValue: config.defaultValue,
        parse: config.parse,
        serialize: config.serialize,
        validate: config.validate,
        reader: {
            parse (value) {
                return config.validate(config.parse(value));
            }
        }
    };
}



/***/ }),

/***/ 70212:
/***/ ((__unused_webpack_module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target)=>__defProp(target, "__esModule", {
        value: true
    });
var __commonJS = (cb, mod)=>function __require() {
        return mod || (0, cb[Object.keys(cb)[0]])((mod = {
            exports: {}
        }).exports, mod), mod.exports;
    };
var __export = (target, all)=>{
    __markAsModule(target);
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __reExport = (target, module2, desc)=>{
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
        for (let key of __getOwnPropNames(module2))if (!__hasOwnProp.call(target, key) && key !== "default") __defProp(target, key, {
            get: ()=>module2[key],
            enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
        });
    }
    return target;
};
var __toModule = (module2)=>{
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {
        get: ()=>module2.default,
        enumerable: true
    } : {
        value: module2,
        enumerable: true
    })), module2);
};
// src/grammar/tag.js
var require_tag = __commonJS({
    "src/grammar/tag.js" (exports1, module2) {
        "use strict";
        function peg$subclass(child, parent) {
            function C() {
                this.constructor = child;
            }
            C.prototype = parent.prototype;
            child.prototype = new C();
        }
        function peg$SyntaxError(message, expected, found, location) {
            this.message = message;
            this.expected = expected;
            this.found = found;
            this.location = location;
            this.name = "SyntaxError";
            if (typeof Error.captureStackTrace === "function") {
                Error.captureStackTrace(this, peg$SyntaxError);
            }
        }
        peg$subclass(peg$SyntaxError, Error);
        peg$SyntaxError.buildMessage = function(expected, found, location) {
            var DESCRIBE_EXPECTATION_FNS = {
                literal: function(expectation) {
                    return '"' + literalEscape(expectation.text) + '"';
                },
                class: function(expectation) {
                    var escapedParts = expectation.parts.map(function(part) {
                        return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
                    });
                    return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
                },
                any: function() {
                    return "any character";
                },
                end: function() {
                    return "end of input";
                },
                other: function(expectation) {
                    return expectation.description;
                },
                not: function(expectation) {
                    return "not " + describeExpectation(expectation.expected);
                }
            };
            function hex(ch) {
                return ch.charCodeAt(0).toString(16).toUpperCase();
            }
            function literalEscape(s2) {
                return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                    return "\\x0" + hex(ch);
                }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                    return "\\x" + hex(ch);
                });
            }
            function classEscape(s2) {
                return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                    return "\\x0" + hex(ch);
                }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                    return "\\x" + hex(ch);
                });
            }
            function describeExpectation(expectation) {
                return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
            }
            function describeExpected(expected2) {
                var descriptions = expected2.map(describeExpectation);
                var i, j;
                descriptions.sort();
                if (descriptions.length > 0) {
                    for(i = 1, j = 1; i < descriptions.length; i++){
                        if (descriptions[i - 1] !== descriptions[i]) {
                            descriptions[j] = descriptions[i];
                            j++;
                        }
                    }
                    descriptions.length = j;
                }
                switch(descriptions.length){
                    case 1:
                        return descriptions[0];
                    case 2:
                        return descriptions[0] + " or " + descriptions[1];
                    default:
                        return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
                }
            }
            function describeFound(found2) {
                return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
            }
            return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
        };
        function peg$parse(input, options) {
            options = options !== void 0 ? options : {};
            var peg$FAILED = {};
            var peg$startRuleFunctions = {
                Top: peg$parseTop
            };
            var peg$startRuleFunction = peg$parseTop;
            var peg$c0 = "/";
            var peg$c1 = ".";
            var peg$c2 = "#";
            var peg$c3 = "=";
            var peg$c4 = "(";
            var peg$c5 = ")";
            var peg$c6 = ",";
            var peg$c7 = "[";
            var peg$c8 = "]";
            var peg$c9 = "null";
            var peg$c10 = "true";
            var peg$c11 = "false";
            var peg$c12 = "{";
            var peg$c13 = "}";
            var peg$c14 = ":";
            var peg$c15 = "-";
            var peg$c16 = '"';
            var peg$c17 = "\\";
            var peg$r0 = /^[$@]/;
            var peg$r1 = /^[0-9]/;
            var peg$r2 = /^[^\0-\x1F"\\]/;
            var peg$r3 = /^[a-zA-Z0-9_\-]/;
            var peg$r4 = /^[ \n\t]/;
            var peg$e0 = peg$literalExpectation("/", false);
            var peg$e1 = peg$otherExpectation("tag name");
            var peg$e2 = peg$otherExpectation("class");
            var peg$e3 = peg$otherExpectation("id");
            var peg$e4 = peg$literalExpectation("=", false);
            var peg$e5 = peg$literalExpectation("(", false);
            var peg$e6 = peg$literalExpectation(")", false);
            var peg$e7 = peg$literalExpectation(",", false);
            var peg$e8 = peg$otherExpectation("variable");
            var peg$e9 = peg$otherExpectation("null");
            var peg$e10 = peg$otherExpectation("boolean");
            var peg$e11 = peg$literalExpectation("[", false);
            var peg$e12 = peg$literalExpectation("]", false);
            var peg$e13 = peg$literalExpectation("{", false);
            var peg$e14 = peg$literalExpectation("}", false);
            var peg$e15 = peg$literalExpectation(":", false);
            var peg$e16 = peg$otherExpectation("number");
            var peg$e17 = peg$otherExpectation("string");
            var peg$e18 = peg$otherExpectation("identifier");
            var peg$e19 = peg$otherExpectation("whitespace");
            var peg$f0 = function(variable) {
                return {
                    type: "variable",
                    meta: {
                        variable
                    }
                };
            };
            var peg$f1 = function(attributes) {
                return {
                    type: "annotation",
                    meta: {
                        attributes
                    }
                };
            };
            var peg$f2 = function(tag, value) {
                return value;
            };
            var peg$f3 = function(tag, primary, attributes, close) {
                if (primary) {
                    attributes = attributes || [];
                    attributes.unshift({
                        type: "attribute",
                        name: "primary",
                        value: primary
                    });
                }
                const [type, nesting] = close ? [
                    "tag",
                    0
                ] : [
                    "tag_open",
                    1
                ];
                return {
                    type,
                    nesting,
                    meta: {
                        tag,
                        attributes
                    }
                };
            };
            var peg$f4 = function(tag) {
                return {
                    type: "tag_close",
                    nesting: -1,
                    meta: {
                        tag
                    }
                };
            };
            var peg$f5 = function(head, tail) {
                return !head ? [] : [
                    head,
                    ...tail
                ];
            };
            var peg$f6 = function(item2) {
                return item2;
            };
            var peg$f7 = function(ids) {
                return ids;
            };
            var peg$f8 = function(classes) {
                return classes;
            };
            var peg$f9 = function(attribute) {
                return attribute;
            };
            var peg$f10 = function(name) {
                return {
                    type: "class",
                    name,
                    value: true
                };
            };
            var peg$f11 = function(value) {
                return {
                    type: "attribute",
                    name: "id",
                    value
                };
            };
            var peg$f12 = function(name, value) {
                return {
                    type: "attribute",
                    name,
                    value
                };
            };
            var peg$f13 = function(name, head, tail) {
                return head ? [
                    head,
                    ...tail
                ] : [];
            };
            var peg$f14 = function(name, params) {
                let parameters = {};
                for (let [index, { name: name2, value }] of params.entries())parameters[name2 || index] = value;
                return new Function3(name, parameters);
            };
            var peg$f15 = function(name) {
                return name;
            };
            var peg$f16 = function(name, value) {
                return {
                    name,
                    value
                };
            };
            var peg$f17 = function(value) {
                return value;
            };
            var peg$f18 = function(prefix, head, tail) {
                if (prefix === "@") return [
                    head,
                    ...tail
                ];
                return new Variable2([
                    head,
                    ...tail
                ]);
            };
            var peg$f19 = function() {
                return null;
            };
            var peg$f20 = function() {
                return true;
            };
            var peg$f21 = function() {
                return false;
            };
            var peg$f22 = function(head, tail) {
                return [
                    head,
                    ...tail
                ];
            };
            var peg$f23 = function(value) {
                return value || [];
            };
            var peg$f24 = function(head, tail) {
                return Object.assign(head, ...tail);
            };
            var peg$f25 = function(value) {
                return value || {};
            };
            var peg$f26 = function(key, value) {
                return key === "$$mdtype" ? {} : {
                    [key]: value
                };
            };
            var peg$f27 = function() {
                return parseFloat(text2());
            };
            var peg$f28 = function(value) {
                return value.join("");
            };
            var peg$f29 = function(sequence) {
                return sequence;
            };
            var peg$currPos = 0;
            var peg$savedPos = 0;
            var peg$posDetailsCache = [
                {
                    line: 1,
                    column: 1
                }
            ];
            var peg$expected = [];
            var peg$silentFails = 0;
            var peg$result;
            if ("startRule" in options) {
                if (!(options.startRule in peg$startRuleFunctions)) {
                    throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
                }
                peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
            }
            function text2() {
                return input.substring(peg$savedPos, peg$currPos);
            }
            function offset() {
                return peg$savedPos;
            }
            function range() {
                return [
                    peg$savedPos,
                    peg$currPos
                ];
            }
            function location() {
                return peg$computeLocation(peg$savedPos, peg$currPos);
            }
            function expected(description, location2) {
                location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
                throw peg$buildStructuredError([
                    peg$otherExpectation(description)
                ], input.substring(peg$savedPos, peg$currPos), location2);
            }
            function error2(message, location2) {
                location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
                throw peg$buildSimpleError(message, location2);
            }
            function peg$literalExpectation(text3, ignoreCase) {
                return {
                    type: "literal",
                    text: text3,
                    ignoreCase
                };
            }
            function peg$classExpectation(parts, inverted, ignoreCase) {
                return {
                    type: "class",
                    parts,
                    inverted,
                    ignoreCase
                };
            }
            function peg$anyExpectation() {
                return {
                    type: "any"
                };
            }
            function peg$endExpectation() {
                return {
                    type: "end"
                };
            }
            function peg$otherExpectation(description) {
                return {
                    type: "other",
                    description
                };
            }
            function peg$computePosDetails(pos) {
                var details = peg$posDetailsCache[pos];
                var p;
                if (details) {
                    return details;
                } else {
                    p = pos - 1;
                    while(!peg$posDetailsCache[p]){
                        p--;
                    }
                    details = peg$posDetailsCache[p];
                    details = {
                        line: details.line,
                        column: details.column
                    };
                    while(p < pos){
                        if (input.charCodeAt(p) === 10) {
                            details.line++;
                            details.column = 1;
                        } else {
                            details.column++;
                        }
                        p++;
                    }
                    peg$posDetailsCache[pos] = details;
                    return details;
                }
            }
            var peg$VALIDFILENAME = typeof options.filename === "string" && options.filename.length > 0;
            function peg$computeLocation(startPos, endPos) {
                var loc = {};
                if (peg$VALIDFILENAME) loc.filename = options.filename;
                var startPosDetails = peg$computePosDetails(startPos);
                loc.start = {
                    offset: startPos,
                    line: startPosDetails.line,
                    column: startPosDetails.column
                };
                var endPosDetails = peg$computePosDetails(endPos);
                loc.end = {
                    offset: endPos,
                    line: endPosDetails.line,
                    column: endPosDetails.column
                };
                return loc;
            }
            function peg$begin() {
                peg$expected.push({
                    pos: peg$currPos,
                    variants: []
                });
            }
            function peg$expect(expected2) {
                var top = peg$expected[peg$expected.length - 1];
                if (peg$currPos < top.pos) {
                    return;
                }
                if (peg$currPos > top.pos) {
                    top.pos = peg$currPos;
                    top.variants = [];
                }
                top.variants.push(expected2);
            }
            function peg$end(invert) {
                var expected2 = peg$expected.pop();
                var top = peg$expected[peg$expected.length - 1];
                var variants = expected2.variants;
                if (top.pos !== expected2.pos) {
                    return;
                }
                if (invert) {
                    variants = variants.map(function(e) {
                        return e.type === "not" ? e.expected : {
                            type: "not",
                            expected: e
                        };
                    });
                }
                Array.prototype.push.apply(top.variants, variants);
            }
            function peg$buildSimpleError(message, location2) {
                return new peg$SyntaxError(message, null, null, location2);
            }
            function peg$buildStructuredError(expected2, found, location2) {
                return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected2, found, location2), expected2, found, location2);
            }
            function peg$buildError() {
                var expected2 = peg$expected[0];
                var failPos = expected2.pos;
                return peg$buildStructuredError(expected2.variants, failPos < input.length ? input.charAt(failPos) : null, failPos < input.length ? peg$computeLocation(failPos, failPos + 1) : peg$computeLocation(failPos, failPos));
            }
            function peg$parseTop() {
                var s0;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                s0 = peg$parseTopLevelValue();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseAnnotation();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseTagOpen();
                        if (s0 === peg$FAILED) {
                            s0 = peg$parseTagClose();
                        }
                    }
                }
                return s0;
            }
            function peg$parseTopLevelValue() {
                var s0, s1;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                s0 = peg$currPos;
                s1 = peg$parseVariable();
                if (s1 === peg$FAILED) {
                    s1 = peg$parseFunction();
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$f0(s1);
                }
                s0 = s1;
                return s0;
            }
            function peg$parseAnnotation() {
                var s0, s1, s2, s3;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                s0 = peg$currPos;
                s1 = peg$parseTagAttributes();
                if (s1 !== peg$FAILED) {
                    s2 = [];
                    s3 = peg$parse_();
                    while(s3 !== peg$FAILED){
                        s2.push(s3);
                        s3 = peg$parse_();
                    }
                    peg$savedPos = s0;
                    s0 = peg$f1(s1);
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                return s0;
            }
            function peg$parseTagOpen() {
                var s0, s1, s2, s3, s4, s5, s6;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                s0 = peg$currPos;
                s1 = peg$parseTagName();
                if (s1 !== peg$FAILED) {
                    s2 = [];
                    s3 = peg$parse_();
                    while(s3 !== peg$FAILED){
                        s2.push(s3);
                        s3 = peg$parse_();
                    }
                    s3 = peg$currPos;
                    s4 = peg$parseValue();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parse_();
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        peg$savedPos = s3;
                        s3 = peg$f2(s1, s4);
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                    if (s3 === peg$FAILED) {
                        s3 = null;
                    }
                    s4 = peg$parseTagAttributes();
                    if (s4 === peg$FAILED) {
                        s4 = null;
                    }
                    s5 = [];
                    s6 = peg$parse_();
                    while(s6 !== peg$FAILED){
                        s5.push(s6);
                        s6 = peg$parse_();
                    }
                    rule$expects(peg$e0);
                    if (input.charCodeAt(peg$currPos) === 47) {
                        s6 = peg$c0;
                        peg$currPos++;
                    } else {
                        s6 = peg$FAILED;
                    }
                    if (s6 === peg$FAILED) {
                        s6 = null;
                    }
                    peg$savedPos = s0;
                    s0 = peg$f3(s1, s3, s4, s6);
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                return s0;
            }
            function peg$parseTagClose() {
                var s0, s1, s2;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                s0 = peg$currPos;
                rule$expects(peg$e0);
                if (input.charCodeAt(peg$currPos) === 47) {
                    s1 = peg$c0;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parseTagName();
                    if (s2 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f4(s2);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                return s0;
            }
            function peg$parseTagName() {
                var s0;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                rule$expects(peg$e1);
                peg$silentFails++;
                s0 = peg$parseIdentifier();
                peg$silentFails--;
                return s0;
            }
            function peg$parseTagAttributes() {
                var s0, s1, s2, s3;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                s0 = peg$currPos;
                s1 = peg$parseTagAttributesItem();
                if (s1 !== peg$FAILED) {
                    s2 = [];
                    s3 = peg$parseTagAttributesTail();
                    while(s3 !== peg$FAILED){
                        s2.push(s3);
                        s3 = peg$parseTagAttributesTail();
                    }
                    peg$savedPos = s0;
                    s0 = peg$f5(s1, s2);
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                return s0;
            }
            function peg$parseTagAttributesTail() {
                var s0, s1, s2;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                s0 = peg$currPos;
                s1 = [];
                s2 = peg$parse_();
                if (s2 !== peg$FAILED) {
                    while(s2 !== peg$FAILED){
                        s1.push(s2);
                        s2 = peg$parse_();
                    }
                } else {
                    s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parseTagAttributesItem();
                    if (s2 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f6(s2);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                return s0;
            }
            function peg$parseTagAttributesItem() {
                var s0, s1;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                s0 = peg$currPos;
                s1 = peg$parseTagShortcutId();
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$f7(s1);
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parseTagShortcutClass();
                    if (s1 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$f8(s1);
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = peg$parseTagAttribute();
                        if (s1 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$f9(s1);
                        }
                        s0 = s1;
                    }
                }
                return s0;
            }
            function peg$parseTagShortcutClass() {
                var s0, s1, s2;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                rule$expects(peg$e2);
                peg$silentFails++;
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 46) {
                    s1 = peg$c1;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parseIdentifier();
                    if (s2 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f10(s2);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                peg$silentFails--;
                return s0;
            }
            function peg$parseTagShortcutId() {
                var s0, s1, s2;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                rule$expects(peg$e3);
                peg$silentFails++;
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 35) {
                    s1 = peg$c2;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parseIdentifier();
                    if (s2 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f11(s2);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                peg$silentFails--;
                return s0;
            }
            function peg$parseTagAttribute() {
                var s0, s1, s2, s3;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                s0 = peg$currPos;
                s1 = peg$parseIdentifier();
                if (s1 !== peg$FAILED) {
                    rule$expects(peg$e4);
                    if (input.charCodeAt(peg$currPos) === 61) {
                        s2 = peg$c3;
                        peg$currPos++;
                    } else {
                        s2 = peg$FAILED;
                    }
                    if (s2 !== peg$FAILED) {
                        s3 = peg$parseValue();
                        if (s3 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f12(s1, s3);
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                return s0;
            }
            function peg$parseFunction() {
                var s0, s1, s2, s3, s4, s5, s6, s7;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                s0 = peg$currPos;
                s1 = peg$parseIdentifier();
                if (s1 !== peg$FAILED) {
                    rule$expects(peg$e5);
                    if (input.charCodeAt(peg$currPos) === 40) {
                        s2 = peg$c4;
                        peg$currPos++;
                    } else {
                        s2 = peg$FAILED;
                    }
                    if (s2 !== peg$FAILED) {
                        s3 = [];
                        s4 = peg$parse_();
                        while(s4 !== peg$FAILED){
                            s3.push(s4);
                            s4 = peg$parse_();
                        }
                        s4 = peg$currPos;
                        s5 = peg$parseFunctionParameter();
                        if (s5 === peg$FAILED) {
                            s5 = null;
                        }
                        s6 = [];
                        s7 = peg$parseFunctionParameterTail();
                        while(s7 !== peg$FAILED){
                            s6.push(s7);
                            s7 = peg$parseFunctionParameterTail();
                        }
                        peg$savedPos = s4;
                        s4 = peg$f13(s1, s5, s6);
                        rule$expects(peg$e6);
                        if (input.charCodeAt(peg$currPos) === 41) {
                            s5 = peg$c5;
                            peg$currPos++;
                        } else {
                            s5 = peg$FAILED;
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f14(s1, s4);
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                return s0;
            }
            function peg$parseFunctionParameter() {
                var s0, s1, s2, s3;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                s0 = peg$currPos;
                s1 = peg$currPos;
                s2 = peg$parseIdentifier();
                if (s2 !== peg$FAILED) {
                    rule$expects(peg$e4);
                    if (input.charCodeAt(peg$currPos) === 61) {
                        s3 = peg$c3;
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                    }
                    if (s3 !== peg$FAILED) {
                        peg$savedPos = s1;
                        s1 = peg$f15(s2);
                    } else {
                        peg$currPos = s1;
                        s1 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                }
                if (s1 === peg$FAILED) {
                    s1 = null;
                }
                s2 = peg$parseValue();
                if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f16(s1, s2);
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                return s0;
            }
            function peg$parseFunctionParameterTail() {
                var s0, s1, s2, s3, s4;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                s0 = peg$currPos;
                s1 = [];
                s2 = peg$parse_();
                while(s2 !== peg$FAILED){
                    s1.push(s2);
                    s2 = peg$parse_();
                }
                rule$expects(peg$e7);
                if (input.charCodeAt(peg$currPos) === 44) {
                    s2 = peg$c6;
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                    s3 = [];
                    s4 = peg$parse_();
                    while(s4 !== peg$FAILED){
                        s3.push(s4);
                        s4 = peg$parse_();
                    }
                    s4 = peg$parseFunctionParameter();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f17(s4);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                return s0;
            }
            function peg$parseTrailingComma() {
                var s0, s1, s2;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                s0 = peg$currPos;
                s1 = [];
                s2 = peg$parse_();
                while(s2 !== peg$FAILED){
                    s1.push(s2);
                    s2 = peg$parse_();
                }
                rule$expects(peg$e7);
                if (input.charCodeAt(peg$currPos) === 44) {
                    s2 = peg$c6;
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                    s1 = [
                        s1,
                        s2
                    ];
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                    s0 = null;
                }
                return s0;
            }
            function peg$parseVariable() {
                var s0, s1, s2, s3, s4;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                rule$expects(peg$e8);
                peg$silentFails++;
                s0 = peg$currPos;
                if (peg$r0.test(input.charAt(peg$currPos))) {
                    s1 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parseIdentifier();
                    if (s2 !== peg$FAILED) {
                        s3 = [];
                        s4 = peg$parseVariableTail();
                        while(s4 !== peg$FAILED){
                            s3.push(s4);
                            s4 = peg$parseVariableTail();
                        }
                        peg$savedPos = s0;
                        s0 = peg$f18(s1, s2, s3);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                peg$silentFails--;
                return s0;
            }
            function peg$parseVariableTail() {
                var s0, s1, s2, s3;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 46) {
                    s1 = peg$c1;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                    s2 = peg$parseIdentifier();
                    if (s2 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f15(s2);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 91) {
                        s1 = peg$c7;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                    }
                    if (s1 !== peg$FAILED) {
                        s2 = peg$parseValueNumber();
                        if (s2 === peg$FAILED) {
                            s2 = peg$parseValueString();
                        }
                        if (s2 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 93) {
                                s3 = peg$c8;
                                peg$currPos++;
                            } else {
                                s3 = peg$FAILED;
                            }
                            if (s3 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s0 = peg$f17(s2);
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
                return s0;
            }
            function peg$parseValue() {
                var s0;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                s0 = peg$parseValueNull();
                if (s0 === peg$FAILED) {
                    s0 = peg$parseValueBoolean();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseValueString();
                        if (s0 === peg$FAILED) {
                            s0 = peg$parseValueNumber();
                            if (s0 === peg$FAILED) {
                                s0 = peg$parseValueArray();
                                if (s0 === peg$FAILED) {
                                    s0 = peg$parseValueHash();
                                    if (s0 === peg$FAILED) {
                                        s0 = peg$parseFunction();
                                        if (s0 === peg$FAILED) {
                                            s0 = peg$parseVariable();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return s0;
            }
            function peg$parseValueNull() {
                var s0, s1;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                rule$expects(peg$e9);
                peg$silentFails++;
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 4) === peg$c9) {
                    s1 = peg$c9;
                    peg$currPos += 4;
                } else {
                    s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$f19();
                }
                s0 = s1;
                peg$silentFails--;
                return s0;
            }
            function peg$parseValueBoolean() {
                var s0, s1;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                rule$expects(peg$e10);
                peg$silentFails++;
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 4) === peg$c10) {
                    s1 = peg$c10;
                    peg$currPos += 4;
                } else {
                    s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$f20();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 5) === peg$c11) {
                        s1 = peg$c11;
                        peg$currPos += 5;
                    } else {
                        s1 = peg$FAILED;
                    }
                    if (s1 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$f21();
                    }
                    s0 = s1;
                }
                peg$silentFails--;
                return s0;
            }
            function peg$parseValueArray() {
                var s0, s1, s2, s3, s4, s5, s6;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                s0 = peg$currPos;
                rule$expects(peg$e11);
                if (input.charCodeAt(peg$currPos) === 91) {
                    s1 = peg$c7;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                    s2 = [];
                    s3 = peg$parse_();
                    while(s3 !== peg$FAILED){
                        s2.push(s3);
                        s3 = peg$parse_();
                    }
                    s3 = peg$currPos;
                    s4 = peg$parseValue();
                    if (s4 !== peg$FAILED) {
                        s5 = [];
                        s6 = peg$parseValueArrayTail();
                        while(s6 !== peg$FAILED){
                            s5.push(s6);
                            s6 = peg$parseValueArrayTail();
                        }
                        s6 = peg$parseTrailingComma();
                        peg$savedPos = s3;
                        s3 = peg$f22(s4, s5);
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                    if (s3 === peg$FAILED) {
                        s3 = null;
                    }
                    s4 = [];
                    s5 = peg$parse_();
                    while(s5 !== peg$FAILED){
                        s4.push(s5);
                        s5 = peg$parse_();
                    }
                    rule$expects(peg$e12);
                    if (input.charCodeAt(peg$currPos) === 93) {
                        s5 = peg$c8;
                        peg$currPos++;
                    } else {
                        s5 = peg$FAILED;
                    }
                    if (s5 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f23(s3);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                return s0;
            }
            function peg$parseValueArrayTail() {
                var s0, s1, s2, s3, s4;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                s0 = peg$currPos;
                s1 = [];
                s2 = peg$parse_();
                while(s2 !== peg$FAILED){
                    s1.push(s2);
                    s2 = peg$parse_();
                }
                rule$expects(peg$e7);
                if (input.charCodeAt(peg$currPos) === 44) {
                    s2 = peg$c6;
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                    s3 = [];
                    s4 = peg$parse_();
                    while(s4 !== peg$FAILED){
                        s3.push(s4);
                        s4 = peg$parse_();
                    }
                    s4 = peg$parseValue();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f17(s4);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                return s0;
            }
            function peg$parseValueHash() {
                var s0, s1, s2, s3, s4, s5, s6;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                s0 = peg$currPos;
                rule$expects(peg$e13);
                if (input.charCodeAt(peg$currPos) === 123) {
                    s1 = peg$c12;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                    s2 = [];
                    s3 = peg$parse_();
                    while(s3 !== peg$FAILED){
                        s2.push(s3);
                        s3 = peg$parse_();
                    }
                    s3 = peg$currPos;
                    s4 = peg$parseValueHashItem();
                    if (s4 !== peg$FAILED) {
                        s5 = [];
                        s6 = peg$parseValueHashTail();
                        while(s6 !== peg$FAILED){
                            s5.push(s6);
                            s6 = peg$parseValueHashTail();
                        }
                        s6 = peg$parseTrailingComma();
                        peg$savedPos = s3;
                        s3 = peg$f24(s4, s5);
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                    if (s3 === peg$FAILED) {
                        s3 = null;
                    }
                    s4 = [];
                    s5 = peg$parse_();
                    while(s5 !== peg$FAILED){
                        s4.push(s5);
                        s5 = peg$parse_();
                    }
                    rule$expects(peg$e14);
                    if (input.charCodeAt(peg$currPos) === 125) {
                        s5 = peg$c13;
                        peg$currPos++;
                    } else {
                        s5 = peg$FAILED;
                    }
                    if (s5 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f25(s3);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                return s0;
            }
            function peg$parseValueHashTail() {
                var s0, s1, s2, s3, s4;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                s0 = peg$currPos;
                s1 = [];
                s2 = peg$parse_();
                while(s2 !== peg$FAILED){
                    s1.push(s2);
                    s2 = peg$parse_();
                }
                rule$expects(peg$e7);
                if (input.charCodeAt(peg$currPos) === 44) {
                    s2 = peg$c6;
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                    s3 = [];
                    s4 = peg$parse_();
                    while(s4 !== peg$FAILED){
                        s3.push(s4);
                        s4 = peg$parse_();
                    }
                    s4 = peg$parseValueHashItem();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f6(s4);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                return s0;
            }
            function peg$parseValueHashItem() {
                var s0, s1, s2, s3, s4;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                s0 = peg$currPos;
                s1 = peg$parseIdentifier();
                if (s1 === peg$FAILED) {
                    s1 = peg$parseValueString();
                }
                if (s1 !== peg$FAILED) {
                    rule$expects(peg$e15);
                    if (input.charCodeAt(peg$currPos) === 58) {
                        s2 = peg$c14;
                        peg$currPos++;
                    } else {
                        s2 = peg$FAILED;
                    }
                    if (s2 !== peg$FAILED) {
                        s3 = [];
                        s4 = peg$parse_();
                        while(s4 !== peg$FAILED){
                            s3.push(s4);
                            s4 = peg$parse_();
                        }
                        s4 = peg$parseValue();
                        if (s4 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s0 = peg$f26(s1, s4);
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                return s0;
            }
            function peg$parseValueNumber() {
                var s0, s1, s2, s3, s4, s5, s6;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                rule$expects(peg$e16);
                peg$silentFails++;
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 45) {
                    s1 = peg$c15;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                }
                if (s1 === peg$FAILED) {
                    s1 = null;
                }
                s2 = [];
                if (peg$r1.test(input.charAt(peg$currPos))) {
                    s3 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                }
                if (s3 !== peg$FAILED) {
                    while(s3 !== peg$FAILED){
                        s2.push(s3);
                        if (peg$r1.test(input.charAt(peg$currPos))) {
                            s3 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                        }
                    }
                } else {
                    s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                    s3 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 46) {
                        s4 = peg$c1;
                        peg$currPos++;
                    } else {
                        s4 = peg$FAILED;
                    }
                    if (s4 !== peg$FAILED) {
                        s5 = [];
                        if (peg$r1.test(input.charAt(peg$currPos))) {
                            s6 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s6 = peg$FAILED;
                        }
                        if (s6 !== peg$FAILED) {
                            while(s6 !== peg$FAILED){
                                s5.push(s6);
                                if (peg$r1.test(input.charAt(peg$currPos))) {
                                    s6 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s6 = peg$FAILED;
                                }
                            }
                        } else {
                            s5 = peg$FAILED;
                        }
                        if (s5 !== peg$FAILED) {
                            s4 = [
                                s4,
                                s5
                            ];
                            s3 = s4;
                        } else {
                            peg$currPos = s3;
                            s3 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                    }
                    if (s3 === peg$FAILED) {
                        s3 = null;
                    }
                    peg$savedPos = s0;
                    s0 = peg$f27();
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                peg$silentFails--;
                return s0;
            }
            function peg$parseValueString() {
                var s0, s1, s2, s3;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                rule$expects(peg$e17);
                peg$silentFails++;
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 34) {
                    s1 = peg$c16;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                    s2 = [];
                    s3 = peg$parseValueStringChars();
                    while(s3 !== peg$FAILED){
                        s2.push(s3);
                        s3 = peg$parseValueStringChars();
                    }
                    if (input.charCodeAt(peg$currPos) === 34) {
                        s3 = peg$c16;
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                    }
                    if (s3 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f28(s2);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                peg$silentFails--;
                return s0;
            }
            function peg$parseValueStringChars() {
                var s0;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                if (peg$r2.test(input.charAt(peg$currPos))) {
                    s0 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$parseValueStringEscapes();
                }
                return s0;
            }
            function peg$parseValueStringEscapes() {
                var s0, s1, s2;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 92) {
                    s1 = peg$c17;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 34) {
                        s2 = peg$c16;
                        peg$currPos++;
                    } else {
                        s2 = peg$FAILED;
                    }
                    if (s2 === peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 92) {
                            s2 = peg$c17;
                            peg$currPos++;
                        } else {
                            s2 = peg$FAILED;
                        }
                    }
                    if (s2 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f29(s2);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                return s0;
            }
            function peg$parseIdentifier() {
                var s0, s1, s2;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                rule$expects(peg$e18);
                peg$silentFails++;
                s0 = peg$currPos;
                s1 = [];
                if (peg$r3.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                    while(s2 !== peg$FAILED){
                        s1.push(s2);
                        if (peg$r3.test(input.charAt(peg$currPos))) {
                            s2 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s2 = peg$FAILED;
                        }
                    }
                } else {
                    s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                    s0 = input.substring(s0, peg$currPos);
                } else {
                    s0 = s1;
                }
                peg$silentFails--;
                return s0;
            }
            function peg$parse_() {
                var s0;
                var rule$expects = function(expected2) {
                    if (peg$silentFails === 0) peg$expect(expected2);
                };
                rule$expects(peg$e19);
                peg$silentFails++;
                if (peg$r4.test(input.charAt(peg$currPos))) {
                    s0 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s0 = peg$FAILED;
                }
                peg$silentFails--;
                return s0;
            }
            const { Variable: Variable2, Function: Function3 } = options;
            peg$begin();
            peg$result = peg$startRuleFunction();
            if (peg$result !== peg$FAILED && peg$currPos === input.length) {
                return peg$result;
            } else {
                if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                    peg$expect(peg$endExpectation());
                }
                throw peg$buildError();
            }
        }
        module2.exports = {
            SyntaxError: peg$SyntaxError,
            parse: peg$parse
        };
    }
});
// node_modules/entities/lib/maps/entities.json
var require_entities = __commonJS({
    "node_modules/entities/lib/maps/entities.json" (exports1, module2) {
        module2.exports = {
            Aacute: "\xc1",
            aacute: "\xe1",
            Abreve: "",
            abreve: "",
            ac: "",
            acd: "",
            acE: "",
            Acirc: "\xc2",
            acirc: "\xe2",
            acute: "\xb4",
            Acy: "",
            acy: "",
            AElig: "\xc6",
            aelig: "\xe6",
            af: "",
            Afr: "\uD835\uDD04",
            afr: "\uD835\uDD1E",
            Agrave: "\xc0",
            agrave: "\xe0",
            alefsym: "",
            aleph: "",
            Alpha: "",
            alpha: "",
            Amacr: "",
            amacr: "",
            amalg: "",
            amp: "&",
            AMP: "&",
            andand: "",
            And: "",
            and: "",
            andd: "",
            andslope: "",
            andv: "",
            ang: "",
            ange: "",
            angle: "",
            angmsdaa: "",
            angmsdab: "",
            angmsdac: "",
            angmsdad: "",
            angmsdae: "",
            angmsdaf: "",
            angmsdag: "",
            angmsdah: "",
            angmsd: "",
            angrt: "",
            angrtvb: "",
            angrtvbd: "",
            angsph: "",
            angst: "\xc5",
            angzarr: "",
            Aogon: "",
            aogon: "",
            Aopf: "\uD835\uDD38",
            aopf: "\uD835\uDD52",
            apacir: "",
            ap: "",
            apE: "",
            ape: "",
            apid: "",
            apos: "'",
            ApplyFunction: "",
            approx: "",
            approxeq: "",
            Aring: "\xc5",
            aring: "\xe5",
            Ascr: "\uD835\uDC9C",
            ascr: "\uD835\uDCB6",
            Assign: "",
            ast: "*",
            asymp: "",
            asympeq: "",
            Atilde: "\xc3",
            atilde: "\xe3",
            Auml: "\xc4",
            auml: "\xe4",
            awconint: "",
            awint: "",
            backcong: "",
            backepsilon: "",
            backprime: "",
            backsim: "",
            backsimeq: "",
            Backslash: "",
            Barv: "",
            barvee: "",
            barwed: "",
            Barwed: "",
            barwedge: "",
            bbrk: "",
            bbrktbrk: "",
            bcong: "",
            Bcy: "",
            bcy: "",
            bdquo: "",
            becaus: "",
            because: "",
            Because: "",
            bemptyv: "",
            bepsi: "",
            bernou: "",
            Bernoullis: "",
            Beta: "",
            beta: "",
            beth: "",
            between: "",
            Bfr: "\uD835\uDD05",
            bfr: "\uD835\uDD1F",
            bigcap: "",
            bigcirc: "",
            bigcup: "",
            bigodot: "",
            bigoplus: "",
            bigotimes: "",
            bigsqcup: "",
            bigstar: "",
            bigtriangledown: "",
            bigtriangleup: "",
            biguplus: "",
            bigvee: "",
            bigwedge: "",
            bkarow: "",
            blacklozenge: "",
            blacksquare: "",
            blacktriangle: "",
            blacktriangledown: "",
            blacktriangleleft: "",
            blacktriangleright: "",
            blank: "",
            blk12: "",
            blk14: "",
            blk34: "",
            block: "",
            bne: "=",
            bnequiv: "",
            bNot: "",
            bnot: "",
            Bopf: "\uD835\uDD39",
            bopf: "\uD835\uDD53",
            bot: "",
            bottom: "",
            bowtie: "",
            boxbox: "",
            boxdl: "",
            boxdL: "",
            boxDl: "",
            boxDL: "",
            boxdr: "",
            boxdR: "",
            boxDr: "",
            boxDR: "",
            boxh: "",
            boxH: "",
            boxhd: "",
            boxHd: "",
            boxhD: "",
            boxHD: "",
            boxhu: "",
            boxHu: "",
            boxhU: "",
            boxHU: "",
            boxminus: "",
            boxplus: "",
            boxtimes: "",
            boxul: "",
            boxuL: "",
            boxUl: "",
            boxUL: "",
            boxur: "",
            boxuR: "",
            boxUr: "",
            boxUR: "",
            boxv: "",
            boxV: "",
            boxvh: "",
            boxvH: "",
            boxVh: "",
            boxVH: "",
            boxvl: "",
            boxvL: "",
            boxVl: "",
            boxVL: "",
            boxvr: "",
            boxvR: "",
            boxVr: "",
            boxVR: "",
            bprime: "",
            breve: "",
            Breve: "",
            brvbar: "\xa6",
            bscr: "\uD835\uDCB7",
            Bscr: "",
            bsemi: "",
            bsim: "",
            bsime: "",
            bsolb: "",
            bsol: "\\",
            bsolhsub: "",
            bull: "",
            bullet: "",
            bump: "",
            bumpE: "",
            bumpe: "",
            Bumpeq: "",
            bumpeq: "",
            Cacute: "",
            cacute: "",
            capand: "",
            capbrcup: "",
            capcap: "",
            cap: "",
            Cap: "",
            capcup: "",
            capdot: "",
            CapitalDifferentialD: "",
            caps: "",
            caret: "",
            caron: "",
            Cayleys: "",
            ccaps: "",
            Ccaron: "",
            ccaron: "",
            Ccedil: "\xc7",
            ccedil: "\xe7",
            Ccirc: "",
            ccirc: "",
            Cconint: "",
            ccups: "",
            ccupssm: "",
            Cdot: "",
            cdot: "",
            cedil: "\xb8",
            Cedilla: "\xb8",
            cemptyv: "",
            cent: "\xa2",
            centerdot: "\xb7",
            CenterDot: "\xb7",
            cfr: "\uD835\uDD20",
            Cfr: "",
            CHcy: "",
            chcy: "",
            check: "",
            checkmark: "",
            Chi: "",
            chi: "",
            circ: "",
            circeq: "",
            circlearrowleft: "",
            circlearrowright: "",
            circledast: "",
            circledcirc: "",
            circleddash: "",
            CircleDot: "",
            circledR: "\xae",
            circledS: "",
            CircleMinus: "",
            CirclePlus: "",
            CircleTimes: "",
            cir: "",
            cirE: "",
            cire: "",
            cirfnint: "",
            cirmid: "",
            cirscir: "",
            ClockwiseContourIntegral: "",
            CloseCurlyDoubleQuote: "",
            CloseCurlyQuote: "",
            clubs: "",
            clubsuit: "",
            colon: ":",
            Colon: "",
            Colone: "",
            colone: "",
            coloneq: "",
            comma: ",",
            commat: "@",
            comp: "",
            compfn: "",
            complement: "",
            complexes: "",
            cong: "",
            congdot: "",
            Congruent: "",
            conint: "",
            Conint: "",
            ContourIntegral: "",
            copf: "\uD835\uDD54",
            Copf: "",
            coprod: "",
            Coproduct: "",
            copy: "\xa9",
            COPY: "\xa9",
            copysr: "",
            CounterClockwiseContourIntegral: "",
            crarr: "",
            cross: "",
            Cross: "",
            Cscr: "\uD835\uDC9E",
            cscr: "\uD835\uDCB8",
            csub: "",
            csube: "",
            csup: "",
            csupe: "",
            ctdot: "",
            cudarrl: "",
            cudarrr: "",
            cuepr: "",
            cuesc: "",
            cularr: "",
            cularrp: "",
            cupbrcap: "",
            cupcap: "",
            CupCap: "",
            cup: "",
            Cup: "",
            cupcup: "",
            cupdot: "",
            cupor: "",
            cups: "",
            curarr: "",
            curarrm: "",
            curlyeqprec: "",
            curlyeqsucc: "",
            curlyvee: "",
            curlywedge: "",
            curren: "\xa4",
            curvearrowleft: "",
            curvearrowright: "",
            cuvee: "",
            cuwed: "",
            cwconint: "",
            cwint: "",
            cylcty: "",
            dagger: "",
            Dagger: "",
            daleth: "",
            darr: "",
            Darr: "",
            dArr: "",
            dash: "",
            Dashv: "",
            dashv: "",
            dbkarow: "",
            dblac: "",
            Dcaron: "",
            dcaron: "",
            Dcy: "",
            dcy: "",
            ddagger: "",
            ddarr: "",
            DD: "",
            dd: "",
            DDotrahd: "",
            ddotseq: "",
            deg: "\xb0",
            Del: "",
            Delta: "",
            delta: "",
            demptyv: "",
            dfisht: "",
            Dfr: "\uD835\uDD07",
            dfr: "\uD835\uDD21",
            dHar: "",
            dharl: "",
            dharr: "",
            DiacriticalAcute: "\xb4",
            DiacriticalDot: "",
            DiacriticalDoubleAcute: "",
            DiacriticalGrave: "`",
            DiacriticalTilde: "",
            diam: "",
            diamond: "",
            Diamond: "",
            diamondsuit: "",
            diams: "",
            die: "\xa8",
            DifferentialD: "",
            digamma: "",
            disin: "",
            div: "\xf7",
            divide: "\xf7",
            divideontimes: "",
            divonx: "",
            DJcy: "",
            djcy: "",
            dlcorn: "",
            dlcrop: "",
            dollar: "$",
            Dopf: "\uD835\uDD3B",
            dopf: "\uD835\uDD55",
            Dot: "\xa8",
            dot: "",
            DotDot: "",
            doteq: "",
            doteqdot: "",
            DotEqual: "",
            dotminus: "",
            dotplus: "",
            dotsquare: "",
            doublebarwedge: "",
            DoubleContourIntegral: "",
            DoubleDot: "\xa8",
            DoubleDownArrow: "",
            DoubleLeftArrow: "",
            DoubleLeftRightArrow: "",
            DoubleLeftTee: "",
            DoubleLongLeftArrow: "",
            DoubleLongLeftRightArrow: "",
            DoubleLongRightArrow: "",
            DoubleRightArrow: "",
            DoubleRightTee: "",
            DoubleUpArrow: "",
            DoubleUpDownArrow: "",
            DoubleVerticalBar: "",
            DownArrowBar: "",
            downarrow: "",
            DownArrow: "",
            Downarrow: "",
            DownArrowUpArrow: "",
            DownBreve: "",
            downdownarrows: "",
            downharpoonleft: "",
            downharpoonright: "",
            DownLeftRightVector: "",
            DownLeftTeeVector: "",
            DownLeftVectorBar: "",
            DownLeftVector: "",
            DownRightTeeVector: "",
            DownRightVectorBar: "",
            DownRightVector: "",
            DownTeeArrow: "",
            DownTee: "",
            drbkarow: "",
            drcorn: "",
            drcrop: "",
            Dscr: "\uD835\uDC9F",
            dscr: "\uD835\uDCB9",
            DScy: "",
            dscy: "",
            dsol: "",
            Dstrok: "",
            dstrok: "",
            dtdot: "",
            dtri: "",
            dtrif: "",
            duarr: "",
            duhar: "",
            dwangle: "",
            DZcy: "",
            dzcy: "",
            dzigrarr: "",
            Eacute: "\xc9",
            eacute: "\xe9",
            easter: "",
            Ecaron: "",
            ecaron: "",
            Ecirc: "\xca",
            ecirc: "\xea",
            ecir: "",
            ecolon: "",
            Ecy: "",
            ecy: "",
            eDDot: "",
            Edot: "",
            edot: "",
            eDot: "",
            ee: "",
            efDot: "",
            Efr: "\uD835\uDD08",
            efr: "\uD835\uDD22",
            eg: "",
            Egrave: "\xc8",
            egrave: "\xe8",
            egs: "",
            egsdot: "",
            el: "",
            Element: "",
            elinters: "",
            ell: "",
            els: "",
            elsdot: "",
            Emacr: "",
            emacr: "",
            empty: "",
            emptyset: "",
            EmptySmallSquare: "",
            emptyv: "",
            EmptyVerySmallSquare: "",
            emsp13: "",
            emsp14: "",
            emsp: "",
            ENG: "",
            eng: "",
            ensp: "",
            Eogon: "",
            eogon: "",
            Eopf: "\uD835\uDD3C",
            eopf: "\uD835\uDD56",
            epar: "",
            eparsl: "",
            eplus: "",
            epsi: "",
            Epsilon: "",
            epsilon: "",
            epsiv: "",
            eqcirc: "",
            eqcolon: "",
            eqsim: "",
            eqslantgtr: "",
            eqslantless: "",
            Equal: "",
            equals: "=",
            EqualTilde: "",
            equest: "",
            Equilibrium: "",
            equiv: "",
            equivDD: "",
            eqvparsl: "",
            erarr: "",
            erDot: "",
            escr: "",
            Escr: "",
            esdot: "",
            Esim: "",
            esim: "",
            Eta: "",
            eta: "",
            ETH: "\xd0",
            eth: "\xf0",
            Euml: "\xcb",
            euml: "\xeb",
            euro: "",
            excl: "!",
            exist: "",
            Exists: "",
            expectation: "",
            exponentiale: "",
            ExponentialE: "",
            fallingdotseq: "",
            Fcy: "",
            fcy: "",
            female: "",
            ffilig: "",
            fflig: "",
            ffllig: "",
            Ffr: "\uD835\uDD09",
            ffr: "\uD835\uDD23",
            filig: "",
            FilledSmallSquare: "",
            FilledVerySmallSquare: "",
            fjlig: "fj",
            flat: "",
            fllig: "",
            fltns: "",
            fnof: "",
            Fopf: "\uD835\uDD3D",
            fopf: "\uD835\uDD57",
            forall: "",
            ForAll: "",
            fork: "",
            forkv: "",
            Fouriertrf: "",
            fpartint: "",
            frac12: "\xbd",
            frac13: "",
            frac14: "\xbc",
            frac15: "",
            frac16: "",
            frac18: "",
            frac23: "",
            frac25: "",
            frac34: "\xbe",
            frac35: "",
            frac38: "",
            frac45: "",
            frac56: "",
            frac58: "",
            frac78: "",
            frasl: "",
            frown: "",
            fscr: "\uD835\uDCBB",
            Fscr: "",
            gacute: "",
            Gamma: "",
            gamma: "",
            Gammad: "",
            gammad: "",
            gap: "",
            Gbreve: "",
            gbreve: "",
            Gcedil: "",
            Gcirc: "",
            gcirc: "",
            Gcy: "",
            gcy: "",
            Gdot: "",
            gdot: "",
            ge: "",
            gE: "",
            gEl: "",
            gel: "",
            geq: "",
            geqq: "",
            geqslant: "",
            gescc: "",
            ges: "",
            gesdot: "",
            gesdoto: "",
            gesdotol: "",
            gesl: "",
            gesles: "",
            Gfr: "\uD835\uDD0A",
            gfr: "\uD835\uDD24",
            gg: "",
            Gg: "",
            ggg: "",
            gimel: "",
            GJcy: "",
            gjcy: "",
            gla: "",
            gl: "",
            glE: "",
            glj: "",
            gnap: "",
            gnapprox: "",
            gne: "",
            gnE: "",
            gneq: "",
            gneqq: "",
            gnsim: "",
            Gopf: "\uD835\uDD3E",
            gopf: "\uD835\uDD58",
            grave: "`",
            GreaterEqual: "",
            GreaterEqualLess: "",
            GreaterFullEqual: "",
            GreaterGreater: "",
            GreaterLess: "",
            GreaterSlantEqual: "",
            GreaterTilde: "",
            Gscr: "\uD835\uDCA2",
            gscr: "",
            gsim: "",
            gsime: "",
            gsiml: "",
            gtcc: "",
            gtcir: "",
            gt: ">",
            GT: ">",
            Gt: "",
            gtdot: "",
            gtlPar: "",
            gtquest: "",
            gtrapprox: "",
            gtrarr: "",
            gtrdot: "",
            gtreqless: "",
            gtreqqless: "",
            gtrless: "",
            gtrsim: "",
            gvertneqq: "",
            gvnE: "",
            Hacek: "",
            hairsp: "",
            half: "\xbd",
            hamilt: "",
            HARDcy: "",
            hardcy: "",
            harrcir: "",
            harr: "",
            hArr: "",
            harrw: "",
            Hat: "^",
            hbar: "",
            Hcirc: "",
            hcirc: "",
            hearts: "",
            heartsuit: "",
            hellip: "",
            hercon: "",
            hfr: "\uD835\uDD25",
            Hfr: "",
            HilbertSpace: "",
            hksearow: "",
            hkswarow: "",
            hoarr: "",
            homtht: "",
            hookleftarrow: "",
            hookrightarrow: "",
            hopf: "\uD835\uDD59",
            Hopf: "",
            horbar: "",
            HorizontalLine: "",
            hscr: "\uD835\uDCBD",
            Hscr: "",
            hslash: "",
            Hstrok: "",
            hstrok: "",
            HumpDownHump: "",
            HumpEqual: "",
            hybull: "",
            hyphen: "",
            Iacute: "\xcd",
            iacute: "\xed",
            ic: "",
            Icirc: "\xce",
            icirc: "\xee",
            Icy: "",
            icy: "",
            Idot: "",
            IEcy: "",
            iecy: "",
            iexcl: "\xa1",
            iff: "",
            ifr: "\uD835\uDD26",
            Ifr: "",
            Igrave: "\xcc",
            igrave: "\xec",
            ii: "",
            iiiint: "",
            iiint: "",
            iinfin: "",
            iiota: "",
            IJlig: "",
            ijlig: "",
            Imacr: "",
            imacr: "",
            image: "",
            ImaginaryI: "",
            imagline: "",
            imagpart: "",
            imath: "",
            Im: "",
            imof: "",
            imped: "",
            Implies: "",
            incare: "",
            in: "",
            infin: "",
            infintie: "",
            inodot: "",
            intcal: "",
            int: "",
            Int: "",
            integers: "",
            Integral: "",
            intercal: "",
            Intersection: "",
            intlarhk: "",
            intprod: "",
            InvisibleComma: "",
            InvisibleTimes: "",
            IOcy: "",
            iocy: "",
            Iogon: "",
            iogon: "",
            Iopf: "\uD835\uDD40",
            iopf: "\uD835\uDD5A",
            Iota: "",
            iota: "",
            iprod: "",
            iquest: "\xbf",
            iscr: "\uD835\uDCBE",
            Iscr: "",
            isin: "",
            isindot: "",
            isinE: "",
            isins: "",
            isinsv: "",
            isinv: "",
            it: "",
            Itilde: "",
            itilde: "",
            Iukcy: "",
            iukcy: "",
            Iuml: "\xcf",
            iuml: "\xef",
            Jcirc: "",
            jcirc: "",
            Jcy: "",
            jcy: "",
            Jfr: "\uD835\uDD0D",
            jfr: "\uD835\uDD27",
            jmath: "",
            Jopf: "\uD835\uDD41",
            jopf: "\uD835\uDD5B",
            Jscr: "\uD835\uDCA5",
            jscr: "\uD835\uDCBF",
            Jsercy: "",
            jsercy: "",
            Jukcy: "",
            jukcy: "",
            Kappa: "",
            kappa: "",
            kappav: "",
            Kcedil: "",
            kcedil: "",
            Kcy: "",
            kcy: "",
            Kfr: "\uD835\uDD0E",
            kfr: "\uD835\uDD28",
            kgreen: "",
            KHcy: "",
            khcy: "",
            KJcy: "",
            kjcy: "",
            Kopf: "\uD835\uDD42",
            kopf: "\uD835\uDD5C",
            Kscr: "\uD835\uDCA6",
            kscr: "\uD835\uDCC0",
            lAarr: "",
            Lacute: "",
            lacute: "",
            laemptyv: "",
            lagran: "",
            Lambda: "",
            lambda: "",
            lang: "",
            Lang: "",
            langd: "",
            langle: "",
            lap: "",
            Laplacetrf: "",
            laquo: "\xab",
            larrb: "",
            larrbfs: "",
            larr: "",
            Larr: "",
            lArr: "",
            larrfs: "",
            larrhk: "",
            larrlp: "",
            larrpl: "",
            larrsim: "",
            larrtl: "",
            latail: "",
            lAtail: "",
            lat: "",
            late: "",
            lates: "",
            lbarr: "",
            lBarr: "",
            lbbrk: "",
            lbrace: "{",
            lbrack: "[",
            lbrke: "",
            lbrksld: "",
            lbrkslu: "",
            Lcaron: "",
            lcaron: "",
            Lcedil: "",
            lcedil: "",
            lceil: "",
            lcub: "{",
            Lcy: "",
            lcy: "",
            ldca: "",
            ldquo: "",
            ldquor: "",
            ldrdhar: "",
            ldrushar: "",
            ldsh: "",
            le: "",
            lE: "",
            LeftAngleBracket: "",
            LeftArrowBar: "",
            leftarrow: "",
            LeftArrow: "",
            Leftarrow: "",
            LeftArrowRightArrow: "",
            leftarrowtail: "",
            LeftCeiling: "",
            LeftDoubleBracket: "",
            LeftDownTeeVector: "",
            LeftDownVectorBar: "",
            LeftDownVector: "",
            LeftFloor: "",
            leftharpoondown: "",
            leftharpoonup: "",
            leftleftarrows: "",
            leftrightarrow: "",
            LeftRightArrow: "",
            Leftrightarrow: "",
            leftrightarrows: "",
            leftrightharpoons: "",
            leftrightsquigarrow: "",
            LeftRightVector: "",
            LeftTeeArrow: "",
            LeftTee: "",
            LeftTeeVector: "",
            leftthreetimes: "",
            LeftTriangleBar: "",
            LeftTriangle: "",
            LeftTriangleEqual: "",
            LeftUpDownVector: "",
            LeftUpTeeVector: "",
            LeftUpVectorBar: "",
            LeftUpVector: "",
            LeftVectorBar: "",
            LeftVector: "",
            lEg: "",
            leg: "",
            leq: "",
            leqq: "",
            leqslant: "",
            lescc: "",
            les: "",
            lesdot: "",
            lesdoto: "",
            lesdotor: "",
            lesg: "",
            lesges: "",
            lessapprox: "",
            lessdot: "",
            lesseqgtr: "",
            lesseqqgtr: "",
            LessEqualGreater: "",
            LessFullEqual: "",
            LessGreater: "",
            lessgtr: "",
            LessLess: "",
            lesssim: "",
            LessSlantEqual: "",
            LessTilde: "",
            lfisht: "",
            lfloor: "",
            Lfr: "\uD835\uDD0F",
            lfr: "\uD835\uDD29",
            lg: "",
            lgE: "",
            lHar: "",
            lhard: "",
            lharu: "",
            lharul: "",
            lhblk: "",
            LJcy: "",
            ljcy: "",
            llarr: "",
            ll: "",
            Ll: "",
            llcorner: "",
            Lleftarrow: "",
            llhard: "",
            lltri: "",
            Lmidot: "",
            lmidot: "",
            lmoustache: "",
            lmoust: "",
            lnap: "",
            lnapprox: "",
            lne: "",
            lnE: "",
            lneq: "",
            lneqq: "",
            lnsim: "",
            loang: "",
            loarr: "",
            lobrk: "",
            longleftarrow: "",
            LongLeftArrow: "",
            Longleftarrow: "",
            longleftrightarrow: "",
            LongLeftRightArrow: "",
            Longleftrightarrow: "",
            longmapsto: "",
            longrightarrow: "",
            LongRightArrow: "",
            Longrightarrow: "",
            looparrowleft: "",
            looparrowright: "",
            lopar: "",
            Lopf: "\uD835\uDD43",
            lopf: "\uD835\uDD5D",
            loplus: "",
            lotimes: "",
            lowast: "",
            lowbar: "_",
            LowerLeftArrow: "",
            LowerRightArrow: "",
            loz: "",
            lozenge: "",
            lozf: "",
            lpar: "(",
            lparlt: "",
            lrarr: "",
            lrcorner: "",
            lrhar: "",
            lrhard: "",
            lrm: "",
            lrtri: "",
            lsaquo: "",
            lscr: "\uD835\uDCC1",
            Lscr: "",
            lsh: "",
            Lsh: "",
            lsim: "",
            lsime: "",
            lsimg: "",
            lsqb: "[",
            lsquo: "",
            lsquor: "",
            Lstrok: "",
            lstrok: "",
            ltcc: "",
            ltcir: "",
            lt: "<",
            LT: "<",
            Lt: "",
            ltdot: "",
            lthree: "",
            ltimes: "",
            ltlarr: "",
            ltquest: "",
            ltri: "",
            ltrie: "",
            ltrif: "",
            ltrPar: "",
            lurdshar: "",
            luruhar: "",
            lvertneqq: "",
            lvnE: "",
            macr: "\xaf",
            male: "",
            malt: "",
            maltese: "",
            Map: "",
            map: "",
            mapsto: "",
            mapstodown: "",
            mapstoleft: "",
            mapstoup: "",
            marker: "",
            mcomma: "",
            Mcy: "",
            mcy: "",
            mdash: "",
            mDDot: "",
            measuredangle: "",
            MediumSpace: "",
            Mellintrf: "",
            Mfr: "\uD835\uDD10",
            mfr: "\uD835\uDD2A",
            mho: "",
            micro: "\xb5",
            midast: "*",
            midcir: "",
            mid: "",
            middot: "\xb7",
            minusb: "",
            minus: "",
            minusd: "",
            minusdu: "",
            MinusPlus: "",
            mlcp: "",
            mldr: "",
            mnplus: "",
            models: "",
            Mopf: "\uD835\uDD44",
            mopf: "\uD835\uDD5E",
            mp: "",
            mscr: "\uD835\uDCC2",
            Mscr: "",
            mstpos: "",
            Mu: "",
            mu: "",
            multimap: "",
            mumap: "",
            nabla: "",
            Nacute: "",
            nacute: "",
            nang: "",
            nap: "",
            napE: "",
            napid: "",
            napos: "",
            napprox: "",
            natural: "",
            naturals: "",
            natur: "",
            nbsp: "\xa0",
            nbump: "",
            nbumpe: "",
            ncap: "",
            Ncaron: "",
            ncaron: "",
            Ncedil: "",
            ncedil: "",
            ncong: "",
            ncongdot: "",
            ncup: "",
            Ncy: "",
            ncy: "",
            ndash: "",
            nearhk: "",
            nearr: "",
            neArr: "",
            nearrow: "",
            ne: "",
            nedot: "",
            NegativeMediumSpace: "",
            NegativeThickSpace: "",
            NegativeThinSpace: "",
            NegativeVeryThinSpace: "",
            nequiv: "",
            nesear: "",
            nesim: "",
            NestedGreaterGreater: "",
            NestedLessLess: "",
            NewLine: "\n",
            nexist: "",
            nexists: "",
            Nfr: "\uD835\uDD11",
            nfr: "\uD835\uDD2B",
            ngE: "",
            nge: "",
            ngeq: "",
            ngeqq: "",
            ngeqslant: "",
            nges: "",
            nGg: "",
            ngsim: "",
            nGt: "",
            ngt: "",
            ngtr: "",
            nGtv: "",
            nharr: "",
            nhArr: "",
            nhpar: "",
            ni: "",
            nis: "",
            nisd: "",
            niv: "",
            NJcy: "",
            njcy: "",
            nlarr: "",
            nlArr: "",
            nldr: "",
            nlE: "",
            nle: "",
            nleftarrow: "",
            nLeftarrow: "",
            nleftrightarrow: "",
            nLeftrightarrow: "",
            nleq: "",
            nleqq: "",
            nleqslant: "",
            nles: "",
            nless: "",
            nLl: "",
            nlsim: "",
            nLt: "",
            nlt: "",
            nltri: "",
            nltrie: "",
            nLtv: "",
            nmid: "",
            NoBreak: "",
            NonBreakingSpace: "\xa0",
            nopf: "\uD835\uDD5F",
            Nopf: "",
            Not: "",
            not: "\xac",
            NotCongruent: "",
            NotCupCap: "",
            NotDoubleVerticalBar: "",
            NotElement: "",
            NotEqual: "",
            NotEqualTilde: "",
            NotExists: "",
            NotGreater: "",
            NotGreaterEqual: "",
            NotGreaterFullEqual: "",
            NotGreaterGreater: "",
            NotGreaterLess: "",
            NotGreaterSlantEqual: "",
            NotGreaterTilde: "",
            NotHumpDownHump: "",
            NotHumpEqual: "",
            notin: "",
            notindot: "",
            notinE: "",
            notinva: "",
            notinvb: "",
            notinvc: "",
            NotLeftTriangleBar: "",
            NotLeftTriangle: "",
            NotLeftTriangleEqual: "",
            NotLess: "",
            NotLessEqual: "",
            NotLessGreater: "",
            NotLessLess: "",
            NotLessSlantEqual: "",
            NotLessTilde: "",
            NotNestedGreaterGreater: "",
            NotNestedLessLess: "",
            notni: "",
            notniva: "",
            notnivb: "",
            notnivc: "",
            NotPrecedes: "",
            NotPrecedesEqual: "",
            NotPrecedesSlantEqual: "",
            NotReverseElement: "",
            NotRightTriangleBar: "",
            NotRightTriangle: "",
            NotRightTriangleEqual: "",
            NotSquareSubset: "",
            NotSquareSubsetEqual: "",
            NotSquareSuperset: "",
            NotSquareSupersetEqual: "",
            NotSubset: "",
            NotSubsetEqual: "",
            NotSucceeds: "",
            NotSucceedsEqual: "",
            NotSucceedsSlantEqual: "",
            NotSucceedsTilde: "",
            NotSuperset: "",
            NotSupersetEqual: "",
            NotTilde: "",
            NotTildeEqual: "",
            NotTildeFullEqual: "",
            NotTildeTilde: "",
            NotVerticalBar: "",
            nparallel: "",
            npar: "",
            nparsl: "",
            npart: "",
            npolint: "",
            npr: "",
            nprcue: "",
            nprec: "",
            npreceq: "",
            npre: "",
            nrarrc: "",
            nrarr: "",
            nrArr: "",
            nrarrw: "",
            nrightarrow: "",
            nRightarrow: "",
            nrtri: "",
            nrtrie: "",
            nsc: "",
            nsccue: "",
            nsce: "",
            Nscr: "\uD835\uDCA9",
            nscr: "\uD835\uDCC3",
            nshortmid: "",
            nshortparallel: "",
            nsim: "",
            nsime: "",
            nsimeq: "",
            nsmid: "",
            nspar: "",
            nsqsube: "",
            nsqsupe: "",
            nsub: "",
            nsubE: "",
            nsube: "",
            nsubset: "",
            nsubseteq: "",
            nsubseteqq: "",
            nsucc: "",
            nsucceq: "",
            nsup: "",
            nsupE: "",
            nsupe: "",
            nsupset: "",
            nsupseteq: "",
            nsupseteqq: "",
            ntgl: "",
            Ntilde: "\xd1",
            ntilde: "\xf1",
            ntlg: "",
            ntriangleleft: "",
            ntrianglelefteq: "",
            ntriangleright: "",
            ntrianglerighteq: "",
            Nu: "",
            nu: "",
            num: "#",
            numero: "",
            numsp: "",
            nvap: "",
            nvdash: "",
            nvDash: "",
            nVdash: "",
            nVDash: "",
            nvge: "",
            nvgt: ">",
            nvHarr: "",
            nvinfin: "",
            nvlArr: "",
            nvle: "",
            nvlt: "<",
            nvltrie: "",
            nvrArr: "",
            nvrtrie: "",
            nvsim: "",
            nwarhk: "",
            nwarr: "",
            nwArr: "",
            nwarrow: "",
            nwnear: "",
            Oacute: "\xd3",
            oacute: "\xf3",
            oast: "",
            Ocirc: "\xd4",
            ocirc: "\xf4",
            ocir: "",
            Ocy: "",
            ocy: "",
            odash: "",
            Odblac: "",
            odblac: "",
            odiv: "",
            odot: "",
            odsold: "",
            OElig: "",
            oelig: "",
            ofcir: "",
            Ofr: "\uD835\uDD12",
            ofr: "\uD835\uDD2C",
            ogon: "",
            Ograve: "\xd2",
            ograve: "\xf2",
            ogt: "",
            ohbar: "",
            ohm: "",
            oint: "",
            olarr: "",
            olcir: "",
            olcross: "",
            oline: "",
            olt: "",
            Omacr: "",
            omacr: "",
            Omega: "",
            omega: "",
            Omicron: "",
            omicron: "",
            omid: "",
            ominus: "",
            Oopf: "\uD835\uDD46",
            oopf: "\uD835\uDD60",
            opar: "",
            OpenCurlyDoubleQuote: "",
            OpenCurlyQuote: "",
            operp: "",
            oplus: "",
            orarr: "",
            Or: "",
            or: "",
            ord: "",
            order: "",
            orderof: "",
            ordf: "\xaa",
            ordm: "\xba",
            origof: "",
            oror: "",
            orslope: "",
            orv: "",
            oS: "",
            Oscr: "\uD835\uDCAA",
            oscr: "",
            Oslash: "\xd8",
            oslash: "\xf8",
            osol: "",
            Otilde: "\xd5",
            otilde: "\xf5",
            otimesas: "",
            Otimes: "",
            otimes: "",
            Ouml: "\xd6",
            ouml: "\xf6",
            ovbar: "",
            OverBar: "",
            OverBrace: "",
            OverBracket: "",
            OverParenthesis: "",
            para: "\xb6",
            parallel: "",
            par: "",
            parsim: "",
            parsl: "",
            part: "",
            PartialD: "",
            Pcy: "",
            pcy: "",
            percnt: "%",
            period: ".",
            permil: "",
            perp: "",
            pertenk: "",
            Pfr: "\uD835\uDD13",
            pfr: "\uD835\uDD2D",
            Phi: "",
            phi: "",
            phiv: "",
            phmmat: "",
            phone: "",
            Pi: "",
            pi: "",
            pitchfork: "",
            piv: "",
            planck: "",
            planckh: "",
            plankv: "",
            plusacir: "",
            plusb: "",
            pluscir: "",
            plus: "+",
            plusdo: "",
            plusdu: "",
            pluse: "",
            PlusMinus: "\xb1",
            plusmn: "\xb1",
            plussim: "",
            plustwo: "",
            pm: "\xb1",
            Poincareplane: "",
            pointint: "",
            popf: "\uD835\uDD61",
            Popf: "",
            pound: "\xa3",
            prap: "",
            Pr: "",
            pr: "",
            prcue: "",
            precapprox: "",
            prec: "",
            preccurlyeq: "",
            Precedes: "",
            PrecedesEqual: "",
            PrecedesSlantEqual: "",
            PrecedesTilde: "",
            preceq: "",
            precnapprox: "",
            precneqq: "",
            precnsim: "",
            pre: "",
            prE: "",
            precsim: "",
            prime: "",
            Prime: "",
            primes: "",
            prnap: "",
            prnE: "",
            prnsim: "",
            prod: "",
            Product: "",
            profalar: "",
            profline: "",
            profsurf: "",
            prop: "",
            Proportional: "",
            Proportion: "",
            propto: "",
            prsim: "",
            prurel: "",
            Pscr: "\uD835\uDCAB",
            pscr: "\uD835\uDCC5",
            Psi: "",
            psi: "",
            puncsp: "",
            Qfr: "\uD835\uDD14",
            qfr: "\uD835\uDD2E",
            qint: "",
            qopf: "\uD835\uDD62",
            Qopf: "",
            qprime: "",
            Qscr: "\uD835\uDCAC",
            qscr: "\uD835\uDCC6",
            quaternions: "",
            quatint: "",
            quest: "?",
            questeq: "",
            quot: '"',
            QUOT: '"',
            rAarr: "",
            race: "",
            Racute: "",
            racute: "",
            radic: "",
            raemptyv: "",
            rang: "",
            Rang: "",
            rangd: "",
            range: "",
            rangle: "",
            raquo: "\xbb",
            rarrap: "",
            rarrb: "",
            rarrbfs: "",
            rarrc: "",
            rarr: "",
            Rarr: "",
            rArr: "",
            rarrfs: "",
            rarrhk: "",
            rarrlp: "",
            rarrpl: "",
            rarrsim: "",
            Rarrtl: "",
            rarrtl: "",
            rarrw: "",
            ratail: "",
            rAtail: "",
            ratio: "",
            rationals: "",
            rbarr: "",
            rBarr: "",
            RBarr: "",
            rbbrk: "",
            rbrace: "}",
            rbrack: "]",
            rbrke: "",
            rbrksld: "",
            rbrkslu: "",
            Rcaron: "",
            rcaron: "",
            Rcedil: "",
            rcedil: "",
            rceil: "",
            rcub: "}",
            Rcy: "",
            rcy: "",
            rdca: "",
            rdldhar: "",
            rdquo: "",
            rdquor: "",
            rdsh: "",
            real: "",
            realine: "",
            realpart: "",
            reals: "",
            Re: "",
            rect: "",
            reg: "\xae",
            REG: "\xae",
            ReverseElement: "",
            ReverseEquilibrium: "",
            ReverseUpEquilibrium: "",
            rfisht: "",
            rfloor: "",
            rfr: "\uD835\uDD2F",
            Rfr: "",
            rHar: "",
            rhard: "",
            rharu: "",
            rharul: "",
            Rho: "",
            rho: "",
            rhov: "",
            RightAngleBracket: "",
            RightArrowBar: "",
            rightarrow: "",
            RightArrow: "",
            Rightarrow: "",
            RightArrowLeftArrow: "",
            rightarrowtail: "",
            RightCeiling: "",
            RightDoubleBracket: "",
            RightDownTeeVector: "",
            RightDownVectorBar: "",
            RightDownVector: "",
            RightFloor: "",
            rightharpoondown: "",
            rightharpoonup: "",
            rightleftarrows: "",
            rightleftharpoons: "",
            rightrightarrows: "",
            rightsquigarrow: "",
            RightTeeArrow: "",
            RightTee: "",
            RightTeeVector: "",
            rightthreetimes: "",
            RightTriangleBar: "",
            RightTriangle: "",
            RightTriangleEqual: "",
            RightUpDownVector: "",
            RightUpTeeVector: "",
            RightUpVectorBar: "",
            RightUpVector: "",
            RightVectorBar: "",
            RightVector: "",
            ring: "",
            risingdotseq: "",
            rlarr: "",
            rlhar: "",
            rlm: "",
            rmoustache: "",
            rmoust: "",
            rnmid: "",
            roang: "",
            roarr: "",
            robrk: "",
            ropar: "",
            ropf: "\uD835\uDD63",
            Ropf: "",
            roplus: "",
            rotimes: "",
            RoundImplies: "",
            rpar: ")",
            rpargt: "",
            rppolint: "",
            rrarr: "",
            Rrightarrow: "",
            rsaquo: "",
            rscr: "\uD835\uDCC7",
            Rscr: "",
            rsh: "",
            Rsh: "",
            rsqb: "]",
            rsquo: "",
            rsquor: "",
            rthree: "",
            rtimes: "",
            rtri: "",
            rtrie: "",
            rtrif: "",
            rtriltri: "",
            RuleDelayed: "",
            ruluhar: "",
            rx: "",
            Sacute: "",
            sacute: "",
            sbquo: "",
            scap: "",
            Scaron: "",
            scaron: "",
            Sc: "",
            sc: "",
            sccue: "",
            sce: "",
            scE: "",
            Scedil: "",
            scedil: "",
            Scirc: "",
            scirc: "",
            scnap: "",
            scnE: "",
            scnsim: "",
            scpolint: "",
            scsim: "",
            Scy: "",
            scy: "",
            sdotb: "",
            sdot: "",
            sdote: "",
            searhk: "",
            searr: "",
            seArr: "",
            searrow: "",
            sect: "\xa7",
            semi: ";",
            seswar: "",
            setminus: "",
            setmn: "",
            sext: "",
            Sfr: "\uD835\uDD16",
            sfr: "\uD835\uDD30",
            sfrown: "",
            sharp: "",
            SHCHcy: "",
            shchcy: "",
            SHcy: "",
            shcy: "",
            ShortDownArrow: "",
            ShortLeftArrow: "",
            shortmid: "",
            shortparallel: "",
            ShortRightArrow: "",
            ShortUpArrow: "",
            shy: "\xad",
            Sigma: "",
            sigma: "",
            sigmaf: "",
            sigmav: "",
            sim: "",
            simdot: "",
            sime: "",
            simeq: "",
            simg: "",
            simgE: "",
            siml: "",
            simlE: "",
            simne: "",
            simplus: "",
            simrarr: "",
            slarr: "",
            SmallCircle: "",
            smallsetminus: "",
            smashp: "",
            smeparsl: "",
            smid: "",
            smile: "",
            smt: "",
            smte: "",
            smtes: "",
            SOFTcy: "",
            softcy: "",
            solbar: "",
            solb: "",
            sol: "/",
            Sopf: "\uD835\uDD4A",
            sopf: "\uD835\uDD64",
            spades: "",
            spadesuit: "",
            spar: "",
            sqcap: "",
            sqcaps: "",
            sqcup: "",
            sqcups: "",
            Sqrt: "",
            sqsub: "",
            sqsube: "",
            sqsubset: "",
            sqsubseteq: "",
            sqsup: "",
            sqsupe: "",
            sqsupset: "",
            sqsupseteq: "",
            square: "",
            Square: "",
            SquareIntersection: "",
            SquareSubset: "",
            SquareSubsetEqual: "",
            SquareSuperset: "",
            SquareSupersetEqual: "",
            SquareUnion: "",
            squarf: "",
            squ: "",
            squf: "",
            srarr: "",
            Sscr: "\uD835\uDCAE",
            sscr: "\uD835\uDCC8",
            ssetmn: "",
            ssmile: "",
            sstarf: "",
            Star: "",
            star: "",
            starf: "",
            straightepsilon: "",
            straightphi: "",
            strns: "\xaf",
            sub: "",
            Sub: "",
            subdot: "",
            subE: "",
            sube: "",
            subedot: "",
            submult: "",
            subnE: "",
            subne: "",
            subplus: "",
            subrarr: "",
            subset: "",
            Subset: "",
            subseteq: "",
            subseteqq: "",
            SubsetEqual: "",
            subsetneq: "",
            subsetneqq: "",
            subsim: "",
            subsub: "",
            subsup: "",
            succapprox: "",
            succ: "",
            succcurlyeq: "",
            Succeeds: "",
            SucceedsEqual: "",
            SucceedsSlantEqual: "",
            SucceedsTilde: "",
            succeq: "",
            succnapprox: "",
            succneqq: "",
            succnsim: "",
            succsim: "",
            SuchThat: "",
            sum: "",
            Sum: "",
            sung: "",
            sup1: "\xb9",
            sup2: "\xb2",
            sup3: "\xb3",
            sup: "",
            Sup: "",
            supdot: "",
            supdsub: "",
            supE: "",
            supe: "",
            supedot: "",
            Superset: "",
            SupersetEqual: "",
            suphsol: "",
            suphsub: "",
            suplarr: "",
            supmult: "",
            supnE: "",
            supne: "",
            supplus: "",
            supset: "",
            Supset: "",
            supseteq: "",
            supseteqq: "",
            supsetneq: "",
            supsetneqq: "",
            supsim: "",
            supsub: "",
            supsup: "",
            swarhk: "",
            swarr: "",
            swArr: "",
            swarrow: "",
            swnwar: "",
            szlig: "\xdf",
            Tab: "	",
            target: "",
            Tau: "",
            tau: "",
            tbrk: "",
            Tcaron: "",
            tcaron: "",
            Tcedil: "",
            tcedil: "",
            Tcy: "",
            tcy: "",
            tdot: "",
            telrec: "",
            Tfr: "\uD835\uDD17",
            tfr: "\uD835\uDD31",
            there4: "",
            therefore: "",
            Therefore: "",
            Theta: "",
            theta: "",
            thetasym: "",
            thetav: "",
            thickapprox: "",
            thicksim: "",
            ThickSpace: "",
            ThinSpace: "",
            thinsp: "",
            thkap: "",
            thksim: "",
            THORN: "\xde",
            thorn: "\xfe",
            tilde: "",
            Tilde: "",
            TildeEqual: "",
            TildeFullEqual: "",
            TildeTilde: "",
            timesbar: "",
            timesb: "",
            times: "\xd7",
            timesd: "",
            tint: "",
            toea: "",
            topbot: "",
            topcir: "",
            top: "",
            Topf: "\uD835\uDD4B",
            topf: "\uD835\uDD65",
            topfork: "",
            tosa: "",
            tprime: "",
            trade: "",
            TRADE: "",
            triangle: "",
            triangledown: "",
            triangleleft: "",
            trianglelefteq: "",
            triangleq: "",
            triangleright: "",
            trianglerighteq: "",
            tridot: "",
            trie: "",
            triminus: "",
            TripleDot: "",
            triplus: "",
            trisb: "",
            tritime: "",
            trpezium: "",
            Tscr: "\uD835\uDCAF",
            tscr: "\uD835\uDCC9",
            TScy: "",
            tscy: "",
            TSHcy: "",
            tshcy: "",
            Tstrok: "",
            tstrok: "",
            twixt: "",
            twoheadleftarrow: "",
            twoheadrightarrow: "",
            Uacute: "\xda",
            uacute: "\xfa",
            uarr: "",
            Uarr: "",
            uArr: "",
            Uarrocir: "",
            Ubrcy: "",
            ubrcy: "",
            Ubreve: "",
            ubreve: "",
            Ucirc: "\xdb",
            ucirc: "\xfb",
            Ucy: "",
            ucy: "",
            udarr: "",
            Udblac: "",
            udblac: "",
            udhar: "",
            ufisht: "",
            Ufr: "\uD835\uDD18",
            ufr: "\uD835\uDD32",
            Ugrave: "\xd9",
            ugrave: "\xf9",
            uHar: "",
            uharl: "",
            uharr: "",
            uhblk: "",
            ulcorn: "",
            ulcorner: "",
            ulcrop: "",
            ultri: "",
            Umacr: "",
            umacr: "",
            uml: "\xa8",
            UnderBar: "_",
            UnderBrace: "",
            UnderBracket: "",
            UnderParenthesis: "",
            Union: "",
            UnionPlus: "",
            Uogon: "",
            uogon: "",
            Uopf: "\uD835\uDD4C",
            uopf: "\uD835\uDD66",
            UpArrowBar: "",
            uparrow: "",
            UpArrow: "",
            Uparrow: "",
            UpArrowDownArrow: "",
            updownarrow: "",
            UpDownArrow: "",
            Updownarrow: "",
            UpEquilibrium: "",
            upharpoonleft: "",
            upharpoonright: "",
            uplus: "",
            UpperLeftArrow: "",
            UpperRightArrow: "",
            upsi: "",
            Upsi: "",
            upsih: "",
            Upsilon: "",
            upsilon: "",
            UpTeeArrow: "",
            UpTee: "",
            upuparrows: "",
            urcorn: "",
            urcorner: "",
            urcrop: "",
            Uring: "",
            uring: "",
            urtri: "",
            Uscr: "\uD835\uDCB0",
            uscr: "\uD835\uDCCA",
            utdot: "",
            Utilde: "",
            utilde: "",
            utri: "",
            utrif: "",
            uuarr: "",
            Uuml: "\xdc",
            uuml: "\xfc",
            uwangle: "",
            vangrt: "",
            varepsilon: "",
            varkappa: "",
            varnothing: "",
            varphi: "",
            varpi: "",
            varpropto: "",
            varr: "",
            vArr: "",
            varrho: "",
            varsigma: "",
            varsubsetneq: "",
            varsubsetneqq: "",
            varsupsetneq: "",
            varsupsetneqq: "",
            vartheta: "",
            vartriangleleft: "",
            vartriangleright: "",
            vBar: "",
            Vbar: "",
            vBarv: "",
            Vcy: "",
            vcy: "",
            vdash: "",
            vDash: "",
            Vdash: "",
            VDash: "",
            Vdashl: "",
            veebar: "",
            vee: "",
            Vee: "",
            veeeq: "",
            vellip: "",
            verbar: "|",
            Verbar: "",
            vert: "|",
            Vert: "",
            VerticalBar: "",
            VerticalLine: "|",
            VerticalSeparator: "",
            VerticalTilde: "",
            VeryThinSpace: "",
            Vfr: "\uD835\uDD19",
            vfr: "\uD835\uDD33",
            vltri: "",
            vnsub: "",
            vnsup: "",
            Vopf: "\uD835\uDD4D",
            vopf: "\uD835\uDD67",
            vprop: "",
            vrtri: "",
            Vscr: "\uD835\uDCB1",
            vscr: "\uD835\uDCCB",
            vsubnE: "",
            vsubne: "",
            vsupnE: "",
            vsupne: "",
            Vvdash: "",
            vzigzag: "",
            Wcirc: "",
            wcirc: "",
            wedbar: "",
            wedge: "",
            Wedge: "",
            wedgeq: "",
            weierp: "",
            Wfr: "\uD835\uDD1A",
            wfr: "\uD835\uDD34",
            Wopf: "\uD835\uDD4E",
            wopf: "\uD835\uDD68",
            wp: "",
            wr: "",
            wreath: "",
            Wscr: "\uD835\uDCB2",
            wscr: "\uD835\uDCCC",
            xcap: "",
            xcirc: "",
            xcup: "",
            xdtri: "",
            Xfr: "\uD835\uDD1B",
            xfr: "\uD835\uDD35",
            xharr: "",
            xhArr: "",
            Xi: "",
            xi: "",
            xlarr: "",
            xlArr: "",
            xmap: "",
            xnis: "",
            xodot: "",
            Xopf: "\uD835\uDD4F",
            xopf: "\uD835\uDD69",
            xoplus: "",
            xotime: "",
            xrarr: "",
            xrArr: "",
            Xscr: "\uD835\uDCB3",
            xscr: "\uD835\uDCCD",
            xsqcup: "",
            xuplus: "",
            xutri: "",
            xvee: "",
            xwedge: "",
            Yacute: "\xdd",
            yacute: "\xfd",
            YAcy: "",
            yacy: "",
            Ycirc: "",
            ycirc: "",
            Ycy: "",
            ycy: "",
            yen: "\xa5",
            Yfr: "\uD835\uDD1C",
            yfr: "\uD835\uDD36",
            YIcy: "",
            yicy: "",
            Yopf: "\uD835\uDD50",
            yopf: "\uD835\uDD6A",
            Yscr: "\uD835\uDCB4",
            yscr: "\uD835\uDCCE",
            YUcy: "",
            yucy: "",
            yuml: "\xff",
            Yuml: "",
            Zacute: "",
            zacute: "",
            Zcaron: "",
            zcaron: "",
            Zcy: "",
            zcy: "",
            Zdot: "",
            zdot: "",
            zeetrf: "",
            ZeroWidthSpace: "",
            Zeta: "",
            zeta: "",
            zfr: "\uD835\uDD37",
            Zfr: "",
            ZHcy: "",
            zhcy: "",
            zigrarr: "",
            zopf: "\uD835\uDD6B",
            Zopf: "",
            Zscr: "\uD835\uDCB5",
            zscr: "\uD835\uDCCF",
            zwj: "",
            zwnj: ""
        };
    }
});
// node_modules/markdown-it/lib/common/entities.js
var require_entities2 = __commonJS({
    "node_modules/markdown-it/lib/common/entities.js" (exports1, module2) {
        "use strict";
        module2.exports = require_entities();
    }
});
// node_modules/uc.micro/categories/P/regex.js
var require_regex = __commonJS({
    "node_modules/uc.micro/categories/P/regex.js" (exports1, module2) {
        module2.exports = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
    }
});
// node_modules/mdurl/encode.js
var require_encode = __commonJS({
    "node_modules/mdurl/encode.js" (exports1, module2) {
        "use strict";
        var encodeCache = {};
        function getEncodeCache(exclude) {
            var i, ch, cache = encodeCache[exclude];
            if (cache) {
                return cache;
            }
            cache = encodeCache[exclude] = [];
            for(i = 0; i < 128; i++){
                ch = String.fromCharCode(i);
                if (/^[0-9a-z]$/i.test(ch)) {
                    cache.push(ch);
                } else {
                    cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
                }
            }
            for(i = 0; i < exclude.length; i++){
                cache[exclude.charCodeAt(i)] = exclude[i];
            }
            return cache;
        }
        function encode(string, exclude, keepEscaped) {
            var i, l, code2, nextCode, cache, result = "";
            if (typeof exclude !== "string") {
                keepEscaped = exclude;
                exclude = encode.defaultChars;
            }
            if (typeof keepEscaped === "undefined") {
                keepEscaped = true;
            }
            cache = getEncodeCache(exclude);
            for(i = 0, l = string.length; i < l; i++){
                code2 = string.charCodeAt(i);
                if (keepEscaped && code2 === 37 && i + 2 < l) {
                    if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
                        result += string.slice(i, i + 3);
                        i += 2;
                        continue;
                    }
                }
                if (code2 < 128) {
                    result += cache[code2];
                    continue;
                }
                if (code2 >= 55296 && code2 <= 57343) {
                    if (code2 >= 55296 && code2 <= 56319 && i + 1 < l) {
                        nextCode = string.charCodeAt(i + 1);
                        if (nextCode >= 56320 && nextCode <= 57343) {
                            result += encodeURIComponent(string[i] + string[i + 1]);
                            i++;
                            continue;
                        }
                    }
                    result += "%EF%BF%BD";
                    continue;
                }
                result += encodeURIComponent(string[i]);
            }
            return result;
        }
        encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
        encode.componentChars = "-_.!~*'()";
        module2.exports = encode;
    }
});
// node_modules/mdurl/decode.js
var require_decode = __commonJS({
    "node_modules/mdurl/decode.js" (exports1, module2) {
        "use strict";
        var decodeCache = {};
        function getDecodeCache(exclude) {
            var i, ch, cache = decodeCache[exclude];
            if (cache) {
                return cache;
            }
            cache = decodeCache[exclude] = [];
            for(i = 0; i < 128; i++){
                ch = String.fromCharCode(i);
                cache.push(ch);
            }
            for(i = 0; i < exclude.length; i++){
                ch = exclude.charCodeAt(i);
                cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
            }
            return cache;
        }
        function decode(string, exclude) {
            var cache;
            if (typeof exclude !== "string") {
                exclude = decode.defaultChars;
            }
            cache = getDecodeCache(exclude);
            return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
                var i, l, b1, b2, b3, b4, chr, result = "";
                for(i = 0, l = seq.length; i < l; i += 3){
                    b1 = parseInt(seq.slice(i + 1, i + 3), 16);
                    if (b1 < 128) {
                        result += cache[b1];
                        continue;
                    }
                    if ((b1 & 224) === 192 && i + 3 < l) {
                        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
                        if ((b2 & 192) === 128) {
                            chr = b1 << 6 & 1984 | b2 & 63;
                            if (chr < 128) {
                                result += "";
                            } else {
                                result += String.fromCharCode(chr);
                            }
                            i += 3;
                            continue;
                        }
                    }
                    if ((b1 & 240) === 224 && i + 6 < l) {
                        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
                        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
                        if ((b2 & 192) === 128 && (b3 & 192) === 128) {
                            chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
                            if (chr < 2048 || chr >= 55296 && chr <= 57343) {
                                result += "";
                            } else {
                                result += String.fromCharCode(chr);
                            }
                            i += 6;
                            continue;
                        }
                    }
                    if ((b1 & 248) === 240 && i + 9 < l) {
                        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
                        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
                        b4 = parseInt(seq.slice(i + 10, i + 12), 16);
                        if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
                            chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
                            if (chr < 65536 || chr > 1114111) {
                                result += "";
                            } else {
                                chr -= 65536;
                                result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
                            }
                            i += 9;
                            continue;
                        }
                    }
                    result += "";
                }
                return result;
            });
        }
        decode.defaultChars = ";/?:@&=+$,#";
        decode.componentChars = "";
        module2.exports = decode;
    }
});
// node_modules/mdurl/format.js
var require_format = __commonJS({
    "node_modules/mdurl/format.js" (exports1, module2) {
        "use strict";
        module2.exports = function format2(url) {
            var result = "";
            result += url.protocol || "";
            result += url.slashes ? "//" : "";
            result += url.auth ? url.auth + "@" : "";
            if (url.hostname && url.hostname.indexOf(":") !== -1) {
                result += "[" + url.hostname + "]";
            } else {
                result += url.hostname || "";
            }
            result += url.port ? ":" + url.port : "";
            result += url.pathname || "";
            result += url.search || "";
            result += url.hash || "";
            return result;
        };
    }
});
// node_modules/mdurl/parse.js
var require_parse = __commonJS({
    "node_modules/mdurl/parse.js" (exports1, module2) {
        "use strict";
        function Url() {
            this.protocol = null;
            this.slashes = null;
            this.auth = null;
            this.port = null;
            this.hostname = null;
            this.hash = null;
            this.search = null;
            this.pathname = null;
        }
        var protocolPattern = /^([a-z0-9.+-]+:)/i;
        var portPattern = /:[0-9]*$/;
        var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
        var delims = [
            "<",
            ">",
            '"',
            "`",
            " ",
            "\r",
            "\n",
            "	"
        ];
        var unwise = [
            "{",
            "}",
            "|",
            "\\",
            "^",
            "`"
        ].concat(delims);
        var autoEscape = [
            "'"
        ].concat(unwise);
        var nonHostChars = [
            "%",
            "/",
            "?",
            ";",
            "#"
        ].concat(autoEscape);
        var hostEndingChars = [
            "/",
            "?",
            "#"
        ];
        var hostnameMaxLen = 255;
        var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
        var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
        var hostlessProtocol = {
            "javascript": true,
            "javascript:": true
        };
        var slashedProtocol = {
            "http": true,
            "https": true,
            "ftp": true,
            "gopher": true,
            "file": true,
            "http:": true,
            "https:": true,
            "ftp:": true,
            "gopher:": true,
            "file:": true
        };
        function urlParse(url, slashesDenoteHost) {
            if (url && url instanceof Url) {
                return url;
            }
            var u = new Url();
            u.parse(url, slashesDenoteHost);
            return u;
        }
        Url.prototype.parse = function(url, slashesDenoteHost) {
            var i, l, lowerProto, hec, slashes, rest = url;
            rest = rest.trim();
            if (!slashesDenoteHost && url.split("#").length === 1) {
                var simplePath = simplePathPattern.exec(rest);
                if (simplePath) {
                    this.pathname = simplePath[1];
                    if (simplePath[2]) {
                        this.search = simplePath[2];
                    }
                    return this;
                }
            }
            var proto = protocolPattern.exec(rest);
            if (proto) {
                proto = proto[0];
                lowerProto = proto.toLowerCase();
                this.protocol = proto;
                rest = rest.substr(proto.length);
            }
            if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                slashes = rest.substr(0, 2) === "//";
                if (slashes && !(proto && hostlessProtocol[proto])) {
                    rest = rest.substr(2);
                    this.slashes = true;
                }
            }
            if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
                var hostEnd = -1;
                for(i = 0; i < hostEndingChars.length; i++){
                    hec = rest.indexOf(hostEndingChars[i]);
                    if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
                        hostEnd = hec;
                    }
                }
                var auth, atSign;
                if (hostEnd === -1) {
                    atSign = rest.lastIndexOf("@");
                } else {
                    atSign = rest.lastIndexOf("@", hostEnd);
                }
                if (atSign !== -1) {
                    auth = rest.slice(0, atSign);
                    rest = rest.slice(atSign + 1);
                    this.auth = auth;
                }
                hostEnd = -1;
                for(i = 0; i < nonHostChars.length; i++){
                    hec = rest.indexOf(nonHostChars[i]);
                    if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
                        hostEnd = hec;
                    }
                }
                if (hostEnd === -1) {
                    hostEnd = rest.length;
                }
                if (rest[hostEnd - 1] === ":") {
                    hostEnd--;
                }
                var host = rest.slice(0, hostEnd);
                rest = rest.slice(hostEnd);
                this.parseHost(host);
                this.hostname = this.hostname || "";
                var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
                if (!ipv6Hostname) {
                    var hostparts = this.hostname.split(/\./);
                    for(i = 0, l = hostparts.length; i < l; i++){
                        var part = hostparts[i];
                        if (!part) {
                            continue;
                        }
                        if (!part.match(hostnamePartPattern)) {
                            var newpart = "";
                            for(var j = 0, k = part.length; j < k; j++){
                                if (part.charCodeAt(j) > 127) {
                                    newpart += "x";
                                } else {
                                    newpart += part[j];
                                }
                            }
                            if (!newpart.match(hostnamePartPattern)) {
                                var validParts = hostparts.slice(0, i);
                                var notHost = hostparts.slice(i + 1);
                                var bit = part.match(hostnamePartStart);
                                if (bit) {
                                    validParts.push(bit[1]);
                                    notHost.unshift(bit[2]);
                                }
                                if (notHost.length) {
                                    rest = notHost.join(".") + rest;
                                }
                                this.hostname = validParts.join(".");
                                break;
                            }
                        }
                    }
                }
                if (this.hostname.length > hostnameMaxLen) {
                    this.hostname = "";
                }
                if (ipv6Hostname) {
                    this.hostname = this.hostname.substr(1, this.hostname.length - 2);
                }
            }
            var hash = rest.indexOf("#");
            if (hash !== -1) {
                this.hash = rest.substr(hash);
                rest = rest.slice(0, hash);
            }
            var qm = rest.indexOf("?");
            if (qm !== -1) {
                this.search = rest.substr(qm);
                rest = rest.slice(0, qm);
            }
            if (rest) {
                this.pathname = rest;
            }
            if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
                this.pathname = "";
            }
            return this;
        };
        Url.prototype.parseHost = function(host) {
            var port = portPattern.exec(host);
            if (port) {
                port = port[0];
                if (port !== ":") {
                    this.port = port.substr(1);
                }
                host = host.substr(0, host.length - port.length);
            }
            if (host) {
                this.hostname = host;
            }
        };
        module2.exports = urlParse;
    }
});
// node_modules/mdurl/index.js
var require_mdurl = __commonJS({
    "node_modules/mdurl/index.js" (exports1, module2) {
        "use strict";
        module2.exports.encode = require_encode();
        module2.exports.decode = require_decode();
        module2.exports.format = require_format();
        module2.exports.parse = require_parse();
    }
});
// node_modules/uc.micro/properties/Any/regex.js
var require_regex2 = __commonJS({
    "node_modules/uc.micro/properties/Any/regex.js" (exports1, module2) {
        module2.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    }
});
// node_modules/uc.micro/categories/Cc/regex.js
var require_regex3 = __commonJS({
    "node_modules/uc.micro/categories/Cc/regex.js" (exports1, module2) {
        module2.exports = /[\0-\x1F\x7F-\x9F]/;
    }
});
// node_modules/uc.micro/categories/Cf/regex.js
var require_regex4 = __commonJS({
    "node_modules/uc.micro/categories/Cf/regex.js" (exports1, module2) {
        module2.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
    }
});
// node_modules/uc.micro/categories/Z/regex.js
var require_regex5 = __commonJS({
    "node_modules/uc.micro/categories/Z/regex.js" (exports1, module2) {
        module2.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
    }
});
// node_modules/uc.micro/index.js
var require_uc = __commonJS({
    "node_modules/uc.micro/index.js" (exports1) {
        "use strict";
        exports1.Any = require_regex2();
        exports1.Cc = require_regex3();
        exports1.Cf = require_regex4();
        exports1.P = require_regex();
        exports1.Z = require_regex5();
    }
});
// node_modules/markdown-it/lib/common/utils.js
var require_utils = __commonJS({
    "node_modules/markdown-it/lib/common/utils.js" (exports1) {
        "use strict";
        function _class(obj) {
            return Object.prototype.toString.call(obj);
        }
        function isString(obj) {
            return _class(obj) === "[object String]";
        }
        var _hasOwnProperty = Object.prototype.hasOwnProperty;
        function has(object, key) {
            return _hasOwnProperty.call(object, key);
        }
        function assign(obj) {
            var sources = Array.prototype.slice.call(arguments, 1);
            sources.forEach(function(source) {
                if (!source) {
                    return;
                }
                if (typeof source !== "object") {
                    throw new TypeError(source + "must be object");
                }
                Object.keys(source).forEach(function(key) {
                    obj[key] = source[key];
                });
            });
            return obj;
        }
        function arrayReplaceAt(src, pos, newElements) {
            return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
        }
        function isValidEntityCode(c) {
            if (c >= 55296 && c <= 57343) {
                return false;
            }
            if (c >= 64976 && c <= 65007) {
                return false;
            }
            if ((c & 65535) === 65535 || (c & 65535) === 65534) {
                return false;
            }
            if (c >= 0 && c <= 8) {
                return false;
            }
            if (c === 11) {
                return false;
            }
            if (c >= 14 && c <= 31) {
                return false;
            }
            if (c >= 127 && c <= 159) {
                return false;
            }
            if (c > 1114111) {
                return false;
            }
            return true;
        }
        function fromCodePoint(c) {
            if (c > 65535) {
                c -= 65536;
                var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);
                return String.fromCharCode(surrogate1, surrogate2);
            }
            return String.fromCharCode(c);
        }
        var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
        var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
        var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
        var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
        var entities = require_entities2();
        function replaceEntityPattern(match, name) {
            var code2 = 0;
            if (has(entities, name)) {
                return entities[name];
            }
            if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
                code2 = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
                if (isValidEntityCode(code2)) {
                    return fromCodePoint(code2);
                }
            }
            return match;
        }
        function unescapeMd(str) {
            if (str.indexOf("\\") < 0) {
                return str;
            }
            return str.replace(UNESCAPE_MD_RE, "$1");
        }
        function unescapeAll(str) {
            if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
                return str;
            }
            return str.replace(UNESCAPE_ALL_RE, function(match, escaped, entity) {
                if (escaped) {
                    return escaped;
                }
                return replaceEntityPattern(match, entity);
            });
        }
        var HTML_ESCAPE_TEST_RE = /[&<>"]/;
        var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
        var HTML_REPLACEMENTS = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;"
        };
        function replaceUnsafeChar(ch) {
            return HTML_REPLACEMENTS[ch];
        }
        function escapeHtml2(str) {
            if (HTML_ESCAPE_TEST_RE.test(str)) {
                return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
            }
            return str;
        }
        var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
        function escapeRE(str) {
            return str.replace(REGEXP_ESCAPE_RE, "\\$&");
        }
        function isSpace(code2) {
            switch(code2){
                case 9:
                case 32:
                    return true;
            }
            return false;
        }
        function isWhiteSpace(code2) {
            if (code2 >= 8192 && code2 <= 8202) {
                return true;
            }
            switch(code2){
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 32:
                case 160:
                case 5760:
                case 8239:
                case 8287:
                case 12288:
                    return true;
            }
            return false;
        }
        var UNICODE_PUNCT_RE = require_regex();
        function isPunctChar(ch) {
            return UNICODE_PUNCT_RE.test(ch);
        }
        function isMdAsciiPunct(ch) {
            switch(ch){
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 91:
                case 92:
                case 93:
                case 94:
                case 95:
                case 96:
                case 123:
                case 124:
                case 125:
                case 126:
                    return true;
                default:
                    return false;
            }
        }
        function normalizeReference(str) {
            str = str.trim().replace(/\s+/g, " ");
            if ("".toLowerCase() === "") {
                str = str.replace(//g, "\xdf");
            }
            return str.toLowerCase().toUpperCase();
        }
        exports1.lib = {};
        exports1.lib.mdurl = require_mdurl();
        exports1.lib.ucmicro = require_uc();
        exports1.assign = assign;
        exports1.isString = isString;
        exports1.has = has;
        exports1.unescapeMd = unescapeMd;
        exports1.unescapeAll = unescapeAll;
        exports1.isValidEntityCode = isValidEntityCode;
        exports1.fromCodePoint = fromCodePoint;
        exports1.escapeHtml = escapeHtml2;
        exports1.arrayReplaceAt = arrayReplaceAt;
        exports1.isSpace = isSpace;
        exports1.isWhiteSpace = isWhiteSpace;
        exports1.isMdAsciiPunct = isMdAsciiPunct;
        exports1.isPunctChar = isPunctChar;
        exports1.escapeRE = escapeRE;
        exports1.normalizeReference = normalizeReference;
    }
});
// node_modules/markdown-it/lib/helpers/parse_link_label.js
var require_parse_link_label = __commonJS({
    "node_modules/markdown-it/lib/helpers/parse_link_label.js" (exports1, module2) {
        "use strict";
        module2.exports = function parseLinkLabel(state, start, disableNested) {
            var level, found, marker, prevPos, labelEnd = -1, max2 = state.posMax, oldPos = state.pos;
            state.pos = start + 1;
            level = 1;
            while(state.pos < max2){
                marker = state.src.charCodeAt(state.pos);
                if (marker === 93) {
                    level--;
                    if (level === 0) {
                        found = true;
                        break;
                    }
                }
                prevPos = state.pos;
                state.md.inline.skipToken(state);
                if (marker === 91) {
                    if (prevPos === state.pos - 1) {
                        level++;
                    } else if (disableNested) {
                        state.pos = oldPos;
                        return -1;
                    }
                }
            }
            if (found) {
                labelEnd = state.pos;
            }
            state.pos = oldPos;
            return labelEnd;
        };
    }
});
// node_modules/markdown-it/lib/helpers/parse_link_destination.js
var require_parse_link_destination = __commonJS({
    "node_modules/markdown-it/lib/helpers/parse_link_destination.js" (exports1, module2) {
        "use strict";
        var unescapeAll = require_utils().unescapeAll;
        module2.exports = function parseLinkDestination(str, pos, max2) {
            var code2, level, lines = 0, start = pos, result = {
                ok: false,
                pos: 0,
                lines: 0,
                str: ""
            };
            if (str.charCodeAt(pos) === 60) {
                pos++;
                while(pos < max2){
                    code2 = str.charCodeAt(pos);
                    if (code2 === 10) {
                        return result;
                    }
                    if (code2 === 60) {
                        return result;
                    }
                    if (code2 === 62) {
                        result.pos = pos + 1;
                        result.str = unescapeAll(str.slice(start + 1, pos));
                        result.ok = true;
                        return result;
                    }
                    if (code2 === 92 && pos + 1 < max2) {
                        pos += 2;
                        continue;
                    }
                    pos++;
                }
                return result;
            }
            level = 0;
            while(pos < max2){
                code2 = str.charCodeAt(pos);
                if (code2 === 32) {
                    break;
                }
                if (code2 < 32 || code2 === 127) {
                    break;
                }
                if (code2 === 92 && pos + 1 < max2) {
                    if (str.charCodeAt(pos + 1) === 32) {
                        break;
                    }
                    pos += 2;
                    continue;
                }
                if (code2 === 40) {
                    level++;
                    if (level > 32) {
                        return result;
                    }
                }
                if (code2 === 41) {
                    if (level === 0) {
                        break;
                    }
                    level--;
                }
                pos++;
            }
            if (start === pos) {
                return result;
            }
            if (level !== 0) {
                return result;
            }
            result.str = unescapeAll(str.slice(start, pos));
            result.lines = lines;
            result.pos = pos;
            result.ok = true;
            return result;
        };
    }
});
// node_modules/markdown-it/lib/helpers/parse_link_title.js
var require_parse_link_title = __commonJS({
    "node_modules/markdown-it/lib/helpers/parse_link_title.js" (exports1, module2) {
        "use strict";
        var unescapeAll = require_utils().unescapeAll;
        module2.exports = function parseLinkTitle(str, pos, max2) {
            var code2, marker, lines = 0, start = pos, result = {
                ok: false,
                pos: 0,
                lines: 0,
                str: ""
            };
            if (pos >= max2) {
                return result;
            }
            marker = str.charCodeAt(pos);
            if (marker !== 34 && marker !== 39 && marker !== 40) {
                return result;
            }
            pos++;
            if (marker === 40) {
                marker = 41;
            }
            while(pos < max2){
                code2 = str.charCodeAt(pos);
                if (code2 === marker) {
                    result.pos = pos + 1;
                    result.lines = lines;
                    result.str = unescapeAll(str.slice(start + 1, pos));
                    result.ok = true;
                    return result;
                } else if (code2 === 40 && marker === 41) {
                    return result;
                } else if (code2 === 10) {
                    lines++;
                } else if (code2 === 92 && pos + 1 < max2) {
                    pos++;
                    if (str.charCodeAt(pos) === 10) {
                        lines++;
                    }
                }
                pos++;
            }
            return result;
        };
    }
});
// node_modules/markdown-it/lib/helpers/index.js
var require_helpers = __commonJS({
    "node_modules/markdown-it/lib/helpers/index.js" (exports1) {
        "use strict";
        exports1.parseLinkLabel = require_parse_link_label();
        exports1.parseLinkDestination = require_parse_link_destination();
        exports1.parseLinkTitle = require_parse_link_title();
    }
});
// node_modules/markdown-it/lib/renderer.js
var require_renderer = __commonJS({
    "node_modules/markdown-it/lib/renderer.js" (exports1, module2) {
        "use strict";
        var assign = require_utils().assign;
        var unescapeAll = require_utils().unescapeAll;
        var escapeHtml2 = require_utils().escapeHtml;
        var default_rules = {};
        default_rules.code_inline = function(tokens, idx, options, env, slf) {
            var token = tokens[idx];
            return "<code" + slf.renderAttrs(token) + ">" + escapeHtml2(tokens[idx].content) + "</code>";
        };
        default_rules.code_block = function(tokens, idx, options, env, slf) {
            var token = tokens[idx];
            return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml2(tokens[idx].content) + "</code></pre>\n";
        };
        default_rules.fence = function(tokens, idx, options, env, slf) {
            var token = tokens[idx], info = token.info ? unescapeAll(token.info).trim() : "", langName = "", langAttrs = "", highlighted, i, arr, tmpAttrs, tmpToken;
            if (info) {
                arr = info.split(/(\s+)/g);
                langName = arr[0];
                langAttrs = arr.slice(2).join("");
            }
            if (options.highlight) {
                highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml2(token.content);
            } else {
                highlighted = escapeHtml2(token.content);
            }
            if (highlighted.indexOf("<pre") === 0) {
                return highlighted + "\n";
            }
            if (info) {
                i = token.attrIndex("class");
                tmpAttrs = token.attrs ? token.attrs.slice() : [];
                if (i < 0) {
                    tmpAttrs.push([
                        "class",
                        options.langPrefix + langName
                    ]);
                } else {
                    tmpAttrs[i] = tmpAttrs[i].slice();
                    tmpAttrs[i][1] += " " + options.langPrefix + langName;
                }
                tmpToken = {
                    attrs: tmpAttrs
                };
                return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
            }
            return "<pre><code" + slf.renderAttrs(token) + ">" + highlighted + "</code></pre>\n";
        };
        default_rules.image = function(tokens, idx, options, env, slf) {
            var token = tokens[idx];
            token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env);
            return slf.renderToken(tokens, idx, options);
        };
        default_rules.hardbreak = function(tokens, idx, options) {
            return options.xhtmlOut ? "<br />\n" : "<br>\n";
        };
        default_rules.softbreak = function(tokens, idx, options) {
            return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
        };
        default_rules.text = function(tokens, idx) {
            return escapeHtml2(tokens[idx].content);
        };
        default_rules.html_block = function(tokens, idx) {
            return tokens[idx].content;
        };
        default_rules.html_inline = function(tokens, idx) {
            return tokens[idx].content;
        };
        function Renderer() {
            this.rules = assign({}, default_rules);
        }
        Renderer.prototype.renderAttrs = function renderAttrs(token) {
            var i, l, result;
            if (!token.attrs) {
                return "";
            }
            result = "";
            for(i = 0, l = token.attrs.length; i < l; i++){
                result += " " + escapeHtml2(token.attrs[i][0]) + '="' + escapeHtml2(token.attrs[i][1]) + '"';
            }
            return result;
        };
        Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
            var nextToken, result = "", needLf = false, token = tokens[idx];
            if (token.hidden) {
                return "";
            }
            if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
                result += "\n";
            }
            result += (token.nesting === -1 ? "</" : "<") + token.tag;
            result += this.renderAttrs(token);
            if (token.nesting === 0 && options.xhtmlOut) {
                result += " /";
            }
            if (token.block) {
                needLf = true;
                if (token.nesting === 1) {
                    if (idx + 1 < tokens.length) {
                        nextToken = tokens[idx + 1];
                        if (nextToken.type === "inline" || nextToken.hidden) {
                            needLf = false;
                        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
                            needLf = false;
                        }
                    }
                }
            }
            result += needLf ? ">\n" : ">";
            return result;
        };
        Renderer.prototype.renderInline = function(tokens, options, env) {
            var type, result = "", rules = this.rules;
            for(var i = 0, len = tokens.length; i < len; i++){
                type = tokens[i].type;
                if (typeof rules[type] !== "undefined") {
                    result += rules[type](tokens, i, options, env, this);
                } else {
                    result += this.renderToken(tokens, i, options);
                }
            }
            return result;
        };
        Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
            var result = "";
            for(var i = 0, len = tokens.length; i < len; i++){
                if (tokens[i].type === "text") {
                    result += tokens[i].content;
                } else if (tokens[i].type === "image") {
                    result += this.renderInlineAsText(tokens[i].children, options, env);
                } else if (tokens[i].type === "softbreak") {
                    result += "\n";
                }
            }
            return result;
        };
        Renderer.prototype.render = function(tokens, options, env) {
            var i, len, type, result = "", rules = this.rules;
            for(i = 0, len = tokens.length; i < len; i++){
                type = tokens[i].type;
                if (type === "inline") {
                    result += this.renderInline(tokens[i].children, options, env);
                } else if (typeof rules[type] !== "undefined") {
                    result += rules[tokens[i].type](tokens, i, options, env, this);
                } else {
                    result += this.renderToken(tokens, i, options, env);
                }
            }
            return result;
        };
        module2.exports = Renderer;
    }
});
// node_modules/markdown-it/lib/ruler.js
var require_ruler = __commonJS({
    "node_modules/markdown-it/lib/ruler.js" (exports1, module2) {
        "use strict";
        function Ruler() {
            this.__rules__ = [];
            this.__cache__ = null;
        }
        Ruler.prototype.__find__ = function(name) {
            for(var i = 0; i < this.__rules__.length; i++){
                if (this.__rules__[i].name === name) {
                    return i;
                }
            }
            return -1;
        };
        Ruler.prototype.__compile__ = function() {
            var self = this;
            var chains = [
                ""
            ];
            self.__rules__.forEach(function(rule) {
                if (!rule.enabled) {
                    return;
                }
                rule.alt.forEach(function(altName) {
                    if (chains.indexOf(altName) < 0) {
                        chains.push(altName);
                    }
                });
            });
            self.__cache__ = {};
            chains.forEach(function(chain) {
                self.__cache__[chain] = [];
                self.__rules__.forEach(function(rule) {
                    if (!rule.enabled) {
                        return;
                    }
                    if (chain && rule.alt.indexOf(chain) < 0) {
                        return;
                    }
                    self.__cache__[chain].push(rule.fn);
                });
            });
        };
        Ruler.prototype.at = function(name, fn, options) {
            var index = this.__find__(name);
            var opt = options || {};
            if (index === -1) {
                throw new Error("Parser rule not found: " + name);
            }
            this.__rules__[index].fn = fn;
            this.__rules__[index].alt = opt.alt || [];
            this.__cache__ = null;
        };
        Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
            var index = this.__find__(beforeName);
            var opt = options || {};
            if (index === -1) {
                throw new Error("Parser rule not found: " + beforeName);
            }
            this.__rules__.splice(index, 0, {
                name: ruleName,
                enabled: true,
                fn,
                alt: opt.alt || []
            });
            this.__cache__ = null;
        };
        Ruler.prototype.after = function(afterName, ruleName, fn, options) {
            var index = this.__find__(afterName);
            var opt = options || {};
            if (index === -1) {
                throw new Error("Parser rule not found: " + afterName);
            }
            this.__rules__.splice(index + 1, 0, {
                name: ruleName,
                enabled: true,
                fn,
                alt: opt.alt || []
            });
            this.__cache__ = null;
        };
        Ruler.prototype.push = function(ruleName, fn, options) {
            var opt = options || {};
            this.__rules__.push({
                name: ruleName,
                enabled: true,
                fn,
                alt: opt.alt || []
            });
            this.__cache__ = null;
        };
        Ruler.prototype.enable = function(list2, ignoreInvalid) {
            if (!Array.isArray(list2)) {
                list2 = [
                    list2
                ];
            }
            var result = [];
            list2.forEach(function(name) {
                var idx = this.__find__(name);
                if (idx < 0) {
                    if (ignoreInvalid) {
                        return;
                    }
                    throw new Error("Rules manager: invalid rule name " + name);
                }
                this.__rules__[idx].enabled = true;
                result.push(name);
            }, this);
            this.__cache__ = null;
            return result;
        };
        Ruler.prototype.enableOnly = function(list2, ignoreInvalid) {
            if (!Array.isArray(list2)) {
                list2 = [
                    list2
                ];
            }
            this.__rules__.forEach(function(rule) {
                rule.enabled = false;
            });
            this.enable(list2, ignoreInvalid);
        };
        Ruler.prototype.disable = function(list2, ignoreInvalid) {
            if (!Array.isArray(list2)) {
                list2 = [
                    list2
                ];
            }
            var result = [];
            list2.forEach(function(name) {
                var idx = this.__find__(name);
                if (idx < 0) {
                    if (ignoreInvalid) {
                        return;
                    }
                    throw new Error("Rules manager: invalid rule name " + name);
                }
                this.__rules__[idx].enabled = false;
                result.push(name);
            }, this);
            this.__cache__ = null;
            return result;
        };
        Ruler.prototype.getRules = function(chainName) {
            if (this.__cache__ === null) {
                this.__compile__();
            }
            return this.__cache__[chainName] || [];
        };
        module2.exports = Ruler;
    }
});
// node_modules/markdown-it/lib/rules_core/normalize.js
var require_normalize = __commonJS({
    "node_modules/markdown-it/lib/rules_core/normalize.js" (exports1, module2) {
        "use strict";
        var NEWLINES_RE = /\r\n?|\n/g;
        var NULL_RE = /\0/g;
        module2.exports = function normalize(state) {
            var str;
            str = state.src.replace(NEWLINES_RE, "\n");
            str = str.replace(NULL_RE, "");
            state.src = str;
        };
    }
});
// node_modules/markdown-it/lib/rules_core/block.js
var require_block = __commonJS({
    "node_modules/markdown-it/lib/rules_core/block.js" (exports1, module2) {
        "use strict";
        module2.exports = function block4(state) {
            var token;
            if (state.inlineMode) {
                token = new state.Token("inline", "", 0);
                token.content = state.src;
                token.map = [
                    0,
                    1
                ];
                token.children = [];
                state.tokens.push(token);
            } else {
                state.md.block.parse(state.src, state.md, state.env, state.tokens);
            }
        };
    }
});
// node_modules/markdown-it/lib/rules_core/inline.js
var require_inline = __commonJS({
    "node_modules/markdown-it/lib/rules_core/inline.js" (exports1, module2) {
        "use strict";
        module2.exports = function inline4(state) {
            var tokens = state.tokens, tok, i, l;
            for(i = 0, l = tokens.length; i < l; i++){
                tok = tokens[i];
                if (tok.type === "inline") {
                    state.md.inline.parse(tok.content, state.md, state.env, tok.children);
                }
            }
        };
    }
});
// node_modules/markdown-it/lib/rules_core/linkify.js
var require_linkify = __commonJS({
    "node_modules/markdown-it/lib/rules_core/linkify.js" (exports1, module2) {
        "use strict";
        var arrayReplaceAt = require_utils().arrayReplaceAt;
        function isLinkOpen(str) {
            return /^<a[>\s]/i.test(str);
        }
        function isLinkClose(str) {
            return /^<\/a\s*>/i.test(str);
        }
        module2.exports = function linkify(state) {
            var i, j, l, tokens, token, currentToken, nodes, ln, text2, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
            if (!state.md.options.linkify) {
                return;
            }
            for(j = 0, l = blockTokens.length; j < l; j++){
                if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
                    continue;
                }
                tokens = blockTokens[j].children;
                htmlLinkLevel = 0;
                for(i = tokens.length - 1; i >= 0; i--){
                    currentToken = tokens[i];
                    if (currentToken.type === "link_close") {
                        i--;
                        while(tokens[i].level !== currentToken.level && tokens[i].type !== "link_open"){
                            i--;
                        }
                        continue;
                    }
                    if (currentToken.type === "html_inline") {
                        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
                            htmlLinkLevel--;
                        }
                        if (isLinkClose(currentToken.content)) {
                            htmlLinkLevel++;
                        }
                    }
                    if (htmlLinkLevel > 0) {
                        continue;
                    }
                    if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
                        text2 = currentToken.content;
                        links = state.md.linkify.match(text2);
                        nodes = [];
                        level = currentToken.level;
                        lastPos = 0;
                        for(ln = 0; ln < links.length; ln++){
                            url = links[ln].url;
                            fullUrl = state.md.normalizeLink(url);
                            if (!state.md.validateLink(fullUrl)) {
                                continue;
                            }
                            urlText = links[ln].text;
                            if (!links[ln].schema) {
                                urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
                            } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
                                urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
                            } else {
                                urlText = state.md.normalizeLinkText(urlText);
                            }
                            pos = links[ln].index;
                            if (pos > lastPos) {
                                token = new state.Token("text", "", 0);
                                token.content = text2.slice(lastPos, pos);
                                token.level = level;
                                nodes.push(token);
                            }
                            token = new state.Token("link_open", "a", 1);
                            token.attrs = [
                                [
                                    "href",
                                    fullUrl
                                ]
                            ];
                            token.level = level++;
                            token.markup = "linkify";
                            token.info = "auto";
                            nodes.push(token);
                            token = new state.Token("text", "", 0);
                            token.content = urlText;
                            token.level = level;
                            nodes.push(token);
                            token = new state.Token("link_close", "a", -1);
                            token.level = --level;
                            token.markup = "linkify";
                            token.info = "auto";
                            nodes.push(token);
                            lastPos = links[ln].lastIndex;
                        }
                        if (lastPos < text2.length) {
                            token = new state.Token("text", "", 0);
                            token.content = text2.slice(lastPos);
                            token.level = level;
                            nodes.push(token);
                        }
                        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
                    }
                }
            }
        };
    }
});
// node_modules/markdown-it/lib/rules_core/replacements.js
var require_replacements = __commonJS({
    "node_modules/markdown-it/lib/rules_core/replacements.js" (exports1, module2) {
        "use strict";
        var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
        var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;
        var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
        var SCOPED_ABBR = {
            c: "\xa9",
            r: "\xae",
            p: "\xa7",
            tm: ""
        };
        function replaceFn(match, name) {
            return SCOPED_ABBR[name.toLowerCase()];
        }
        function replace_scoped(inlineTokens) {
            var i, token, inside_autolink = 0;
            for(i = inlineTokens.length - 1; i >= 0; i--){
                token = inlineTokens[i];
                if (token.type === "text" && !inside_autolink) {
                    token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
                }
                if (token.type === "link_open" && token.info === "auto") {
                    inside_autolink--;
                }
                if (token.type === "link_close" && token.info === "auto") {
                    inside_autolink++;
                }
            }
        }
        function replace_rare(inlineTokens) {
            var i, token, inside_autolink = 0;
            for(i = inlineTokens.length - 1; i >= 0; i--){
                token = inlineTokens[i];
                if (token.type === "text" && !inside_autolink) {
                    if (RARE_RE.test(token.content)) {
                        token.content = token.content.replace(/\+-/g, "\xb1").replace(/\.{2,}/g, "").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1").replace(/(^|\s)--(?=\s|$)/mg, "$1").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1");
                    }
                }
                if (token.type === "link_open" && token.info === "auto") {
                    inside_autolink--;
                }
                if (token.type === "link_close" && token.info === "auto") {
                    inside_autolink++;
                }
            }
        }
        module2.exports = function replace(state) {
            var blkIdx;
            if (!state.md.options.typographer) {
                return;
            }
            for(blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--){
                if (state.tokens[blkIdx].type !== "inline") {
                    continue;
                }
                if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
                    replace_scoped(state.tokens[blkIdx].children);
                }
                if (RARE_RE.test(state.tokens[blkIdx].content)) {
                    replace_rare(state.tokens[blkIdx].children);
                }
            }
        };
    }
});
// node_modules/markdown-it/lib/rules_core/smartquotes.js
var require_smartquotes = __commonJS({
    "node_modules/markdown-it/lib/rules_core/smartquotes.js" (exports1, module2) {
        "use strict";
        var isWhiteSpace = require_utils().isWhiteSpace;
        var isPunctChar = require_utils().isPunctChar;
        var isMdAsciiPunct = require_utils().isMdAsciiPunct;
        var QUOTE_TEST_RE = /['"]/;
        var QUOTE_RE = /['"]/g;
        var APOSTROPHE = "";
        function replaceAt(str, index, ch) {
            return str.substr(0, index) + ch + str.substr(index + 1);
        }
        function process_inlines(tokens, state) {
            var i, token, text2, t, pos, max2, thisLevel, item2, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
            stack = [];
            for(i = 0; i < tokens.length; i++){
                token = tokens[i];
                thisLevel = tokens[i].level;
                for(j = stack.length - 1; j >= 0; j--){
                    if (stack[j].level <= thisLevel) {
                        break;
                    }
                }
                stack.length = j + 1;
                if (token.type !== "text") {
                    continue;
                }
                text2 = token.content;
                pos = 0;
                max2 = text2.length;
                OUTER: while(pos < max2){
                    QUOTE_RE.lastIndex = pos;
                    t = QUOTE_RE.exec(text2);
                    if (!t) {
                        break;
                    }
                    canOpen = canClose = true;
                    pos = t.index + 1;
                    isSingle = t[0] === "'";
                    lastChar = 32;
                    if (t.index - 1 >= 0) {
                        lastChar = text2.charCodeAt(t.index - 1);
                    } else {
                        for(j = i - 1; j >= 0; j--){
                            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak") break;
                            if (!tokens[j].content) continue;
                            lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
                            break;
                        }
                    }
                    nextChar = 32;
                    if (pos < max2) {
                        nextChar = text2.charCodeAt(pos);
                    } else {
                        for(j = i + 1; j < tokens.length; j++){
                            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak") break;
                            if (!tokens[j].content) continue;
                            nextChar = tokens[j].content.charCodeAt(0);
                            break;
                        }
                    }
                    isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
                    isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
                    isLastWhiteSpace = isWhiteSpace(lastChar);
                    isNextWhiteSpace = isWhiteSpace(nextChar);
                    if (isNextWhiteSpace) {
                        canOpen = false;
                    } else if (isNextPunctChar) {
                        if (!(isLastWhiteSpace || isLastPunctChar)) {
                            canOpen = false;
                        }
                    }
                    if (isLastWhiteSpace) {
                        canClose = false;
                    } else if (isLastPunctChar) {
                        if (!(isNextWhiteSpace || isNextPunctChar)) {
                            canClose = false;
                        }
                    }
                    if (nextChar === 34 && t[0] === '"') {
                        if (lastChar >= 48 && lastChar <= 57) {
                            canClose = canOpen = false;
                        }
                    }
                    if (canOpen && canClose) {
                        canOpen = isLastPunctChar;
                        canClose = isNextPunctChar;
                    }
                    if (!canOpen && !canClose) {
                        if (isSingle) {
                            token.content = replaceAt(token.content, t.index, APOSTROPHE);
                        }
                        continue;
                    }
                    if (canClose) {
                        for(j = stack.length - 1; j >= 0; j--){
                            item2 = stack[j];
                            if (stack[j].level < thisLevel) {
                                break;
                            }
                            if (item2.single === isSingle && stack[j].level === thisLevel) {
                                item2 = stack[j];
                                if (isSingle) {
                                    openQuote = state.md.options.quotes[2];
                                    closeQuote = state.md.options.quotes[3];
                                } else {
                                    openQuote = state.md.options.quotes[0];
                                    closeQuote = state.md.options.quotes[1];
                                }
                                token.content = replaceAt(token.content, t.index, closeQuote);
                                tokens[item2.token].content = replaceAt(tokens[item2.token].content, item2.pos, openQuote);
                                pos += closeQuote.length - 1;
                                if (item2.token === i) {
                                    pos += openQuote.length - 1;
                                }
                                text2 = token.content;
                                max2 = text2.length;
                                stack.length = j;
                                continue OUTER;
                            }
                        }
                    }
                    if (canOpen) {
                        stack.push({
                            token: i,
                            pos: t.index,
                            single: isSingle,
                            level: thisLevel
                        });
                    } else if (canClose && isSingle) {
                        token.content = replaceAt(token.content, t.index, APOSTROPHE);
                    }
                }
            }
        }
        module2.exports = function smartquotes(state) {
            var blkIdx;
            if (!state.md.options.typographer) {
                return;
            }
            for(blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--){
                if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
                    continue;
                }
                process_inlines(state.tokens[blkIdx].children, state);
            }
        };
    }
});
// node_modules/markdown-it/lib/token.js
var require_token = __commonJS({
    "node_modules/markdown-it/lib/token.js" (exports1, module2) {
        "use strict";
        function Token(type, tag, nesting) {
            this.type = type;
            this.tag = tag;
            this.attrs = null;
            this.map = null;
            this.nesting = nesting;
            this.level = 0;
            this.children = null;
            this.content = "";
            this.markup = "";
            this.info = "";
            this.meta = null;
            this.block = false;
            this.hidden = false;
        }
        Token.prototype.attrIndex = function attrIndex(name) {
            var attrs, i, len;
            if (!this.attrs) {
                return -1;
            }
            attrs = this.attrs;
            for(i = 0, len = attrs.length; i < len; i++){
                if (attrs[i][0] === name) {
                    return i;
                }
            }
            return -1;
        };
        Token.prototype.attrPush = function attrPush(attrData) {
            if (this.attrs) {
                this.attrs.push(attrData);
            } else {
                this.attrs = [
                    attrData
                ];
            }
        };
        Token.prototype.attrSet = function attrSet(name, value) {
            var idx = this.attrIndex(name), attrData = [
                name,
                value
            ];
            if (idx < 0) {
                this.attrPush(attrData);
            } else {
                this.attrs[idx] = attrData;
            }
        };
        Token.prototype.attrGet = function attrGet(name) {
            var idx = this.attrIndex(name), value = null;
            if (idx >= 0) {
                value = this.attrs[idx][1];
            }
            return value;
        };
        Token.prototype.attrJoin = function attrJoin(name, value) {
            var idx = this.attrIndex(name);
            if (idx < 0) {
                this.attrPush([
                    name,
                    value
                ]);
            } else {
                this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
            }
        };
        module2.exports = Token;
    }
});
// node_modules/markdown-it/lib/rules_core/state_core.js
var require_state_core = __commonJS({
    "node_modules/markdown-it/lib/rules_core/state_core.js" (exports1, module2) {
        "use strict";
        var Token = require_token();
        function StateCore(src, md, env) {
            this.src = src;
            this.env = env;
            this.tokens = [];
            this.inlineMode = false;
            this.md = md;
        }
        StateCore.prototype.Token = Token;
        module2.exports = StateCore;
    }
});
// node_modules/markdown-it/lib/parser_core.js
var require_parser_core = __commonJS({
    "node_modules/markdown-it/lib/parser_core.js" (exports1, module2) {
        "use strict";
        var Ruler = require_ruler();
        var _rules = [
            [
                "normalize",
                require_normalize()
            ],
            [
                "block",
                require_block()
            ],
            [
                "inline",
                require_inline()
            ],
            [
                "linkify",
                require_linkify()
            ],
            [
                "replacements",
                require_replacements()
            ],
            [
                "smartquotes",
                require_smartquotes()
            ]
        ];
        function Core() {
            this.ruler = new Ruler();
            for(var i = 0; i < _rules.length; i++){
                this.ruler.push(_rules[i][0], _rules[i][1]);
            }
        }
        Core.prototype.process = function(state) {
            var i, l, rules;
            rules = this.ruler.getRules("");
            for(i = 0, l = rules.length; i < l; i++){
                rules[i](state);
            }
        };
        Core.prototype.State = require_state_core();
        module2.exports = Core;
    }
});
// node_modules/markdown-it/lib/rules_block/table.js
var require_table = __commonJS({
    "node_modules/markdown-it/lib/rules_block/table.js" (exports1, module2) {
        "use strict";
        var isSpace = require_utils().isSpace;
        function getLine2(state, line) {
            var pos = state.bMarks[line] + state.tShift[line], max2 = state.eMarks[line];
            return state.src.substr(pos, max2 - pos);
        }
        function escapedSplit(str) {
            var result = [], pos = 0, max2 = str.length, ch, isEscaped = false, lastPos = 0, current = "";
            ch = str.charCodeAt(pos);
            while(pos < max2){
                if (ch === 124) {
                    if (!isEscaped) {
                        result.push(current + str.substring(lastPos, pos));
                        current = "";
                        lastPos = pos + 1;
                    } else {
                        current += str.substring(lastPos, pos - 1);
                        lastPos = pos;
                    }
                }
                isEscaped = ch === 92;
                pos++;
                ch = str.charCodeAt(pos);
            }
            result.push(current + str.substring(lastPos));
            return result;
        }
        module2.exports = function table3(state, startLine, endLine, silent) {
            var ch, lineText, pos, i, l, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
            if (startLine + 2 > endLine) {
                return false;
            }
            nextLine = startLine + 1;
            if (state.sCount[nextLine] < state.blkIndent) {
                return false;
            }
            if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent >= 4) {
                return false;
            }
            pos = state.bMarks[nextLine] + state.tShift[nextLine];
            if (pos >= state.eMarks[nextLine]) {
                return false;
            }
            firstCh = state.src.charCodeAt(pos++);
            if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
                return false;
            }
            if (pos >= state.eMarks[nextLine]) {
                return false;
            }
            secondCh = state.src.charCodeAt(pos++);
            if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
                return false;
            }
            if (firstCh === 45 && isSpace(secondCh)) {
                return false;
            }
            while(pos < state.eMarks[nextLine]){
                ch = state.src.charCodeAt(pos);
                if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
                    return false;
                }
                pos++;
            }
            lineText = getLine2(state, startLine + 1);
            columns = lineText.split("|");
            aligns = [];
            for(i = 0; i < columns.length; i++){
                t = columns[i].trim();
                if (!t) {
                    if (i === 0 || i === columns.length - 1) {
                        continue;
                    } else {
                        return false;
                    }
                }
                if (!/^:?-+:?$/.test(t)) {
                    return false;
                }
                if (t.charCodeAt(t.length - 1) === 58) {
                    aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
                } else if (t.charCodeAt(0) === 58) {
                    aligns.push("left");
                } else {
                    aligns.push("");
                }
            }
            lineText = getLine2(state, startLine).trim();
            if (lineText.indexOf("|") === -1) {
                return false;
            }
            if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
                return false;
            }
            columns = escapedSplit(lineText);
            if (columns.length && columns[0] === "") columns.shift();
            if (columns.length && columns[columns.length - 1] === "") columns.pop();
            columnCount = columns.length;
            if (columnCount === 0 || columnCount !== aligns.length) {
                return false;
            }
            if (silent) {
                return true;
            }
            oldParentType = state.parentType;
            state.parentType = "table";
            terminatorRules = state.md.block.ruler.getRules("blockquote");
            token = state.push("table_open", "table", 1);
            token.map = tableLines = [
                startLine,
                0
            ];
            token = state.push("thead_open", "thead", 1);
            token.map = [
                startLine,
                startLine + 1
            ];
            token = state.push("tr_open", "tr", 1);
            token.map = [
                startLine,
                startLine + 1
            ];
            for(i = 0; i < columns.length; i++){
                token = state.push("th_open", "th", 1);
                if (aligns[i]) {
                    token.attrs = [
                        [
                            "style",
                            "text-align:" + aligns[i]
                        ]
                    ];
                }
                token = state.push("inline", "", 0);
                token.content = columns[i].trim();
                token.children = [];
                token = state.push("th_close", "th", -1);
            }
            token = state.push("tr_close", "tr", -1);
            token = state.push("thead_close", "thead", -1);
            for(nextLine = startLine + 2; nextLine < endLine; nextLine++){
                if (state.sCount[nextLine] < state.blkIndent) {
                    break;
                }
                terminate = false;
                for(i = 0, l = terminatorRules.length; i < l; i++){
                    if (terminatorRules[i](state, nextLine, endLine, true)) {
                        terminate = true;
                        break;
                    }
                }
                if (terminate) {
                    break;
                }
                lineText = getLine2(state, nextLine).trim();
                if (!lineText) {
                    break;
                }
                if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent >= 4) {
                    break;
                }
                columns = escapedSplit(lineText);
                if (columns.length && columns[0] === "") columns.shift();
                if (columns.length && columns[columns.length - 1] === "") columns.pop();
                if (nextLine === startLine + 2) {
                    token = state.push("tbody_open", "tbody", 1);
                    token.map = tbodyLines = [
                        startLine + 2,
                        0
                    ];
                }
                token = state.push("tr_open", "tr", 1);
                token.map = [
                    nextLine,
                    nextLine + 1
                ];
                for(i = 0; i < columnCount; i++){
                    token = state.push("td_open", "td", 1);
                    if (aligns[i]) {
                        token.attrs = [
                            [
                                "style",
                                "text-align:" + aligns[i]
                            ]
                        ];
                    }
                    token = state.push("inline", "", 0);
                    token.content = columns[i] ? columns[i].trim() : "";
                    token.children = [];
                    token = state.push("td_close", "td", -1);
                }
                token = state.push("tr_close", "tr", -1);
            }
            if (tbodyLines) {
                token = state.push("tbody_close", "tbody", -1);
                tbodyLines[1] = nextLine;
            }
            token = state.push("table_close", "table", -1);
            tableLines[1] = nextLine;
            state.parentType = oldParentType;
            state.line = nextLine;
            return true;
        };
    }
});
// node_modules/markdown-it/lib/rules_block/code.js
var require_code = __commonJS({
    "node_modules/markdown-it/lib/rules_block/code.js" (exports1, module2) {
        "use strict";
        module2.exports = function code2(state, startLine, endLine) {
            if (state.md.options.allowIndentation) {
                return false;
            }
            var nextLine, last, token;
            if (state.sCount[startLine] - state.blkIndent < 4) {
                return false;
            }
            last = nextLine = startLine + 1;
            while(nextLine < endLine){
                if (state.isEmpty(nextLine)) {
                    nextLine++;
                    continue;
                }
                if (state.sCount[nextLine] - state.blkIndent >= 4) {
                    nextLine++;
                    last = nextLine;
                    continue;
                }
                break;
            }
            state.line = last;
            token = state.push("code_block", "code", 0);
            token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
            token.map = [
                startLine,
                state.line
            ];
            return true;
        };
    }
});
// node_modules/markdown-it/lib/rules_block/fence.js
var require_fence = __commonJS({
    "node_modules/markdown-it/lib/rules_block/fence.js" (exports1, module2) {
        "use strict";
        module2.exports = function fence3(state, startLine, endLine, silent) {
            var marker, len, params, nextLine, mem, token, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
            if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
                return false;
            }
            if (pos + 3 > max2) {
                return false;
            }
            marker = state.src.charCodeAt(pos);
            if (marker !== 126 && marker !== 96) {
                return false;
            }
            mem = pos;
            pos = state.skipChars(pos, marker);
            len = pos - mem;
            if (len < 3) {
                return false;
            }
            markup = state.src.slice(mem, pos);
            params = state.src.slice(pos, max2);
            if (marker === 96) {
                if (params.indexOf(String.fromCharCode(marker)) >= 0) {
                    return false;
                }
            }
            if (silent) {
                return true;
            }
            nextLine = startLine;
            for(;;){
                nextLine++;
                if (nextLine >= endLine) {
                    break;
                }
                pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
                max2 = state.eMarks[nextLine];
                if (pos < max2 && state.sCount[nextLine] < state.blkIndent) {
                    break;
                }
                if (state.src.charCodeAt(pos) !== marker) {
                    continue;
                }
                if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent >= 4) {
                    continue;
                }
                pos = state.skipChars(pos, marker);
                if (pos - mem < len) {
                    continue;
                }
                pos = state.skipSpaces(pos);
                if (pos < max2) {
                    continue;
                }
                haveEndMarker = true;
                break;
            }
            len = state.sCount[startLine];
            state.line = nextLine + (haveEndMarker ? 1 : 0);
            token = state.push("fence", "code", 0);
            token.info = params;
            token.content = state.getLines(startLine + 1, nextLine, len, true);
            token.markup = markup;
            token.map = [
                startLine,
                state.line
            ];
            return true;
        };
    }
});
// node_modules/markdown-it/lib/rules_block/blockquote.js
var require_blockquote = __commonJS({
    "node_modules/markdown-it/lib/rules_block/blockquote.js" (exports1, module2) {
        "use strict";
        var isSpace = require_utils().isSpace;
        module2.exports = function blockquote2(state, startLine, endLine, silent) {
            var adjustTab, ch, i, initial, l, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
            if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
                return false;
            }
            if (state.src.charCodeAt(pos++) !== 62) {
                return false;
            }
            if (silent) {
                return true;
            }
            initial = offset = state.sCount[startLine] + 1;
            if (state.src.charCodeAt(pos) === 32) {
                pos++;
                initial++;
                offset++;
                adjustTab = false;
                spaceAfterMarker = true;
            } else if (state.src.charCodeAt(pos) === 9) {
                spaceAfterMarker = true;
                if ((state.bsCount[startLine] + offset) % 4 === 3) {
                    pos++;
                    initial++;
                    offset++;
                    adjustTab = false;
                } else {
                    adjustTab = true;
                }
            } else {
                spaceAfterMarker = false;
            }
            oldBMarks = [
                state.bMarks[startLine]
            ];
            state.bMarks[startLine] = pos;
            while(pos < max2){
                ch = state.src.charCodeAt(pos);
                if (isSpace(ch)) {
                    if (ch === 9) {
                        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
                    } else {
                        offset++;
                    }
                } else {
                    break;
                }
                pos++;
            }
            oldBSCount = [
                state.bsCount[startLine]
            ];
            state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
            lastLineEmpty = pos >= max2;
            oldSCount = [
                state.sCount[startLine]
            ];
            state.sCount[startLine] = offset - initial;
            oldTShift = [
                state.tShift[startLine]
            ];
            state.tShift[startLine] = pos - state.bMarks[startLine];
            terminatorRules = state.md.block.ruler.getRules("blockquote");
            oldParentType = state.parentType;
            state.parentType = "blockquote";
            for(nextLine = startLine + 1; nextLine < endLine; nextLine++){
                isOutdented = state.sCount[nextLine] < state.blkIndent;
                pos = state.bMarks[nextLine] + state.tShift[nextLine];
                max2 = state.eMarks[nextLine];
                if (pos >= max2) {
                    break;
                }
                if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
                    initial = offset = state.sCount[nextLine] + 1;
                    if (state.src.charCodeAt(pos) === 32) {
                        pos++;
                        initial++;
                        offset++;
                        adjustTab = false;
                        spaceAfterMarker = true;
                    } else if (state.src.charCodeAt(pos) === 9) {
                        spaceAfterMarker = true;
                        if ((state.bsCount[nextLine] + offset) % 4 === 3) {
                            pos++;
                            initial++;
                            offset++;
                            adjustTab = false;
                        } else {
                            adjustTab = true;
                        }
                    } else {
                        spaceAfterMarker = false;
                    }
                    oldBMarks.push(state.bMarks[nextLine]);
                    state.bMarks[nextLine] = pos;
                    while(pos < max2){
                        ch = state.src.charCodeAt(pos);
                        if (isSpace(ch)) {
                            if (ch === 9) {
                                offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
                            } else {
                                offset++;
                            }
                        } else {
                            break;
                        }
                        pos++;
                    }
                    lastLineEmpty = pos >= max2;
                    oldBSCount.push(state.bsCount[nextLine]);
                    state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
                    oldSCount.push(state.sCount[nextLine]);
                    state.sCount[nextLine] = offset - initial;
                    oldTShift.push(state.tShift[nextLine]);
                    state.tShift[nextLine] = pos - state.bMarks[nextLine];
                    continue;
                }
                if (lastLineEmpty) {
                    break;
                }
                terminate = false;
                for(i = 0, l = terminatorRules.length; i < l; i++){
                    if (terminatorRules[i](state, nextLine, endLine, true)) {
                        terminate = true;
                        break;
                    }
                }
                if (terminate) {
                    state.lineMax = nextLine;
                    if (state.blkIndent !== 0) {
                        oldBMarks.push(state.bMarks[nextLine]);
                        oldBSCount.push(state.bsCount[nextLine]);
                        oldTShift.push(state.tShift[nextLine]);
                        oldSCount.push(state.sCount[nextLine]);
                        state.sCount[nextLine] -= state.blkIndent;
                    }
                    break;
                }
                oldBMarks.push(state.bMarks[nextLine]);
                oldBSCount.push(state.bsCount[nextLine]);
                oldTShift.push(state.tShift[nextLine]);
                oldSCount.push(state.sCount[nextLine]);
                state.sCount[nextLine] = -1;
            }
            oldIndent = state.blkIndent;
            state.blkIndent = 0;
            token = state.push("blockquote_open", "blockquote", 1);
            token.markup = ">";
            token.map = lines = [
                startLine,
                0
            ];
            state.md.block.tokenize(state, startLine, nextLine);
            token = state.push("blockquote_close", "blockquote", -1);
            token.markup = ">";
            state.lineMax = oldLineMax;
            state.parentType = oldParentType;
            lines[1] = state.line;
            for(i = 0; i < oldTShift.length; i++){
                state.bMarks[i + startLine] = oldBMarks[i];
                state.tShift[i + startLine] = oldTShift[i];
                state.sCount[i + startLine] = oldSCount[i];
                state.bsCount[i + startLine] = oldBSCount[i];
            }
            state.blkIndent = oldIndent;
            return true;
        };
    }
});
// node_modules/markdown-it/lib/rules_block/hr.js
var require_hr = __commonJS({
    "node_modules/markdown-it/lib/rules_block/hr.js" (exports1, module2) {
        "use strict";
        var isSpace = require_utils().isSpace;
        module2.exports = function hr2(state, startLine, endLine, silent) {
            var marker, cnt, ch, token, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
            if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
                return false;
            }
            marker = state.src.charCodeAt(pos++);
            if (marker !== 42 && marker !== 45 && marker !== 95) {
                return false;
            }
            cnt = 1;
            while(pos < max2){
                ch = state.src.charCodeAt(pos++);
                if (ch !== marker && !isSpace(ch)) {
                    return false;
                }
                if (ch === marker) {
                    cnt++;
                }
            }
            if (cnt < 3) {
                return false;
            }
            if (silent) {
                return true;
            }
            state.line = startLine + 1;
            token = state.push("hr", "hr", 0);
            token.map = [
                startLine,
                state.line
            ];
            token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
            return true;
        };
    }
});
// node_modules/markdown-it/lib/rules_block/list.js
var require_list = __commonJS({
    "node_modules/markdown-it/lib/rules_block/list.js" (exports1, module2) {
        "use strict";
        var isSpace = require_utils().isSpace;
        function skipBulletListMarker(state, startLine) {
            var marker, pos, max2, ch;
            pos = state.bMarks[startLine] + state.tShift[startLine];
            max2 = state.eMarks[startLine];
            marker = state.src.charCodeAt(pos++);
            if (marker !== 42 && marker !== 45 && marker !== 43) {
                return -1;
            }
            if (pos < max2) {
                ch = state.src.charCodeAt(pos);
                if (!isSpace(ch)) {
                    return -1;
                }
            }
            return pos;
        }
        function skipOrderedListMarker(state, startLine) {
            var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max2 = state.eMarks[startLine];
            if (pos + 1 >= max2) {
                return -1;
            }
            ch = state.src.charCodeAt(pos++);
            if (ch < 48 || ch > 57) {
                return -1;
            }
            for(;;){
                if (pos >= max2) {
                    return -1;
                }
                ch = state.src.charCodeAt(pos++);
                if (ch >= 48 && ch <= 57) {
                    if (pos - start >= 10) {
                        return -1;
                    }
                    continue;
                }
                if (ch === 41 || ch === 46) {
                    break;
                }
                return -1;
            }
            if (pos < max2) {
                ch = state.src.charCodeAt(pos);
                if (!isSpace(ch)) {
                    return -1;
                }
            }
            return pos;
        }
        function markTightParagraphs(state, idx) {
            var i, l, level = state.level + 2;
            for(i = idx + 2, l = state.tokens.length - 2; i < l; i++){
                if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
                    state.tokens[i + 2].hidden = true;
                    state.tokens[i].hidden = true;
                    i += 2;
                }
            }
        }
        module2.exports = function list2(state, startLine, endLine, silent) {
            var ch, contentStart, i, indent, indentAfterMarker, initial, isOrdered, itemLines, l, listLines, listTokIdx, markerCharCode, markerValue, max2, nextLine, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token, isTerminatingParagraph = false, tight = true;
            if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
                return false;
            }
            if (!state.md.options.allowIndentation && state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {
                return false;
            }
            if (silent && state.parentType === "paragraph") {
                if (state.sCount[startLine] >= state.blkIndent) {
                    isTerminatingParagraph = true;
                }
            }
            if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
                isOrdered = true;
                start = state.bMarks[startLine] + state.tShift[startLine];
                markerValue = Number(state.src.slice(start, posAfterMarker - 1));
                if (isTerminatingParagraph && markerValue !== 1) return false;
            } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
                isOrdered = false;
            } else {
                return false;
            }
            if (isTerminatingParagraph) {
                if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
            }
            markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
            if (silent) {
                return true;
            }
            listTokIdx = state.tokens.length;
            if (isOrdered) {
                token = state.push("ordered_list_open", "ol", 1);
                if (markerValue !== 1) {
                    token.attrs = [
                        [
                            "start",
                            markerValue
                        ]
                    ];
                }
            } else {
                token = state.push("bullet_list_open", "ul", 1);
            }
            token.map = listLines = [
                startLine,
                0
            ];
            token.markup = String.fromCharCode(markerCharCode);
            nextLine = startLine;
            prevEmptyEnd = false;
            terminatorRules = state.md.block.ruler.getRules("list");
            oldParentType = state.parentType;
            state.parentType = "list";
            while(nextLine < endLine){
                pos = posAfterMarker;
                max2 = state.eMarks[nextLine];
                initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);
                while(pos < max2){
                    ch = state.src.charCodeAt(pos);
                    if (ch === 9) {
                        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
                    } else if (ch === 32) {
                        offset++;
                    } else {
                        break;
                    }
                    pos++;
                }
                contentStart = pos;
                if (contentStart >= max2) {
                    indentAfterMarker = 1;
                } else {
                    indentAfterMarker = offset - initial;
                }
                if (!state.md.options.allowIndentation && indentAfterMarker > 4) {
                    indentAfterMarker = 1;
                }
                indent = initial + indentAfterMarker;
                token = state.push("list_item_open", "li", 1);
                token.markup = String.fromCharCode(markerCharCode);
                token.map = itemLines = [
                    startLine,
                    0
                ];
                if (isOrdered) {
                    token.info = state.src.slice(start, posAfterMarker - 1);
                }
                oldTight = state.tight;
                oldTShift = state.tShift[startLine];
                oldSCount = state.sCount[startLine];
                oldListIndent = state.listIndent;
                state.listIndent = state.blkIndent;
                state.blkIndent = indent;
                state.tight = true;
                state.tShift[startLine] = contentStart - state.bMarks[startLine];
                state.sCount[startLine] = offset;
                if (contentStart >= max2 && state.isEmpty(startLine + 1)) {
                    state.line = Math.min(state.line + 2, endLine);
                } else {
                    state.md.block.tokenize(state, startLine, endLine, true);
                }
                if (!state.tight || prevEmptyEnd) {
                    tight = false;
                }
                prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
                state.blkIndent = state.listIndent;
                state.listIndent = oldListIndent;
                state.tShift[startLine] = oldTShift;
                state.sCount[startLine] = oldSCount;
                state.tight = oldTight;
                token = state.push("list_item_close", "li", -1);
                token.markup = String.fromCharCode(markerCharCode);
                nextLine = startLine = state.line;
                itemLines[1] = nextLine;
                contentStart = state.bMarks[startLine];
                if (nextLine >= endLine) {
                    break;
                }
                if (state.sCount[nextLine] < state.blkIndent) {
                    break;
                }
                if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
                    break;
                }
                terminate = false;
                for(i = 0, l = terminatorRules.length; i < l; i++){
                    if (terminatorRules[i](state, nextLine, endLine, true)) {
                        terminate = true;
                        break;
                    }
                }
                if (terminate) {
                    break;
                }
                if (isOrdered) {
                    posAfterMarker = skipOrderedListMarker(state, nextLine);
                    if (posAfterMarker < 0) {
                        break;
                    }
                    start = state.bMarks[nextLine] + state.tShift[nextLine];
                } else {
                    posAfterMarker = skipBulletListMarker(state, nextLine);
                    if (posAfterMarker < 0) {
                        break;
                    }
                }
                if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
                    break;
                }
            }
            if (isOrdered) {
                token = state.push("ordered_list_close", "ol", -1);
            } else {
                token = state.push("bullet_list_close", "ul", -1);
            }
            token.markup = String.fromCharCode(markerCharCode);
            listLines[1] = nextLine;
            state.line = nextLine;
            state.parentType = oldParentType;
            if (tight) {
                markTightParagraphs(state, listTokIdx);
            }
            return true;
        };
    }
});
// node_modules/markdown-it/lib/rules_block/reference.js
var require_reference = __commonJS({
    "node_modules/markdown-it/lib/rules_block/reference.js" (exports1, module2) {
        "use strict";
        var normalizeReference = require_utils().normalizeReference;
        var isSpace = require_utils().isSpace;
        module2.exports = function reference(state, startLine, _endLine, silent) {
            var ch, destEndPos, destEndLineNo, endLine, href, i, l, label, labelEnd, oldParentType, res, start, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine], nextLine = startLine + 1;
            if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
                return false;
            }
            if (state.src.charCodeAt(pos) !== 91) {
                return false;
            }
            while(++pos < max2){
                if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
                    if (pos + 1 === max2) {
                        return false;
                    }
                    if (state.src.charCodeAt(pos + 1) !== 58) {
                        return false;
                    }
                    break;
                }
            }
            endLine = state.lineMax;
            terminatorRules = state.md.block.ruler.getRules("reference");
            oldParentType = state.parentType;
            state.parentType = "reference";
            for(; nextLine < endLine && !state.isEmpty(nextLine); nextLine++){
                if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent > 3) {
                    continue;
                }
                if (state.sCount[nextLine] < 0) {
                    continue;
                }
                terminate = false;
                for(i = 0, l = terminatorRules.length; i < l; i++){
                    if (terminatorRules[i](state, nextLine, endLine, true)) {
                        terminate = true;
                        break;
                    }
                }
                if (terminate) {
                    break;
                }
            }
            str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
            max2 = str.length;
            for(pos = 1; pos < max2; pos++){
                ch = str.charCodeAt(pos);
                if (ch === 91) {
                    return false;
                } else if (ch === 93) {
                    labelEnd = pos;
                    break;
                } else if (ch === 10) {
                    lines++;
                } else if (ch === 92) {
                    pos++;
                    if (pos < max2 && str.charCodeAt(pos) === 10) {
                        lines++;
                    }
                }
            }
            if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
                return false;
            }
            for(pos = labelEnd + 2; pos < max2; pos++){
                ch = str.charCodeAt(pos);
                if (ch === 10) {
                    lines++;
                } else if (isSpace(ch)) {} else {
                    break;
                }
            }
            res = state.md.helpers.parseLinkDestination(str, pos, max2);
            if (!res.ok) {
                return false;
            }
            href = state.md.normalizeLink(res.str);
            if (!state.md.validateLink(href)) {
                return false;
            }
            pos = res.pos;
            lines += res.lines;
            destEndPos = pos;
            destEndLineNo = lines;
            start = pos;
            for(; pos < max2; pos++){
                ch = str.charCodeAt(pos);
                if (ch === 10) {
                    lines++;
                } else if (isSpace(ch)) {} else {
                    break;
                }
            }
            res = state.md.helpers.parseLinkTitle(str, pos, max2);
            if (pos < max2 && start !== pos && res.ok) {
                title = res.str;
                pos = res.pos;
                lines += res.lines;
            } else {
                title = "";
                pos = destEndPos;
                lines = destEndLineNo;
            }
            while(pos < max2){
                ch = str.charCodeAt(pos);
                if (!isSpace(ch)) {
                    break;
                }
                pos++;
            }
            if (pos < max2 && str.charCodeAt(pos) !== 10) {
                if (title) {
                    title = "";
                    pos = destEndPos;
                    lines = destEndLineNo;
                    while(pos < max2){
                        ch = str.charCodeAt(pos);
                        if (!isSpace(ch)) {
                            break;
                        }
                        pos++;
                    }
                }
            }
            if (pos < max2 && str.charCodeAt(pos) !== 10) {
                return false;
            }
            label = normalizeReference(str.slice(1, labelEnd));
            if (!label) {
                return false;
            }
            if (silent) {
                return true;
            }
            if (typeof state.env.references === "undefined") {
                state.env.references = {};
            }
            if (typeof state.env.references[label] === "undefined") {
                state.env.references[label] = {
                    title,
                    href
                };
            }
            state.parentType = oldParentType;
            state.line = startLine + lines + 1;
            return true;
        };
    }
});
// node_modules/markdown-it/lib/common/html_blocks.js
var require_html_blocks = __commonJS({
    "node_modules/markdown-it/lib/common/html_blocks.js" (exports1, module2) {
        "use strict";
        module2.exports = [
            "address",
            "article",
            "aside",
            "base",
            "basefont",
            "blockquote",
            "body",
            "caption",
            "center",
            "col",
            "colgroup",
            "dd",
            "details",
            "dialog",
            "dir",
            "div",
            "dl",
            "dt",
            "fieldset",
            "figcaption",
            "figure",
            "footer",
            "form",
            "frame",
            "frameset",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "head",
            "header",
            "hr",
            "html",
            "iframe",
            "legend",
            "li",
            "link",
            "main",
            "menu",
            "menuitem",
            "nav",
            "noframes",
            "ol",
            "optgroup",
            "option",
            "p",
            "param",
            "section",
            "source",
            "summary",
            "table",
            "tbody",
            "td",
            "tfoot",
            "th",
            "thead",
            "title",
            "tr",
            "track",
            "ul"
        ];
    }
});
// node_modules/markdown-it/lib/common/html_re.js
var require_html_re = __commonJS({
    "node_modules/markdown-it/lib/common/html_re.js" (exports1, module2) {
        "use strict";
        var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
        var unquoted = "[^\"'=<>`\\x00-\\x20]+";
        var single_quoted = "'[^']*'";
        var double_quoted = '"[^"]*"';
        var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
        var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
        var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
        var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
        var comment2 = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
        var processing = "<[?][\\s\\S]*?[?]>";
        var declaration = "<![A-Z]+\\s+[^>]*>";
        var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
        var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment2 + "|" + processing + "|" + declaration + "|" + cdata + ")");
        var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
        module2.exports.HTML_TAG_RE = HTML_TAG_RE;
        module2.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;
    }
});
// node_modules/markdown-it/lib/rules_block/html_block.js
var require_html_block = __commonJS({
    "node_modules/markdown-it/lib/rules_block/html_block.js" (exports1, module2) {
        "use strict";
        var block_names = require_html_blocks();
        var HTML_OPEN_CLOSE_TAG_RE = require_html_re().HTML_OPEN_CLOSE_TAG_RE;
        var HTML_SEQUENCES = [
            [
                /^<(script|pre|style|textarea)(?=(\s|>|$))/i,
                /<\/(script|pre|style|textarea)>/i,
                true
            ],
            [
                /^<!--/,
                /-->/,
                true
            ],
            [
                /^<\?/,
                /\?>/,
                true
            ],
            [
                /^<![A-Z]/,
                />/,
                true
            ],
            [
                /^<!\[CDATA\[/,
                /\]\]>/,
                true
            ],
            [
                new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"),
                /^$/,
                true
            ],
            [
                new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"),
                /^$/,
                false
            ]
        ];
        module2.exports = function html_block(state, startLine, endLine, silent) {
            var i, nextLine, token, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
            if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
                return false;
            }
            if (!state.md.options.html) {
                return false;
            }
            if (state.src.charCodeAt(pos) !== 60) {
                return false;
            }
            lineText = state.src.slice(pos, max2);
            for(i = 0; i < HTML_SEQUENCES.length; i++){
                if (HTML_SEQUENCES[i][0].test(lineText)) {
                    break;
                }
            }
            if (i === HTML_SEQUENCES.length) {
                return false;
            }
            if (silent) {
                return HTML_SEQUENCES[i][2];
            }
            nextLine = startLine + 1;
            if (!HTML_SEQUENCES[i][1].test(lineText)) {
                for(; nextLine < endLine; nextLine++){
                    if (state.sCount[nextLine] < state.blkIndent) {
                        break;
                    }
                    pos = state.bMarks[nextLine] + state.tShift[nextLine];
                    max2 = state.eMarks[nextLine];
                    lineText = state.src.slice(pos, max2);
                    if (HTML_SEQUENCES[i][1].test(lineText)) {
                        if (lineText.length !== 0) {
                            nextLine++;
                        }
                        break;
                    }
                }
            }
            state.line = nextLine;
            token = state.push("html_block", "", 0);
            token.map = [
                startLine,
                nextLine
            ];
            token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
            return true;
        };
    }
});
// node_modules/markdown-it/lib/rules_block/heading.js
var require_heading = __commonJS({
    "node_modules/markdown-it/lib/rules_block/heading.js" (exports1, module2) {
        "use strict";
        var isSpace = require_utils().isSpace;
        module2.exports = function heading2(state, startLine, endLine, silent) {
            var ch, level, tmp, token, pos = state.bMarks[startLine] + state.tShift[startLine], max2 = state.eMarks[startLine];
            if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
                return false;
            }
            ch = state.src.charCodeAt(pos);
            if (ch !== 35 || pos >= max2) {
                return false;
            }
            level = 1;
            ch = state.src.charCodeAt(++pos);
            while(ch === 35 && pos < max2 && level <= 6){
                level++;
                ch = state.src.charCodeAt(++pos);
            }
            if (level > 6 || pos < max2 && !isSpace(ch)) {
                return false;
            }
            if (silent) {
                return true;
            }
            max2 = state.skipSpacesBack(max2, pos);
            tmp = state.skipCharsBack(max2, 35, pos);
            if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
                max2 = tmp;
            }
            state.line = startLine + 1;
            token = state.push("heading_open", "h" + String(level), 1);
            token.markup = "########".slice(0, level);
            token.map = [
                startLine,
                state.line
            ];
            token = state.push("inline", "", 0);
            token.content = state.src.slice(pos, max2).trim();
            token.map = [
                startLine,
                state.line
            ];
            token.children = [];
            token = state.push("heading_close", "h" + String(level), -1);
            token.markup = "########".slice(0, level);
            return true;
        };
    }
});
// node_modules/markdown-it/lib/rules_block/lheading.js
var require_lheading = __commonJS({
    "node_modules/markdown-it/lib/rules_block/lheading.js" (exports1, module2) {
        "use strict";
        module2.exports = function lheading(state, startLine, endLine) {
            var content, terminate, i, l, token, pos, max2, level, marker, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
            if (!state.md.options.allowIndentation && state.sCount[startLine] - state.blkIndent >= 4) {
                return false;
            }
            oldParentType = state.parentType;
            state.parentType = "paragraph";
            for(; nextLine < endLine && !state.isEmpty(nextLine); nextLine++){
                if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent > 3) {
                    continue;
                }
                if (state.sCount[nextLine] >= state.blkIndent) {
                    pos = state.bMarks[nextLine] + state.tShift[nextLine];
                    max2 = state.eMarks[nextLine];
                    if (pos < max2) {
                        marker = state.src.charCodeAt(pos);
                        if (marker === 45 || marker === 61) {
                            pos = state.skipChars(pos, marker);
                            pos = state.skipSpaces(pos);
                            if (pos >= max2) {
                                level = marker === 61 ? 1 : 2;
                                break;
                            }
                        }
                    }
                }
                if (state.sCount[nextLine] < 0) {
                    continue;
                }
                terminate = false;
                for(i = 0, l = terminatorRules.length; i < l; i++){
                    if (terminatorRules[i](state, nextLine, endLine, true)) {
                        terminate = true;
                        break;
                    }
                }
                if (terminate) {
                    break;
                }
            }
            if (!level) {
                return false;
            }
            content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
            state.line = nextLine + 1;
            token = state.push("heading_open", "h" + String(level), 1);
            token.markup = String.fromCharCode(marker);
            token.map = [
                startLine,
                state.line
            ];
            token = state.push("inline", "", 0);
            token.content = content;
            token.map = [
                startLine,
                state.line - 1
            ];
            token.children = [];
            token = state.push("heading_close", "h" + String(level), -1);
            token.markup = String.fromCharCode(marker);
            state.parentType = oldParentType;
            return true;
        };
    }
});
// node_modules/markdown-it/lib/rules_block/paragraph.js
var require_paragraph = __commonJS({
    "node_modules/markdown-it/lib/rules_block/paragraph.js" (exports1, module2) {
        "use strict";
        module2.exports = function paragraph2(state, startLine) {
            var content, terminate, i, l, token, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph"), endLine = state.lineMax;
            oldParentType = state.parentType;
            state.parentType = "paragraph";
            for(; nextLine < endLine && !state.isEmpty(nextLine); nextLine++){
                if (!state.md.options.allowIndentation && state.sCount[nextLine] - state.blkIndent > 3) {
                    continue;
                }
                if (state.sCount[nextLine] < 0) {
                    continue;
                }
                terminate = false;
                for(i = 0, l = terminatorRules.length; i < l; i++){
                    if (terminatorRules[i](state, nextLine, endLine, true)) {
                        terminate = true;
                        break;
                    }
                }
                if (terminate) {
                    break;
                }
            }
            content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
            state.line = nextLine;
            token = state.push("paragraph_open", "p", 1);
            token.map = [
                startLine,
                state.line
            ];
            token = state.push("inline", "", 0);
            token.content = content;
            token.map = [
                startLine,
                state.line
            ];
            token.children = [];
            token = state.push("paragraph_close", "p", -1);
            state.parentType = oldParentType;
            return true;
        };
    }
});
// node_modules/markdown-it/lib/rules_block/state_block.js
var require_state_block = __commonJS({
    "node_modules/markdown-it/lib/rules_block/state_block.js" (exports1, module2) {
        "use strict";
        var Token = require_token();
        var isSpace = require_utils().isSpace;
        function StateBlock(src, md, env, tokens) {
            var ch, s2, start, pos, len, indent, offset, indent_found;
            this.src = src;
            this.md = md;
            this.env = env;
            this.tokens = tokens;
            this.bMarks = [];
            this.eMarks = [];
            this.tShift = [];
            this.sCount = [];
            this.bsCount = [];
            this.blkIndent = 0;
            this.line = 0;
            this.lineMax = 0;
            this.tight = false;
            this.ddIndent = -1;
            this.listIndent = -1;
            this.parentType = "root";
            this.level = 0;
            this.result = "";
            s2 = this.src;
            indent_found = false;
            for(start = pos = indent = offset = 0, len = s2.length; pos < len; pos++){
                ch = s2.charCodeAt(pos);
                if (!indent_found) {
                    if (isSpace(ch)) {
                        indent++;
                        if (ch === 9) {
                            offset += 4 - offset % 4;
                        } else {
                            offset++;
                        }
                        continue;
                    } else {
                        indent_found = true;
                    }
                }
                if (ch === 10 || pos === len - 1) {
                    if (ch !== 10) {
                        pos++;
                    }
                    this.bMarks.push(start);
                    this.eMarks.push(pos);
                    this.tShift.push(indent);
                    this.sCount.push(offset);
                    this.bsCount.push(0);
                    indent_found = false;
                    indent = 0;
                    offset = 0;
                    start = pos + 1;
                }
            }
            this.bMarks.push(s2.length);
            this.eMarks.push(s2.length);
            this.tShift.push(0);
            this.sCount.push(0);
            this.bsCount.push(0);
            this.lineMax = this.bMarks.length - 1;
        }
        StateBlock.prototype.push = function(type, tag, nesting) {
            var token = new Token(type, tag, nesting);
            token.block = true;
            if (nesting < 0) this.level--;
            token.level = this.level;
            if (nesting > 0) this.level++;
            this.tokens.push(token);
            return token;
        };
        StateBlock.prototype.isEmpty = function isEmpty(line) {
            return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
        };
        StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
            for(var max2 = this.lineMax; from < max2; from++){
                if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
                    break;
                }
            }
            return from;
        };
        StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
            var ch;
            for(var max2 = this.src.length; pos < max2; pos++){
                ch = this.src.charCodeAt(pos);
                if (!isSpace(ch)) {
                    break;
                }
            }
            return pos;
        };
        StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
            if (pos <= min) {
                return pos;
            }
            while(pos > min){
                if (!isSpace(this.src.charCodeAt(--pos))) {
                    return pos + 1;
                }
            }
            return pos;
        };
        StateBlock.prototype.skipChars = function skipChars(pos, code2) {
            for(var max2 = this.src.length; pos < max2; pos++){
                if (this.src.charCodeAt(pos) !== code2) {
                    break;
                }
            }
            return pos;
        };
        StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min) {
            if (pos <= min) {
                return pos;
            }
            while(pos > min){
                if (code2 !== this.src.charCodeAt(--pos)) {
                    return pos + 1;
                }
            }
            return pos;
        };
        StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
            var i, lineIndent, ch, first, last, queue, lineStart, line = begin;
            if (begin >= end) {
                return "";
            }
            queue = new Array(end - begin);
            for(i = 0; line < end; line++, i++){
                lineIndent = 0;
                lineStart = first = this.bMarks[line];
                if (line + 1 < end || keepLastLF) {
                    last = this.eMarks[line] + 1;
                } else {
                    last = this.eMarks[line];
                }
                while(first < last && lineIndent < indent){
                    ch = this.src.charCodeAt(first);
                    if (isSpace(ch)) {
                        if (ch === 9) {
                            lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
                        } else {
                            lineIndent++;
                        }
                    } else if (first - lineStart < this.tShift[line]) {
                        lineIndent++;
                    } else {
                        break;
                    }
                    first++;
                }
                if (lineIndent > indent) {
                    queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
                } else {
                    queue[i] = this.src.slice(first, last);
                }
            }
            return queue.join("");
        };
        StateBlock.prototype.Token = Token;
        module2.exports = StateBlock;
    }
});
// node_modules/markdown-it/lib/parser_block.js
var require_parser_block = __commonJS({
    "node_modules/markdown-it/lib/parser_block.js" (exports1, module2) {
        "use strict";
        var Ruler = require_ruler();
        var _rules = [
            [
                "table",
                require_table(),
                [
                    "paragraph",
                    "reference"
                ]
            ],
            [
                "code",
                require_code()
            ],
            [
                "fence",
                require_fence(),
                [
                    "paragraph",
                    "reference",
                    "blockquote",
                    "list"
                ]
            ],
            [
                "blockquote",
                require_blockquote(),
                [
                    "paragraph",
                    "reference",
                    "blockquote",
                    "list"
                ]
            ],
            [
                "hr",
                require_hr(),
                [
                    "paragraph",
                    "reference",
                    "blockquote",
                    "list"
                ]
            ],
            [
                "list",
                require_list(),
                [
                    "paragraph",
                    "reference",
                    "blockquote"
                ]
            ],
            [
                "reference",
                require_reference()
            ],
            [
                "html_block",
                require_html_block(),
                [
                    "paragraph",
                    "reference",
                    "blockquote"
                ]
            ],
            [
                "heading",
                require_heading(),
                [
                    "paragraph",
                    "reference",
                    "blockquote"
                ]
            ],
            [
                "lheading",
                require_lheading()
            ],
            [
                "paragraph",
                require_paragraph()
            ]
        ];
        function ParserBlock() {
            this.ruler = new Ruler();
            for(var i = 0; i < _rules.length; i++){
                this.ruler.push(_rules[i][0], _rules[i][1], {
                    alt: (_rules[i][2] || []).slice()
                });
            }
        }
        ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
            var ok, i, rules = this.ruler.getRules(""), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
            while(line < endLine){
                state.line = line = state.skipEmptyLines(line);
                if (line >= endLine) {
                    break;
                }
                if (state.sCount[line] < state.blkIndent) {
                    break;
                }
                if (state.level >= maxNesting) {
                    state.line = endLine;
                    break;
                }
                for(i = 0; i < len; i++){
                    ok = rules[i](state, line, endLine, false);
                    if (ok) {
                        break;
                    }
                }
                state.tight = !hasEmptyLines;
                if (state.isEmpty(state.line - 1)) {
                    hasEmptyLines = true;
                }
                line = state.line;
                if (line < endLine && state.isEmpty(line)) {
                    hasEmptyLines = true;
                    line++;
                    state.line = line;
                }
            }
        };
        ParserBlock.prototype.parse = function(src, md, env, outTokens) {
            var state;
            if (!src) {
                return;
            }
            state = new this.State(src, md, env, outTokens);
            this.tokenize(state, state.line, state.lineMax);
        };
        ParserBlock.prototype.State = require_state_block();
        module2.exports = ParserBlock;
    }
});
// node_modules/markdown-it/lib/rules_inline/text.js
var require_text = __commonJS({
    "node_modules/markdown-it/lib/rules_inline/text.js" (exports1, module2) {
        "use strict";
        function isTerminatorChar(ch) {
            switch(ch){
                case 10:
                case 33:
                case 35:
                case 36:
                case 37:
                case 38:
                case 42:
                case 43:
                case 45:
                case 58:
                case 60:
                case 61:
                case 62:
                case 64:
                case 91:
                case 92:
                case 93:
                case 94:
                case 95:
                case 96:
                case 123:
                case 125:
                case 126:
                    return true;
                default:
                    return false;
            }
        }
        module2.exports = function text2(state, silent) {
            var pos = state.pos;
            while(pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))){
                pos++;
            }
            if (pos === state.pos) {
                return false;
            }
            if (!silent) {
                state.pending += state.src.slice(state.pos, pos);
            }
            state.pos = pos;
            return true;
        };
    }
});
// node_modules/markdown-it/lib/rules_inline/newline.js
var require_newline = __commonJS({
    "node_modules/markdown-it/lib/rules_inline/newline.js" (exports1, module2) {
        "use strict";
        var isSpace = require_utils().isSpace;
        module2.exports = function newline(state, silent) {
            var pmax, max2, ws, pos = state.pos;
            if (state.src.charCodeAt(pos) !== 10) {
                return false;
            }
            pmax = state.pending.length - 1;
            max2 = state.posMax;
            if (!silent) {
                if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
                    if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
                        ws = pmax - 1;
                        while(ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)ws--;
                        state.pending = state.pending.slice(0, ws);
                        state.push("hardbreak", "br", 0);
                    } else {
                        state.pending = state.pending.slice(0, -1);
                        state.push("softbreak", "br", 0);
                    }
                } else {
                    state.push("softbreak", "br", 0);
                }
            }
            pos++;
            while(pos < max2 && isSpace(state.src.charCodeAt(pos))){
                pos++;
            }
            state.pos = pos;
            return true;
        };
    }
});
// node_modules/markdown-it/lib/rules_inline/escape.js
var require_escape = __commonJS({
    "node_modules/markdown-it/lib/rules_inline/escape.js" (exports1, module2) {
        "use strict";
        var isSpace = require_utils().isSpace;
        var ESCAPED = [];
        for(i = 0; i < 256; i++){
            ESCAPED.push(0);
        }
        var i;
        "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
            ESCAPED[ch.charCodeAt(0)] = 1;
        });
        module2.exports = function escape(state, silent) {
            var ch, pos = state.pos, max2 = state.posMax;
            if (state.src.charCodeAt(pos) !== 92) {
                return false;
            }
            pos++;
            if (pos < max2) {
                ch = state.src.charCodeAt(pos);
                if (ch < 256 && ESCAPED[ch] !== 0) {
                    if (!silent) {
                        state.pending += state.src[pos];
                    }
                    state.pos += 2;
                    return true;
                }
                if (ch === 10) {
                    if (!silent) {
                        state.push("hardbreak", "br", 0);
                    }
                    pos++;
                    while(pos < max2){
                        ch = state.src.charCodeAt(pos);
                        if (!isSpace(ch)) {
                            break;
                        }
                        pos++;
                    }
                    state.pos = pos;
                    return true;
                }
            }
            if (!silent) {
                state.pending += "\\";
            }
            state.pos++;
            return true;
        };
    }
});
// node_modules/markdown-it/lib/rules_inline/backticks.js
var require_backticks = __commonJS({
    "node_modules/markdown-it/lib/rules_inline/backticks.js" (exports1, module2) {
        "use strict";
        module2.exports = function backtick(state, silent) {
            var start, max2, marker, token, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);
            if (ch !== 96) {
                return false;
            }
            start = pos;
            pos++;
            max2 = state.posMax;
            while(pos < max2 && state.src.charCodeAt(pos) === 96){
                pos++;
            }
            marker = state.src.slice(start, pos);
            openerLength = marker.length;
            if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
                if (!silent) state.pending += marker;
                state.pos += openerLength;
                return true;
            }
            matchStart = matchEnd = pos;
            while((matchStart = state.src.indexOf("`", matchEnd)) !== -1){
                matchEnd = matchStart + 1;
                while(matchEnd < max2 && state.src.charCodeAt(matchEnd) === 96){
                    matchEnd++;
                }
                closerLength = matchEnd - matchStart;
                if (closerLength === openerLength) {
                    if (!silent) {
                        token = state.push("code_inline", "code", 0);
                        token.markup = marker;
                        token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
                    }
                    state.pos = matchEnd;
                    return true;
                }
                state.backticks[closerLength] = matchStart;
            }
            state.backticksScanned = true;
            if (!silent) state.pending += marker;
            state.pos += openerLength;
            return true;
        };
    }
});
// node_modules/markdown-it/lib/rules_inline/strikethrough.js
var require_strikethrough = __commonJS({
    "node_modules/markdown-it/lib/rules_inline/strikethrough.js" (exports1, module2) {
        "use strict";
        module2.exports.tokenize = function strikethrough(state, silent) {
            var i, scanned, token, len, ch, start = state.pos, marker = state.src.charCodeAt(start);
            if (silent) {
                return false;
            }
            if (marker !== 126) {
                return false;
            }
            scanned = state.scanDelims(state.pos, true);
            len = scanned.length;
            ch = String.fromCharCode(marker);
            if (len < 2) {
                return false;
            }
            if (len % 2) {
                token = state.push("text", "", 0);
                token.content = ch;
                len--;
            }
            for(i = 0; i < len; i += 2){
                token = state.push("text", "", 0);
                token.content = ch + ch;
                state.delimiters.push({
                    marker,
                    length: 0,
                    token: state.tokens.length - 1,
                    end: -1,
                    open: scanned.can_open,
                    close: scanned.can_close
                });
            }
            state.pos += scanned.length;
            return true;
        };
        function postProcess(state, delimiters) {
            var i, j, startDelim, endDelim, token, loneMarkers = [], max2 = delimiters.length;
            for(i = 0; i < max2; i++){
                startDelim = delimiters[i];
                if (startDelim.marker !== 126) {
                    continue;
                }
                if (startDelim.end === -1) {
                    continue;
                }
                endDelim = delimiters[startDelim.end];
                token = state.tokens[startDelim.token];
                token.type = "s_open";
                token.tag = "s";
                token.nesting = 1;
                token.markup = "~~";
                token.content = "";
                token = state.tokens[endDelim.token];
                token.type = "s_close";
                token.tag = "s";
                token.nesting = -1;
                token.markup = "~~";
                token.content = "";
                if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
                    loneMarkers.push(endDelim.token - 1);
                }
            }
            while(loneMarkers.length){
                i = loneMarkers.pop();
                j = i + 1;
                while(j < state.tokens.length && state.tokens[j].type === "s_close"){
                    j++;
                }
                j--;
                if (i !== j) {
                    token = state.tokens[j];
                    state.tokens[j] = state.tokens[i];
                    state.tokens[i] = token;
                }
            }
        }
        module2.exports.postProcess = function strikethrough(state) {
            var curr, tokens_meta = state.tokens_meta, max2 = state.tokens_meta.length;
            postProcess(state, state.delimiters);
            for(curr = 0; curr < max2; curr++){
                if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
                    postProcess(state, tokens_meta[curr].delimiters);
                }
            }
        };
    }
});
// node_modules/markdown-it/lib/rules_inline/emphasis.js
var require_emphasis = __commonJS({
    "node_modules/markdown-it/lib/rules_inline/emphasis.js" (exports1, module2) {
        "use strict";
        module2.exports.tokenize = function emphasis(state, silent) {
            var i, scanned, token, start = state.pos, marker = state.src.charCodeAt(start);
            if (silent) {
                return false;
            }
            if (marker !== 95 && marker !== 42) {
                return false;
            }
            scanned = state.scanDelims(state.pos, marker === 42);
            for(i = 0; i < scanned.length; i++){
                token = state.push("text", "", 0);
                token.content = String.fromCharCode(marker);
                state.delimiters.push({
                    marker,
                    length: scanned.length,
                    token: state.tokens.length - 1,
                    end: -1,
                    open: scanned.can_open,
                    close: scanned.can_close
                });
            }
            state.pos += scanned.length;
            return true;
        };
        function postProcess(state, delimiters) {
            var i, startDelim, endDelim, token, ch, isStrong, max2 = delimiters.length;
            for(i = max2 - 1; i >= 0; i--){
                startDelim = delimiters[i];
                if (startDelim.marker !== 95 && startDelim.marker !== 42) {
                    continue;
                }
                if (startDelim.end === -1) {
                    continue;
                }
                endDelim = delimiters[startDelim.end];
                isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1;
                ch = String.fromCharCode(startDelim.marker);
                token = state.tokens[startDelim.token];
                token.type = isStrong ? "strong_open" : "em_open";
                token.tag = isStrong ? "strong" : "em";
                token.nesting = 1;
                token.markup = isStrong ? ch + ch : ch;
                token.content = "";
                token = state.tokens[endDelim.token];
                token.type = isStrong ? "strong_close" : "em_close";
                token.tag = isStrong ? "strong" : "em";
                token.nesting = -1;
                token.markup = isStrong ? ch + ch : ch;
                token.content = "";
                if (isStrong) {
                    state.tokens[delimiters[i - 1].token].content = "";
                    state.tokens[delimiters[startDelim.end + 1].token].content = "";
                    i--;
                }
            }
        }
        module2.exports.postProcess = function emphasis(state) {
            var curr, tokens_meta = state.tokens_meta, max2 = state.tokens_meta.length;
            postProcess(state, state.delimiters);
            for(curr = 0; curr < max2; curr++){
                if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
                    postProcess(state, tokens_meta[curr].delimiters);
                }
            }
        };
    }
});
// node_modules/markdown-it/lib/rules_inline/link.js
var require_link = __commonJS({
    "node_modules/markdown-it/lib/rules_inline/link.js" (exports1, module2) {
        "use strict";
        var normalizeReference = require_utils().normalizeReference;
        var isSpace = require_utils().isSpace;
        module2.exports = function link2(state, silent) {
            var attrs, code2, label, labelEnd, labelStart, pos, res, ref, token, href = "", title = "", oldPos = state.pos, max2 = state.posMax, start = state.pos, parseReference = true;
            if (state.src.charCodeAt(state.pos) !== 91) {
                return false;
            }
            labelStart = state.pos + 1;
            labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
            if (labelEnd < 0) {
                return false;
            }
            pos = labelEnd + 1;
            if (pos < max2 && state.src.charCodeAt(pos) === 40) {
                parseReference = false;
                pos++;
                for(; pos < max2; pos++){
                    code2 = state.src.charCodeAt(pos);
                    if (!isSpace(code2) && code2 !== 10) {
                        break;
                    }
                }
                if (pos >= max2) {
                    return false;
                }
                start = pos;
                res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
                if (res.ok) {
                    href = state.md.normalizeLink(res.str);
                    if (state.md.validateLink(href)) {
                        pos = res.pos;
                    } else {
                        href = "";
                    }
                    start = pos;
                    for(; pos < max2; pos++){
                        code2 = state.src.charCodeAt(pos);
                        if (!isSpace(code2) && code2 !== 10) {
                            break;
                        }
                    }
                    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
                    if (pos < max2 && start !== pos && res.ok) {
                        title = res.str;
                        pos = res.pos;
                        for(; pos < max2; pos++){
                            code2 = state.src.charCodeAt(pos);
                            if (!isSpace(code2) && code2 !== 10) {
                                break;
                            }
                        }
                    }
                }
                if (pos >= max2 || state.src.charCodeAt(pos) !== 41) {
                    parseReference = true;
                }
                pos++;
            }
            if (parseReference) {
                if (typeof state.env.references === "undefined") {
                    return false;
                }
                if (pos < max2 && state.src.charCodeAt(pos) === 91) {
                    start = pos + 1;
                    pos = state.md.helpers.parseLinkLabel(state, pos);
                    if (pos >= 0) {
                        label = state.src.slice(start, pos++);
                    } else {
                        pos = labelEnd + 1;
                    }
                } else {
                    pos = labelEnd + 1;
                }
                if (!label) {
                    label = state.src.slice(labelStart, labelEnd);
                }
                ref = state.env.references[normalizeReference(label)];
                if (!ref) {
                    state.pos = oldPos;
                    return false;
                }
                href = ref.href;
                title = ref.title;
            }
            if (!silent) {
                state.pos = labelStart;
                state.posMax = labelEnd;
                token = state.push("link_open", "a", 1);
                token.attrs = attrs = [
                    [
                        "href",
                        href
                    ]
                ];
                if (title) {
                    attrs.push([
                        "title",
                        title
                    ]);
                }
                state.md.inline.tokenize(state);
                token = state.push("link_close", "a", -1);
            }
            state.pos = pos;
            state.posMax = max2;
            return true;
        };
    }
});
// node_modules/markdown-it/lib/rules_inline/image.js
var require_image = __commonJS({
    "node_modules/markdown-it/lib/rules_inline/image.js" (exports1, module2) {
        "use strict";
        var normalizeReference = require_utils().normalizeReference;
        var isSpace = require_utils().isSpace;
        module2.exports = function image2(state, silent) {
            var attrs, code2, content, label, labelEnd, labelStart, pos, ref, res, title, token, tokens, start, href = "", oldPos = state.pos, max2 = state.posMax;
            if (state.src.charCodeAt(state.pos) !== 33) {
                return false;
            }
            if (state.src.charCodeAt(state.pos + 1) !== 91) {
                return false;
            }
            labelStart = state.pos + 2;
            labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
            if (labelEnd < 0) {
                return false;
            }
            pos = labelEnd + 1;
            if (pos < max2 && state.src.charCodeAt(pos) === 40) {
                pos++;
                for(; pos < max2; pos++){
                    code2 = state.src.charCodeAt(pos);
                    if (!isSpace(code2) && code2 !== 10) {
                        break;
                    }
                }
                if (pos >= max2) {
                    return false;
                }
                start = pos;
                res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
                if (res.ok) {
                    href = state.md.normalizeLink(res.str);
                    if (state.md.validateLink(href)) {
                        pos = res.pos;
                    } else {
                        href = "";
                    }
                }
                start = pos;
                for(; pos < max2; pos++){
                    code2 = state.src.charCodeAt(pos);
                    if (!isSpace(code2) && code2 !== 10) {
                        break;
                    }
                }
                res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
                if (pos < max2 && start !== pos && res.ok) {
                    title = res.str;
                    pos = res.pos;
                    for(; pos < max2; pos++){
                        code2 = state.src.charCodeAt(pos);
                        if (!isSpace(code2) && code2 !== 10) {
                            break;
                        }
                    }
                } else {
                    title = "";
                }
                if (pos >= max2 || state.src.charCodeAt(pos) !== 41) {
                    state.pos = oldPos;
                    return false;
                }
                pos++;
            } else {
                if (typeof state.env.references === "undefined") {
                    return false;
                }
                if (pos < max2 && state.src.charCodeAt(pos) === 91) {
                    start = pos + 1;
                    pos = state.md.helpers.parseLinkLabel(state, pos);
                    if (pos >= 0) {
                        label = state.src.slice(start, pos++);
                    } else {
                        pos = labelEnd + 1;
                    }
                } else {
                    pos = labelEnd + 1;
                }
                if (!label) {
                    label = state.src.slice(labelStart, labelEnd);
                }
                ref = state.env.references[normalizeReference(label)];
                if (!ref) {
                    state.pos = oldPos;
                    return false;
                }
                href = ref.href;
                title = ref.title;
            }
            if (!silent) {
                content = state.src.slice(labelStart, labelEnd);
                state.md.inline.parse(content, state.md, state.env, tokens = []);
                token = state.push("image", "img", 0);
                token.attrs = attrs = [
                    [
                        "src",
                        href
                    ],
                    [
                        "alt",
                        ""
                    ]
                ];
                token.children = tokens;
                token.content = content;
                if (title) {
                    attrs.push([
                        "title",
                        title
                    ]);
                }
            }
            state.pos = pos;
            state.posMax = max2;
            return true;
        };
    }
});
// node_modules/markdown-it/lib/rules_inline/autolink.js
var require_autolink = __commonJS({
    "node_modules/markdown-it/lib/rules_inline/autolink.js" (exports1, module2) {
        "use strict";
        var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
        var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
        module2.exports = function autolink(state, silent) {
            var url, fullUrl, token, ch, start, max2, pos = state.pos;
            if (state.src.charCodeAt(pos) !== 60) {
                return false;
            }
            start = state.pos;
            max2 = state.posMax;
            for(;;){
                if (++pos >= max2) return false;
                ch = state.src.charCodeAt(pos);
                if (ch === 60) return false;
                if (ch === 62) break;
            }
            url = state.src.slice(start + 1, pos);
            if (AUTOLINK_RE.test(url)) {
                fullUrl = state.md.normalizeLink(url);
                if (!state.md.validateLink(fullUrl)) {
                    return false;
                }
                if (!silent) {
                    token = state.push("link_open", "a", 1);
                    token.attrs = [
                        [
                            "href",
                            fullUrl
                        ]
                    ];
                    token.markup = "autolink";
                    token.info = "auto";
                    token = state.push("text", "", 0);
                    token.content = state.md.normalizeLinkText(url);
                    token = state.push("link_close", "a", -1);
                    token.markup = "autolink";
                    token.info = "auto";
                }
                state.pos += url.length + 2;
                return true;
            }
            if (EMAIL_RE.test(url)) {
                fullUrl = state.md.normalizeLink("mailto:" + url);
                if (!state.md.validateLink(fullUrl)) {
                    return false;
                }
                if (!silent) {
                    token = state.push("link_open", "a", 1);
                    token.attrs = [
                        [
                            "href",
                            fullUrl
                        ]
                    ];
                    token.markup = "autolink";
                    token.info = "auto";
                    token = state.push("text", "", 0);
                    token.content = state.md.normalizeLinkText(url);
                    token = state.push("link_close", "a", -1);
                    token.markup = "autolink";
                    token.info = "auto";
                }
                state.pos += url.length + 2;
                return true;
            }
            return false;
        };
    }
});
// node_modules/markdown-it/lib/rules_inline/html_inline.js
var require_html_inline = __commonJS({
    "node_modules/markdown-it/lib/rules_inline/html_inline.js" (exports1, module2) {
        "use strict";
        var HTML_TAG_RE = require_html_re().HTML_TAG_RE;
        function isLetter(ch) {
            var lc = ch | 32;
            return lc >= 97 && lc <= 122;
        }
        module2.exports = function html_inline(state, silent) {
            var ch, match, max2, token, pos = state.pos;
            if (!state.md.options.html) {
                return false;
            }
            max2 = state.posMax;
            if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max2) {
                return false;
            }
            ch = state.src.charCodeAt(pos + 1);
            if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
                return false;
            }
            match = state.src.slice(pos).match(HTML_TAG_RE);
            if (!match) {
                return false;
            }
            if (!silent) {
                token = state.push("html_inline", "", 0);
                token.content = state.src.slice(pos, pos + match[0].length);
            }
            state.pos += match[0].length;
            return true;
        };
    }
});
// node_modules/markdown-it/lib/rules_inline/entity.js
var require_entity = __commonJS({
    "node_modules/markdown-it/lib/rules_inline/entity.js" (exports1, module2) {
        "use strict";
        var entities = require_entities2();
        var has = require_utils().has;
        var isValidEntityCode = require_utils().isValidEntityCode;
        var fromCodePoint = require_utils().fromCodePoint;
        var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
        var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
        module2.exports = function entity(state, silent) {
            var ch, code2, match, pos = state.pos, max2 = state.posMax;
            if (state.src.charCodeAt(pos) !== 38) {
                return false;
            }
            if (pos + 1 < max2) {
                ch = state.src.charCodeAt(pos + 1);
                if (ch === 35) {
                    match = state.src.slice(pos).match(DIGITAL_RE);
                    if (match) {
                        if (!silent) {
                            code2 = match[1][0].toLowerCase() === "x" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
                            state.pending += isValidEntityCode(code2) ? fromCodePoint(code2) : fromCodePoint(65533);
                        }
                        state.pos += match[0].length;
                        return true;
                    }
                } else {
                    match = state.src.slice(pos).match(NAMED_RE);
                    if (match) {
                        if (has(entities, match[1])) {
                            if (!silent) {
                                state.pending += entities[match[1]];
                            }
                            state.pos += match[0].length;
                            return true;
                        }
                    }
                }
            }
            if (!silent) {
                state.pending += "&";
            }
            state.pos++;
            return true;
        };
    }
});
// node_modules/markdown-it/lib/rules_inline/balance_pairs.js
var require_balance_pairs = __commonJS({
    "node_modules/markdown-it/lib/rules_inline/balance_pairs.js" (exports1, module2) {
        "use strict";
        function processDelimiters(state, delimiters) {
            var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max2 = delimiters.length;
            if (!max2) return;
            var headerIdx = 0;
            var lastTokenIdx = -2;
            var jumps = [];
            for(closerIdx = 0; closerIdx < max2; closerIdx++){
                closer = delimiters[closerIdx];
                jumps.push(0);
                if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
                    headerIdx = closerIdx;
                }
                lastTokenIdx = closer.token;
                closer.length = closer.length || 0;
                if (!closer.close) continue;
                if (!openersBottom.hasOwnProperty(closer.marker)) {
                    openersBottom[closer.marker] = [
                        -1,
                        -1,
                        -1,
                        -1,
                        -1,
                        -1
                    ];
                }
                minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
                openerIdx = headerIdx - jumps[headerIdx] - 1;
                newMinOpenerIdx = openerIdx;
                for(; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1){
                    opener = delimiters[openerIdx];
                    if (opener.marker !== closer.marker) continue;
                    if (opener.open && opener.end < 0) {
                        isOddMatch = false;
                        if (opener.close || closer.open) {
                            if ((opener.length + closer.length) % 3 === 0) {
                                if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                                    isOddMatch = true;
                                }
                            }
                        }
                        if (!isOddMatch) {
                            lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
                            jumps[closerIdx] = closerIdx - openerIdx + lastJump;
                            jumps[openerIdx] = lastJump;
                            closer.open = false;
                            opener.end = closerIdx;
                            opener.close = false;
                            newMinOpenerIdx = -1;
                            lastTokenIdx = -2;
                            break;
                        }
                    }
                }
                if (newMinOpenerIdx !== -1) {
                    openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
                }
            }
        }
        module2.exports = function link_pairs(state) {
            var curr, tokens_meta = state.tokens_meta, max2 = state.tokens_meta.length;
            processDelimiters(state, state.delimiters);
            for(curr = 0; curr < max2; curr++){
                if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
                    processDelimiters(state, tokens_meta[curr].delimiters);
                }
            }
        };
    }
});
// node_modules/markdown-it/lib/rules_inline/text_collapse.js
var require_text_collapse = __commonJS({
    "node_modules/markdown-it/lib/rules_inline/text_collapse.js" (exports1, module2) {
        "use strict";
        module2.exports = function text_collapse(state) {
            var curr, last, level = 0, tokens = state.tokens, max2 = state.tokens.length;
            for(curr = last = 0; curr < max2; curr++){
                if (tokens[curr].nesting < 0) level--;
                tokens[curr].level = level;
                if (tokens[curr].nesting > 0) level++;
                if (tokens[curr].type === "text" && curr + 1 < max2 && tokens[curr + 1].type === "text") {
                    tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
                } else {
                    if (curr !== last) {
                        tokens[last] = tokens[curr];
                    }
                    last++;
                }
            }
            if (curr !== last) {
                tokens.length = last;
            }
        };
    }
});
// node_modules/markdown-it/lib/rules_inline/state_inline.js
var require_state_inline = __commonJS({
    "node_modules/markdown-it/lib/rules_inline/state_inline.js" (exports1, module2) {
        "use strict";
        var Token = require_token();
        var isWhiteSpace = require_utils().isWhiteSpace;
        var isPunctChar = require_utils().isPunctChar;
        var isMdAsciiPunct = require_utils().isMdAsciiPunct;
        function StateInline(src, md, env, outTokens) {
            this.src = src;
            this.env = env;
            this.md = md;
            this.tokens = outTokens;
            this.tokens_meta = Array(outTokens.length);
            this.pos = 0;
            this.posMax = this.src.length;
            this.level = 0;
            this.pending = "";
            this.pendingLevel = 0;
            this.cache = {};
            this.delimiters = [];
            this._prev_delimiters = [];
            this.backticks = {};
            this.backticksScanned = false;
        }
        StateInline.prototype.pushPending = function() {
            var token = new Token("text", "", 0);
            token.content = this.pending;
            token.level = this.pendingLevel;
            this.tokens.push(token);
            this.pending = "";
            return token;
        };
        StateInline.prototype.push = function(type, tag, nesting) {
            if (this.pending) {
                this.pushPending();
            }
            var token = new Token(type, tag, nesting);
            var token_meta = null;
            if (nesting < 0) {
                this.level--;
                this.delimiters = this._prev_delimiters.pop();
            }
            token.level = this.level;
            if (nesting > 0) {
                this.level++;
                this._prev_delimiters.push(this.delimiters);
                this.delimiters = [];
                token_meta = {
                    delimiters: this.delimiters
                };
            }
            this.pendingLevel = this.level;
            this.tokens.push(token);
            this.tokens_meta.push(token_meta);
            return token;
        };
        StateInline.prototype.scanDelims = function(start, canSplitWord) {
            var pos = start, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max2 = this.posMax, marker = this.src.charCodeAt(start);
            lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
            while(pos < max2 && this.src.charCodeAt(pos) === marker){
                pos++;
            }
            count = pos - start;
            nextChar = pos < max2 ? this.src.charCodeAt(pos) : 32;
            isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
            isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
            isLastWhiteSpace = isWhiteSpace(lastChar);
            isNextWhiteSpace = isWhiteSpace(nextChar);
            if (isNextWhiteSpace) {
                left_flanking = false;
            } else if (isNextPunctChar) {
                if (!(isLastWhiteSpace || isLastPunctChar)) {
                    left_flanking = false;
                }
            }
            if (isLastWhiteSpace) {
                right_flanking = false;
            } else if (isLastPunctChar) {
                if (!(isNextWhiteSpace || isNextPunctChar)) {
                    right_flanking = false;
                }
            }
            if (!canSplitWord) {
                can_open = left_flanking && (!right_flanking || isLastPunctChar);
                can_close = right_flanking && (!left_flanking || isNextPunctChar);
            } else {
                can_open = left_flanking;
                can_close = right_flanking;
            }
            return {
                can_open,
                can_close,
                length: count
            };
        };
        StateInline.prototype.Token = Token;
        module2.exports = StateInline;
    }
});
// node_modules/markdown-it/lib/parser_inline.js
var require_parser_inline = __commonJS({
    "node_modules/markdown-it/lib/parser_inline.js" (exports1, module2) {
        "use strict";
        var Ruler = require_ruler();
        var _rules = [
            [
                "text",
                require_text()
            ],
            [
                "newline",
                require_newline()
            ],
            [
                "escape",
                require_escape()
            ],
            [
                "backticks",
                require_backticks()
            ],
            [
                "strikethrough",
                require_strikethrough().tokenize
            ],
            [
                "emphasis",
                require_emphasis().tokenize
            ],
            [
                "link",
                require_link()
            ],
            [
                "image",
                require_image()
            ],
            [
                "autolink",
                require_autolink()
            ],
            [
                "html_inline",
                require_html_inline()
            ],
            [
                "entity",
                require_entity()
            ]
        ];
        var _rules2 = [
            [
                "balance_pairs",
                require_balance_pairs()
            ],
            [
                "strikethrough",
                require_strikethrough().postProcess
            ],
            [
                "emphasis",
                require_emphasis().postProcess
            ],
            [
                "text_collapse",
                require_text_collapse()
            ]
        ];
        function ParserInline() {
            var i;
            this.ruler = new Ruler();
            for(i = 0; i < _rules.length; i++){
                this.ruler.push(_rules[i][0], _rules[i][1]);
            }
            this.ruler2 = new Ruler();
            for(i = 0; i < _rules2.length; i++){
                this.ruler2.push(_rules2[i][0], _rules2[i][1]);
            }
        }
        ParserInline.prototype.skipToken = function(state) {
            var ok, i, pos = state.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state.md.options.maxNesting, cache = state.cache;
            if (typeof cache[pos] !== "undefined") {
                state.pos = cache[pos];
                return;
            }
            if (state.level < maxNesting) {
                for(i = 0; i < len; i++){
                    state.level++;
                    ok = rules[i](state, true);
                    state.level--;
                    if (ok) {
                        break;
                    }
                }
            } else {
                state.pos = state.posMax;
            }
            if (!ok) {
                state.pos++;
            }
            cache[pos] = state.pos;
        };
        ParserInline.prototype.tokenize = function(state) {
            var ok, i, rules = this.ruler.getRules(""), len = rules.length, end = state.posMax, maxNesting = state.md.options.maxNesting;
            while(state.pos < end){
                if (state.level < maxNesting) {
                    for(i = 0; i < len; i++){
                        ok = rules[i](state, false);
                        if (ok) {
                            break;
                        }
                    }
                }
                if (ok) {
                    if (state.pos >= end) {
                        break;
                    }
                    continue;
                }
                state.pending += state.src[state.pos++];
            }
            if (state.pending) {
                state.pushPending();
            }
        };
        ParserInline.prototype.parse = function(str, md, env, outTokens) {
            var i, rules, len;
            var state = new this.State(str, md, env, outTokens);
            this.tokenize(state);
            rules = this.ruler2.getRules("");
            len = rules.length;
            for(i = 0; i < len; i++){
                rules[i](state);
            }
        };
        ParserInline.prototype.State = require_state_inline();
        module2.exports = ParserInline;
    }
});
// node_modules/linkify-it/lib/re.js
var require_re = __commonJS({
    "node_modules/linkify-it/lib/re.js" (exports1, module2) {
        "use strict";
        module2.exports = function(opts) {
            var re = {};
            re.src_Any = require_regex2().source;
            re.src_Cc = require_regex3().source;
            re.src_Z = require_regex5().source;
            re.src_P = require_regex().source;
            re.src_ZPCc = [
                re.src_Z,
                re.src_P,
                re.src_Cc
            ].join("|");
            re.src_ZCc = [
                re.src_Z,
                re.src_Cc
            ].join("|");
            var text_separators = "[><]";
            re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
            re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
            re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
            re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
            re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
            re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-]).|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]).|" + (opts && opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re.src_ZCc + ").|;(?!" + re.src_ZCc + ").|\\!+(?!" + re.src_ZCc + "|[!]).|\\?(?!" + re.src_ZCc + "|[?]).)+|\\/)?";
            re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
            re.src_xn = "xn--[a-z0-9\\-]{1,59}";
            re.src_domain_root = "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
            re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
            re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
            re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
            re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
            re.src_host_strict = re.src_host + re.src_host_terminator;
            re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
            re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
            re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
            re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
            re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
            re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
            re.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + re.src_ZPCc + "))((?![$+<=>^`|])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
            re.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + re.src_ZPCc + "))((?![$+<=>^`|])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
            return re;
        };
    }
});
// node_modules/linkify-it/index.js
var require_linkify_it = __commonJS({
    "node_modules/linkify-it/index.js" (exports1, module2) {
        "use strict";
        function assign(obj) {
            var sources = Array.prototype.slice.call(arguments, 1);
            sources.forEach(function(source) {
                if (!source) {
                    return;
                }
                Object.keys(source).forEach(function(key) {
                    obj[key] = source[key];
                });
            });
            return obj;
        }
        function _class(obj) {
            return Object.prototype.toString.call(obj);
        }
        function isString(obj) {
            return _class(obj) === "[object String]";
        }
        function isObject(obj) {
            return _class(obj) === "[object Object]";
        }
        function isRegExp(obj) {
            return _class(obj) === "[object RegExp]";
        }
        function isFunction2(obj) {
            return _class(obj) === "[object Function]";
        }
        function escapeRE(str) {
            return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
        }
        var defaultOptions = {
            fuzzyLink: true,
            fuzzyEmail: true,
            fuzzyIP: false
        };
        function isOptionsObj(obj) {
            return Object.keys(obj || {}).reduce(function(acc, k) {
                return acc || defaultOptions.hasOwnProperty(k);
            }, false);
        }
        var defaultSchemas = {
            "http:": {
                validate: function(text2, pos, self) {
                    var tail = text2.slice(pos);
                    if (!self.re.http) {
                        self.re.http = new RegExp("^\\/\\/" + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, "i");
                    }
                    if (self.re.http.test(tail)) {
                        return tail.match(self.re.http)[0].length;
                    }
                    return 0;
                }
            },
            "https:": "http:",
            "ftp:": "http:",
            "//": {
                validate: function(text2, pos, self) {
                    var tail = text2.slice(pos);
                    if (!self.re.no_http) {
                        self.re.no_http = new RegExp("^" + self.re.src_auth + "(?:localhost|(?:(?:" + self.re.src_domain + ")\\.)+" + self.re.src_domain_root + ")" + self.re.src_port + self.re.src_host_terminator + self.re.src_path, "i");
                    }
                    if (self.re.no_http.test(tail)) {
                        if (pos >= 3 && text2[pos - 3] === ":") {
                            return 0;
                        }
                        if (pos >= 3 && text2[pos - 3] === "/") {
                            return 0;
                        }
                        return tail.match(self.re.no_http)[0].length;
                    }
                    return 0;
                }
            },
            "mailto:": {
                validate: function(text2, pos, self) {
                    var tail = text2.slice(pos);
                    if (!self.re.mailto) {
                        self.re.mailto = new RegExp("^" + self.re.src_email_name + "@" + self.re.src_host_strict, "i");
                    }
                    if (self.re.mailto.test(tail)) {
                        return tail.match(self.re.mailto)[0].length;
                    }
                    return 0;
                }
            }
        };
        var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
        var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|".split("|");
        function resetScanCache(self) {
            self.__index__ = -1;
            self.__text_cache__ = "";
        }
        function createValidator(re) {
            return function(text2, pos) {
                var tail = text2.slice(pos);
                if (re.test(tail)) {
                    return tail.match(re)[0].length;
                }
                return 0;
            };
        }
        function createNormalizer() {
            return function(match, self) {
                self.normalize(match);
            };
        }
        function compile(self) {
            var re = self.re = require_re()(self.__opts__);
            var tlds = self.__tlds__.slice();
            self.onCompile();
            if (!self.__tlds_replaced__) {
                tlds.push(tlds_2ch_src_re);
            }
            tlds.push(re.src_xn);
            re.src_tlds = tlds.join("|");
            function untpl(tpl) {
                return tpl.replace("%TLDS%", re.src_tlds);
            }
            re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
            re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
            re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
            re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
            var aliases = [];
            self.__compiled__ = {};
            function schemaError(name, val) {
                throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
            }
            Object.keys(self.__schemas__).forEach(function(name) {
                var val = self.__schemas__[name];
                if (val === null) {
                    return;
                }
                var compiled = {
                    validate: null,
                    link: null
                };
                self.__compiled__[name] = compiled;
                if (isObject(val)) {
                    if (isRegExp(val.validate)) {
                        compiled.validate = createValidator(val.validate);
                    } else if (isFunction2(val.validate)) {
                        compiled.validate = val.validate;
                    } else {
                        schemaError(name, val);
                    }
                    if (isFunction2(val.normalize)) {
                        compiled.normalize = val.normalize;
                    } else if (!val.normalize) {
                        compiled.normalize = createNormalizer();
                    } else {
                        schemaError(name, val);
                    }
                    return;
                }
                if (isString(val)) {
                    aliases.push(name);
                    return;
                }
                schemaError(name, val);
            });
            aliases.forEach(function(alias) {
                if (!self.__compiled__[self.__schemas__[alias]]) {
                    return;
                }
                self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
                self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
            });
            self.__compiled__[""] = {
                validate: null,
                normalize: createNormalizer()
            };
            var slist = Object.keys(self.__compiled__).filter(function(name) {
                return name.length > 0 && self.__compiled__[name];
            }).map(escapeRE).join("|");
            self.re.schema_test = RegExp("(^|(?!_)(?:[><]|" + re.src_ZPCc + "))(" + slist + ")", "i");
            self.re.schema_search = RegExp("(^|(?!_)(?:[><]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
            self.re.pretest = RegExp("(" + self.re.schema_test.source + ")|(" + self.re.host_fuzzy_test.source + ")|@", "i");
            resetScanCache(self);
        }
        function Match(self, shift) {
            var start = self.__index__, end = self.__last_index__, text2 = self.__text_cache__.slice(start, end);
            this.schema = self.__schema__.toLowerCase();
            this.index = start + shift;
            this.lastIndex = end + shift;
            this.raw = text2;
            this.text = text2;
            this.url = text2;
        }
        function createMatch(self, shift) {
            var match = new Match(self, shift);
            self.__compiled__[match.schema].normalize(match, self);
            return match;
        }
        function LinkifyIt(schemas, options) {
            if (!(this instanceof LinkifyIt)) {
                return new LinkifyIt(schemas, options);
            }
            if (!options) {
                if (isOptionsObj(schemas)) {
                    options = schemas;
                    schemas = {};
                }
            }
            this.__opts__ = assign({}, defaultOptions, options);
            this.__index__ = -1;
            this.__last_index__ = -1;
            this.__schema__ = "";
            this.__text_cache__ = "";
            this.__schemas__ = assign({}, defaultSchemas, schemas);
            this.__compiled__ = {};
            this.__tlds__ = tlds_default;
            this.__tlds_replaced__ = false;
            this.re = {};
            compile(this);
        }
        LinkifyIt.prototype.add = function add(schema, definition) {
            this.__schemas__[schema] = definition;
            compile(this);
            return this;
        };
        LinkifyIt.prototype.set = function set(options) {
            this.__opts__ = assign(this.__opts__, options);
            return this;
        };
        LinkifyIt.prototype.test = function test(text2) {
            this.__text_cache__ = text2;
            this.__index__ = -1;
            if (!text2.length) {
                return false;
            }
            var m, ml, me, len, shift, next, re, tld_pos, at_pos;
            if (this.re.schema_test.test(text2)) {
                re = this.re.schema_search;
                re.lastIndex = 0;
                while((m = re.exec(text2)) !== null){
                    len = this.testSchemaAt(text2, m[2], re.lastIndex);
                    if (len) {
                        this.__schema__ = m[2];
                        this.__index__ = m.index + m[1].length;
                        this.__last_index__ = m.index + m[0].length + len;
                        break;
                    }
                }
            }
            if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
                tld_pos = text2.search(this.re.host_fuzzy_test);
                if (tld_pos >= 0) {
                    if (this.__index__ < 0 || tld_pos < this.__index__) {
                        if ((ml = text2.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
                            shift = ml.index + ml[1].length;
                            if (this.__index__ < 0 || shift < this.__index__) {
                                this.__schema__ = "";
                                this.__index__ = shift;
                                this.__last_index__ = ml.index + ml[0].length;
                            }
                        }
                    }
                }
            }
            if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
                at_pos = text2.indexOf("@");
                if (at_pos >= 0) {
                    if ((me = text2.match(this.re.email_fuzzy)) !== null) {
                        shift = me.index + me[1].length;
                        next = me.index + me[0].length;
                        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
                            this.__schema__ = "mailto:";
                            this.__index__ = shift;
                            this.__last_index__ = next;
                        }
                    }
                }
            }
            return this.__index__ >= 0;
        };
        LinkifyIt.prototype.pretest = function pretest(text2) {
            return this.re.pretest.test(text2);
        };
        LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text2, schema, pos) {
            if (!this.__compiled__[schema.toLowerCase()]) {
                return 0;
            }
            return this.__compiled__[schema.toLowerCase()].validate(text2, pos, this);
        };
        LinkifyIt.prototype.match = function match(text2) {
            var shift = 0, result = [];
            if (this.__index__ >= 0 && this.__text_cache__ === text2) {
                result.push(createMatch(this, shift));
                shift = this.__last_index__;
            }
            var tail = shift ? text2.slice(shift) : text2;
            while(this.test(tail)){
                result.push(createMatch(this, shift));
                tail = tail.slice(this.__last_index__);
                shift += this.__last_index__;
            }
            if (result.length) {
                return result;
            }
            return null;
        };
        LinkifyIt.prototype.tlds = function tlds(list2, keepOld) {
            list2 = Array.isArray(list2) ? list2 : [
                list2
            ];
            if (!keepOld) {
                this.__tlds__ = list2.slice();
                this.__tlds_replaced__ = true;
                compile(this);
                return this;
            }
            this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el, idx, arr) {
                return el !== arr[idx - 1];
            }).reverse();
            compile(this);
            return this;
        };
        LinkifyIt.prototype.normalize = function normalize(match) {
            if (!match.schema) {
                match.url = "http://" + match.url;
            }
            if (match.schema === "mailto:" && !/^mailto:/i.test(match.url)) {
                match.url = "mailto:" + match.url;
            }
        };
        LinkifyIt.prototype.onCompile = function onCompile() {};
        module2.exports = LinkifyIt;
    }
});
// node_modules/punycode/punycode.js
var require_punycode = __commonJS({
    "node_modules/punycode/punycode.js" (exports1, module2) {
        "use strict";
        var maxInt = 2147483647;
        var base = 36;
        var tMin = 1;
        var tMax = 26;
        var skew = 38;
        var damp = 700;
        var initialBias = 72;
        var initialN = 128;
        var delimiter = "-";
        var regexPunycode = /^xn--/;
        var regexNonASCII = /[^\0-\x7E]/;
        var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
        var errors = {
            "overflow": "Overflow: input needs wider integers to process",
            "not-basic": "Illegal input >= 0x80 (not a basic code point)",
            "invalid-input": "Invalid input"
        };
        var baseMinusTMin = base - tMin;
        var floor = Math.floor;
        var stringFromCharCode = String.fromCharCode;
        function error2(type) {
            throw new RangeError(errors[type]);
        }
        function map(array, fn) {
            const result = [];
            let length = array.length;
            while(length--){
                result[length] = fn(array[length]);
            }
            return result;
        }
        function mapDomain(string, fn) {
            const parts = string.split("@");
            let result = "";
            if (parts.length > 1) {
                result = parts[0] + "@";
                string = parts[1];
            }
            string = string.replace(regexSeparators, ".");
            const labels = string.split(".");
            const encoded = map(labels, fn).join(".");
            return result + encoded;
        }
        function ucs2decode(string) {
            const output = [];
            let counter = 0;
            const length = string.length;
            while(counter < length){
                const value = string.charCodeAt(counter++);
                if (value >= 55296 && value <= 56319 && counter < length) {
                    const extra = string.charCodeAt(counter++);
                    if ((extra & 64512) == 56320) {
                        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                    } else {
                        output.push(value);
                        counter--;
                    }
                } else {
                    output.push(value);
                }
            }
            return output;
        }
        var ucs2encode = (array)=>String.fromCodePoint(...array);
        var basicToDigit = function(codePoint) {
            if (codePoint - 48 < 10) {
                return codePoint - 22;
            }
            if (codePoint - 65 < 26) {
                return codePoint - 65;
            }
            if (codePoint - 97 < 26) {
                return codePoint - 97;
            }
            return base;
        };
        var digitToBasic = function(digit, flag) {
            return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        };
        var adapt = function(delta, numPoints, firstTime) {
            let k = 0;
            delta = firstTime ? floor(delta / damp) : delta >> 1;
            delta += floor(delta / numPoints);
            for(; delta > baseMinusTMin * tMax >> 1; k += base){
                delta = floor(delta / baseMinusTMin);
            }
            return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
        };
        var decode = function(input) {
            const output = [];
            const inputLength = input.length;
            let i = 0;
            let n = initialN;
            let bias = initialBias;
            let basic = input.lastIndexOf(delimiter);
            if (basic < 0) {
                basic = 0;
            }
            for(let j = 0; j < basic; ++j){
                if (input.charCodeAt(j) >= 128) {
                    error2("not-basic");
                }
                output.push(input.charCodeAt(j));
            }
            for(let index = basic > 0 ? basic + 1 : 0; index < inputLength;){
                let oldi = i;
                for(let w = 1, k = base;; k += base){
                    if (index >= inputLength) {
                        error2("invalid-input");
                    }
                    const digit = basicToDigit(input.charCodeAt(index++));
                    if (digit >= base || digit > floor((maxInt - i) / w)) {
                        error2("overflow");
                    }
                    i += digit * w;
                    const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                    if (digit < t) {
                        break;
                    }
                    const baseMinusT = base - t;
                    if (w > floor(maxInt / baseMinusT)) {
                        error2("overflow");
                    }
                    w *= baseMinusT;
                }
                const out = output.length + 1;
                bias = adapt(i - oldi, out, oldi == 0);
                if (floor(i / out) > maxInt - n) {
                    error2("overflow");
                }
                n += floor(i / out);
                i %= out;
                output.splice(i++, 0, n);
            }
            return String.fromCodePoint(...output);
        };
        var encode = function(input) {
            const output = [];
            input = ucs2decode(input);
            let inputLength = input.length;
            let n = initialN;
            let delta = 0;
            let bias = initialBias;
            for (const currentValue of input){
                if (currentValue < 128) {
                    output.push(stringFromCharCode(currentValue));
                }
            }
            let basicLength = output.length;
            let handledCPCount = basicLength;
            if (basicLength) {
                output.push(delimiter);
            }
            while(handledCPCount < inputLength){
                let m = maxInt;
                for (const currentValue of input){
                    if (currentValue >= n && currentValue < m) {
                        m = currentValue;
                    }
                }
                const handledCPCountPlusOne = handledCPCount + 1;
                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                    error2("overflow");
                }
                delta += (m - n) * handledCPCountPlusOne;
                n = m;
                for (const currentValue of input){
                    if (currentValue < n && ++delta > maxInt) {
                        error2("overflow");
                    }
                    if (currentValue == n) {
                        let q = delta;
                        for(let k = base;; k += base){
                            const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                            if (q < t) {
                                break;
                            }
                            const qMinusT = q - t;
                            const baseMinusT = base - t;
                            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                            q = floor(qMinusT / baseMinusT);
                        }
                        output.push(stringFromCharCode(digitToBasic(q, 0)));
                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                        delta = 0;
                        ++handledCPCount;
                    }
                }
                ++delta;
                ++n;
            }
            return output.join("");
        };
        var toUnicode = function(input) {
            return mapDomain(input, function(string) {
                return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
            });
        };
        var toASCII = function(input) {
            return mapDomain(input, function(string) {
                return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
            });
        };
        var punycode = {
            "version": "2.1.0",
            "ucs2": {
                "decode": ucs2decode,
                "encode": ucs2encode
            },
            "decode": decode,
            "encode": encode,
            "toASCII": toASCII,
            "toUnicode": toUnicode
        };
        module2.exports = punycode;
    }
});
// node_modules/markdown-it/lib/presets/default.js
var require_default = __commonJS({
    "node_modules/markdown-it/lib/presets/default.js" (exports1, module2) {
        "use strict";
        module2.exports = {
            options: {
                html: false,
                xhtmlOut: false,
                breaks: false,
                langPrefix: "language-",
                linkify: false,
                typographer: false,
                quotes: "",
                highlight: null,
                maxNesting: 100
            },
            components: {
                core: {},
                block: {},
                inline: {}
            }
        };
    }
});
// node_modules/markdown-it/lib/presets/zero.js
var require_zero = __commonJS({
    "node_modules/markdown-it/lib/presets/zero.js" (exports1, module2) {
        "use strict";
        module2.exports = {
            options: {
                html: false,
                xhtmlOut: false,
                breaks: false,
                langPrefix: "language-",
                linkify: false,
                typographer: false,
                quotes: "",
                highlight: null,
                maxNesting: 20
            },
            components: {
                core: {
                    rules: [
                        "normalize",
                        "block",
                        "inline"
                    ]
                },
                block: {
                    rules: [
                        "paragraph"
                    ]
                },
                inline: {
                    rules: [
                        "text"
                    ],
                    rules2: [
                        "balance_pairs",
                        "text_collapse"
                    ]
                }
            }
        };
    }
});
// node_modules/markdown-it/lib/presets/commonmark.js
var require_commonmark = __commonJS({
    "node_modules/markdown-it/lib/presets/commonmark.js" (exports1, module2) {
        "use strict";
        module2.exports = {
            options: {
                html: true,
                xhtmlOut: true,
                breaks: false,
                langPrefix: "language-",
                linkify: false,
                typographer: false,
                quotes: "",
                highlight: null,
                maxNesting: 20
            },
            components: {
                core: {
                    rules: [
                        "normalize",
                        "block",
                        "inline"
                    ]
                },
                block: {
                    rules: [
                        "blockquote",
                        "code",
                        "fence",
                        "heading",
                        "hr",
                        "html_block",
                        "lheading",
                        "list",
                        "reference",
                        "paragraph"
                    ]
                },
                inline: {
                    rules: [
                        "autolink",
                        "backticks",
                        "emphasis",
                        "entity",
                        "escape",
                        "html_inline",
                        "image",
                        "link",
                        "newline",
                        "text"
                    ],
                    rules2: [
                        "balance_pairs",
                        "emphasis",
                        "text_collapse"
                    ]
                }
            }
        };
    }
});
// node_modules/markdown-it/lib/index.js
var require_lib = __commonJS({
    "node_modules/markdown-it/lib/index.js" (exports1, module2) {
        "use strict";
        var utils = require_utils();
        var helpers = require_helpers();
        var Renderer = require_renderer();
        var ParserCore = require_parser_core();
        var ParserBlock = require_parser_block();
        var ParserInline = require_parser_inline();
        var LinkifyIt = require_linkify_it();
        var mdurl = require_mdurl();
        var punycode = require_punycode();
        var config = {
            default: require_default(),
            zero: require_zero(),
            commonmark: require_commonmark()
        };
        var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
        var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
        function validateLink(url) {
            var str = url.trim().toLowerCase();
            return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
        }
        var RECODE_HOSTNAME_FOR = [
            "http:",
            "https:",
            "mailto:"
        ];
        function normalizeLink(url) {
            var parsed = mdurl.parse(url, true);
            if (parsed.hostname) {
                if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
                    try {
                        parsed.hostname = punycode.toASCII(parsed.hostname);
                    } catch (er) {}
                }
            }
            return mdurl.encode(mdurl.format(parsed));
        }
        function normalizeLinkText(url) {
            var parsed = mdurl.parse(url, true);
            if (parsed.hostname) {
                if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
                    try {
                        parsed.hostname = punycode.toUnicode(parsed.hostname);
                    } catch (er) {}
                }
            }
            return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
        }
        function MarkdownIt3(presetName, options) {
            if (!(this instanceof MarkdownIt3)) {
                return new MarkdownIt3(presetName, options);
            }
            if (!options) {
                if (!utils.isString(presetName)) {
                    options = presetName || {};
                    presetName = "default";
                }
            }
            this.inline = new ParserInline();
            this.block = new ParserBlock();
            this.core = new ParserCore();
            this.renderer = new Renderer();
            this.linkify = new LinkifyIt();
            this.validateLink = validateLink;
            this.normalizeLink = normalizeLink;
            this.normalizeLinkText = normalizeLinkText;
            this.utils = utils;
            this.helpers = utils.assign({}, helpers);
            this.options = {};
            this.configure(presetName);
            if (options) {
                this.set(options);
            }
        }
        MarkdownIt3.prototype.set = function(options) {
            utils.assign(this.options, options);
            return this;
        };
        MarkdownIt3.prototype.configure = function(presets) {
            var self = this, presetName;
            if (utils.isString(presets)) {
                presetName = presets;
                presets = config[presetName];
                if (!presets) {
                    throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
                }
            }
            if (!presets) {
                throw new Error("Wrong `markdown-it` preset, can't be empty");
            }
            if (presets.options) {
                self.set(presets.options);
            }
            if (presets.components) {
                Object.keys(presets.components).forEach(function(name) {
                    if (presets.components[name].rules) {
                        self[name].ruler.enableOnly(presets.components[name].rules);
                    }
                    if (presets.components[name].rules2) {
                        self[name].ruler2.enableOnly(presets.components[name].rules2);
                    }
                });
            }
            return this;
        };
        MarkdownIt3.prototype.enable = function(list2, ignoreInvalid) {
            var result = [];
            if (!Array.isArray(list2)) {
                list2 = [
                    list2
                ];
            }
            [
                "core",
                "block",
                "inline"
            ].forEach(function(chain) {
                result = result.concat(this[chain].ruler.enable(list2, true));
            }, this);
            result = result.concat(this.inline.ruler2.enable(list2, true));
            var missed = list2.filter(function(name) {
                return result.indexOf(name) < 0;
            });
            if (missed.length && !ignoreInvalid) {
                throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
            }
            return this;
        };
        MarkdownIt3.prototype.disable = function(list2, ignoreInvalid) {
            var result = [];
            if (!Array.isArray(list2)) {
                list2 = [
                    list2
                ];
            }
            [
                "core",
                "block",
                "inline"
            ].forEach(function(chain) {
                result = result.concat(this[chain].ruler.disable(list2, true));
            }, this);
            result = result.concat(this.inline.ruler2.disable(list2, true));
            var missed = list2.filter(function(name) {
                return result.indexOf(name) < 0;
            });
            if (missed.length && !ignoreInvalid) {
                throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
            }
            return this;
        };
        MarkdownIt3.prototype.use = function(plugin4) {
            var args = [
                this
            ].concat(Array.prototype.slice.call(arguments, 1));
            plugin4.apply(plugin4, args);
            return this;
        };
        MarkdownIt3.prototype.parse = function(src, env) {
            if (typeof src !== "string") {
                throw new Error("Input data should be a String");
            }
            var state = new this.core.State(src, this, env);
            this.core.process(state);
            return state.tokens;
        };
        MarkdownIt3.prototype.render = function(src, env) {
            env = env || {};
            return this.renderer.render(this.parse(src, env), this.options, env);
        };
        MarkdownIt3.prototype.parseInline = function(src, env) {
            var state = new this.core.State(src, this, env);
            state.inlineMode = true;
            this.core.process(state);
            return state.tokens;
        };
        MarkdownIt3.prototype.renderInline = function(src, env) {
            env = env || {};
            return this.renderer.render(this.parseInline(src, env), this.options, env);
        };
        module2.exports = MarkdownIt3;
    }
});
// node_modules/markdown-it/index.js
var require_markdown_it = __commonJS({
    "node_modules/markdown-it/index.js" (exports1, module2) {
        "use strict";
        module2.exports = require_lib();
    }
});
// index.ts
__export(exports, {
    Ast: ()=>ast_default,
    Tag: ()=>Tag,
    Tokenizer: ()=>Tokenizer,
    createElement: ()=>createElement,
    default: ()=>Markdoc,
    format: ()=>format,
    functions: ()=>functions_default,
    globalAttributes: ()=>globalAttributes,
    nodes: ()=>schema_exports,
    parse: ()=>parse3,
    parseTags: ()=>parseTags,
    renderers: ()=>renderers_default,
    resolve: ()=>resolve2,
    tags: ()=>tags_default,
    transform: ()=>transform2,
    transformer: ()=>transformer_default,
    transforms: ()=>transforms_default,
    truthy: ()=>truthy,
    validate: ()=>validate,
    validator: ()=>validator
});
// src/ast/base.ts
var base_exports = {};
__export(base_exports, {
    getAstValues: ()=>getAstValues,
    isAst: ()=>isAst,
    isFunction: ()=>isFunction,
    isVariable: ()=>isVariable,
    resolve: ()=>resolve
});
function isAst(value) {
    return !!value?.$$mdtype;
}
function isFunction(value) {
    return !!(value?.$$mdtype === "Function");
}
function isVariable(value) {
    return !!(value?.$$mdtype === "Variable");
}
function* getAstValues(value) {
    if (value == null || typeof value !== "object") return;
    if (Array.isArray(value)) for (const v of value)yield* getAstValues(v);
    if (isAst(value)) yield value;
    if (Object.getPrototypeOf(value) !== Object.prototype) return;
    for (const v of Object.values(value))yield* getAstValues(v);
}
function resolve(value, config = {}) {
    if (value == null || typeof value !== "object") return value;
    if (Array.isArray(value)) return value.map((item2)=>resolve(item2, config));
    if (isAst(value) && value?.resolve instanceof Function) return value.resolve(config);
    if (Object.getPrototypeOf(value) !== Object.prototype) return value;
    const output = {};
    for (const [k, v] of Object.entries(value))output[k] = resolve(v, config);
    return output;
}
// src/tag.ts
var Tag = class {
    constructor(name = "div", attributes = {}, children = []){
        this.$$mdtype = "Tag";
        this.name = name;
        this.attributes = attributes;
        this.children = children;
    }
};
Tag.isTag = (tag)=>{
    return !!(tag?.$$mdtype === "Tag");
};
// src/schema-types/class.ts
var Class = class {
    validate(value) {
        if (typeof value === "string" || typeof value === "object") return [];
        return [
            {
                id: "attribute-type-invalid",
                level: "error",
                message: `Attribute 'class' must be type 'string | object'`
            }
        ];
    }
    transform(value) {
        if (!value || typeof value === "string") return value;
        const classes = [];
        for (const [k, v] of Object.entries(value ?? {}))if (v) classes.push(k);
        return classes.join(" ");
    }
};
// src/schema-types/id.ts
var Id = class {
    validate(value) {
        if (typeof value === "string" && value.match(/^[a-zA-Z]/)) return [];
        return [
            {
                id: "attribute-value-invalid",
                level: "error",
                message: "The 'id' attribute must start with a letter"
            }
        ];
    }
};
// src/utils.ts
var import_tag = __toModule(require_tag());
// src/ast/variable.ts
var Variable = class {
    constructor(path = []){
        this.$$mdtype = "Variable";
        this.path = path;
    }
    resolve({ variables } = {}) {
        return variables instanceof Function ? variables(this.path) : this.path.reduce((obj = {}, key)=>obj[key], variables);
    }
};
// src/ast/function.ts
var Function2 = class {
    constructor(name, parameters){
        this.$$mdtype = "Function";
        this.name = name;
        this.parameters = parameters;
    }
    resolve(config = {}) {
        const fn = config?.functions?.[this.name];
        if (!fn) return null;
        const parameters = resolve(this.parameters, config);
        return fn.transform?.(parameters, config);
    }
};
// src/utils.ts
var STATES;
(function(STATES2) {
    STATES2[STATES2["normal"] = 0] = "normal";
    STATES2[STATES2["string"] = 1] = "string";
    STATES2[STATES2["escape"] = 2] = "escape";
})(STATES || (STATES = {}));
var OPEN = "{%";
var CLOSE = "%}";
var IDENTIFIER_REGEX = /^[a-zA-Z0-9_-]+$/;
function isIdentifier(s2) {
    return typeof s2 === "string" && IDENTIFIER_REGEX.test(s2);
}
function isPromise(a) {
    return a && typeof a === "object" && typeof a.then === "function";
}
function findTagEnd(content, start = 0) {
    let state = 0;
    for(let pos = start; pos < content.length; pos++){
        const char = content[pos];
        switch(state){
            case 1:
                switch(char){
                    case '"':
                        state = 0;
                        break;
                    case "\\":
                        state = 2;
                        break;
                }
                break;
            case 2:
                state = 1;
                break;
            case 0:
                if (char === '"') state = 1;
                else if (content.startsWith(CLOSE, pos)) return pos;
        }
    }
    return null;
}
function parseTag(content, line, contentStart) {
    try {
        return (0, import_tag.parse)(content, {
            Variable,
            Function: Function2
        });
    } catch (error2) {
        if (!(error2 instanceof import_tag.SyntaxError)) throw error2;
        const { message, location: { start, end } } = error2;
        const location = {
            start: {
                line,
                character: start.offset + contentStart
            },
            end: {
                line: line + 1,
                character: end.offset + contentStart
            }
        };
        return {
            type: "error",
            meta: {
                error: {
                    message,
                    location
                }
            }
        };
    }
}
function parseTags(content, firstLine = 0) {
    let line = firstLine + 1;
    const output = [];
    let start = 0;
    for(let pos = 0; pos < content.length; pos++){
        if (content[pos] === "\n") {
            line++;
            continue;
        }
        if (!content.startsWith(OPEN, pos)) continue;
        const end = findTagEnd(content, pos);
        if (end == null) {
            pos = pos + OPEN.length;
            continue;
        }
        const text2 = content.slice(pos, end + CLOSE.length);
        const inner = content.slice(pos + OPEN.length, end);
        const lineStart = content.lastIndexOf("\n", pos);
        const lineEnd = content.indexOf("\n", end);
        const lineContent = content.slice(lineStart, lineEnd);
        const tag = parseTag(inner.trim(), line, pos - lineStart);
        const precedingTextEnd = lineContent.trim() === text2 ? lineStart : pos;
        const precedingText = content.slice(start, precedingTextEnd);
        output.push({
            type: "text",
            start,
            end: pos - 1,
            content: precedingText
        });
        output.push({
            map: [
                line,
                line + 1
            ],
            position: {
                start: pos - lineStart,
                end: pos - lineStart + text2.length
            },
            start: pos,
            end: pos + text2.length - 1,
            info: text2,
            ...tag
        });
        start = end + CLOSE.length;
        pos = start - 1;
    }
    output.push({
        type: "text",
        start,
        end: content.length - 1,
        content: content.slice(start)
    });
    return output;
}
// src/transformer.ts
var globalAttributes = {
    class: {
        type: Class,
        render: true
    },
    id: {
        type: Id,
        render: true
    }
};
var transformer_default = {
    findSchema (node2, { nodes = {}, tags = {} } = {}) {
        return node2.tag ? tags[node2.tag] : nodes[node2.type];
    },
    attributes (node2, config = {}) {
        const schema = this.findSchema(node2, config) ?? {};
        const output = {};
        const attrs = {
            ...globalAttributes,
            ...schema.attributes
        };
        for (const [key, attr] of Object.entries(attrs)){
            if (attr.render == false) continue;
            const name = typeof attr.render === "string" ? attr.render : key;
            let value = node2.attributes[key];
            if (typeof attr.type === "function") {
                const instance = new attr.type();
                if (instance.transform) {
                    value = instance.transform(value, config);
                }
            }
            value = value === void 0 ? attr.default : value;
            if (value === void 0) continue;
            output[name] = value;
        }
        if (schema.slots) {
            for (const [key, slot2] of Object.entries(schema.slots)){
                const name = typeof slot2.render === "string" ? slot2.render : key;
                if (node2.slots[key]) output[name] = this.node(node2.slots[key], config);
            }
        }
        return output;
    },
    children (node2, config = {}) {
        const children = node2.children.flatMap((child)=>this.node(child, config));
        if (children.some(isPromise)) {
            return Promise.all(children);
        }
        return children;
    },
    node (node2, config = {}) {
        const schema = this.findSchema(node2, config) ?? {};
        if (schema && schema.transform instanceof Function) return schema.transform(node2, config);
        const children = this.children(node2, config);
        if (!schema || !schema.render) return children;
        const attributes = this.attributes(node2, config);
        if (isPromise(attributes) || isPromise(children)) {
            return Promise.all([
                attributes,
                children
            ]).then((values)=>new Tag(schema.render, ...values));
        }
        return new Tag(schema.render, attributes, children);
    }
};
// src/ast/node.ts
var Node = class {
    constructor(type = "node", attributes = {}, children = [], tag){
        this.$$mdtype = "Node";
        this.errors = [];
        this.lines = [];
        this.inline = false;
        this.attributes = attributes;
        this.children = children;
        this.type = type;
        this.tag = tag;
        this.annotations = [];
        this.slots = {};
    }
    *walk() {
        for (const child of [
            ...Object.values(this.slots),
            ...this.children
        ]){
            yield child;
            yield* child.walk();
        }
    }
    push(node2) {
        this.children.push(node2);
    }
    resolve(config = {}) {
        return Object.assign(new Node(), this, {
            children: this.children.map((child)=>child.resolve(config)),
            attributes: resolve(this.attributes, config)
        });
    }
    findSchema(config = {}) {
        return transformer_default.findSchema(this, config);
    }
    transformAttributes(config = {}) {
        return transformer_default.attributes(this, config);
    }
    transformChildren(config) {
        return transformer_default.children(this, config);
    }
    transform(config) {
        return transformer_default.node(this, config);
    }
};
// src/ast/index.ts
var AstTypes = {
    Function: Function2,
    Node,
    Variable
};
function reviver(_, value) {
    if (!value) return value;
    const klass = AstTypes[value.$$mdtype];
    return klass ? Object.assign(new klass(), value) : value;
}
function fromJSON(text2) {
    return JSON.parse(text2, reviver);
}
var ast_default = {
    ...AstTypes,
    ...base_exports,
    fromJSON
};
// src/formatter.ts
var SPACE = " ";
var SEP = ", ";
var NL = "\n";
var OL = ".";
var UL = "-";
var MAX_TAG_OPENING_WIDTH = 80;
var WRAPPING_TYPES = [
    "strong",
    "em",
    "s"
];
var max = (a, b)=>Math.max(a, b);
var increment = (o, n = 2)=>({
        ...o,
        indent: (o.indent || 0) + n
    });
function* formatChildren(a, options) {
    for (const child of a.children){
        yield* formatValue(child, options);
    }
}
function* formatInline(g) {
    yield [
        ...g
    ].join("").trim();
}
function* formatTableRow(items) {
    yield `| ${items.join(" | ")} |`;
}
function formatScalar(v) {
    if (ast_default.isAst(v)) {
        return format(v);
    }
    if (v === null) {
        return "null";
    }
    if (Array.isArray(v)) {
        return "[" + v.map(formatScalar).join(SEP) + "]";
    }
    if (typeof v === "object") {
        return "{" + Object.entries(v).map(([key, value])=>`${isIdentifier(key) ? key : `"${key}"`}: ${formatScalar(value)}`).join(SEP) + "}";
    }
    return JSON.stringify(v);
}
function formatAnnotationValue(a) {
    if (a.name === "primary") return formatScalar(a.value);
    if (a.name === "id" && typeof a.value === "string" && isIdentifier(a.value)) return "#" + a.value;
    if (a.type === "class" && isIdentifier(a.name)) return "." + a.name;
    return `${a.name}=${formatScalar(a.value)}`;
}
function* formatAttributes(n) {
    for (const [key, value] of Object.entries(n.attributes)){
        if (key === "class" && typeof value === "object" && !ast_default.isAst(value)) for (const name of Object.keys(value)){
            yield formatAnnotationValue({
                type: "class",
                name,
                value
            });
        }
        else yield formatAnnotationValue({
            type: "attribute",
            name: key,
            value
        });
    }
}
function* formatAnnotations(n) {
    if (n.annotations.length) {
        yield OPEN + SPACE;
        yield n.annotations.map(formatAnnotationValue).join(SPACE);
        yield SPACE + CLOSE;
    }
}
function* formatVariable(v) {
    yield "$";
    yield v.path.map((p, i)=>{
        if (i === 0) return p;
        if (isIdentifier(p)) return "." + p;
        if (typeof p === "number") return `[${p}]`;
        return `["${p}"]`;
    }).join("");
}
function* formatFunction(f) {
    yield f.name;
    yield "(";
    yield Object.values(f.parameters).map(formatScalar).join(SEP);
    yield ")";
}
function* trimStart(g) {
    let n;
    do {
        const { value, done } = g.next();
        if (done) return;
        n = value.trimStart();
    }while (!n.length);
    yield n;
    yield* g;
}
function* escapeMarkdownCharacters(s2, characters) {
    yield s2.replace(characters, "\\$&").replace(new RegExp("\xa0", "g"), "&nbsp;");
}
function* formatNode(n, o = {}) {
    const no = {
        ...o,
        parent: n
    };
    const indent = SPACE.repeat(no.indent || 0);
    switch(n.type){
        case "document":
            {
                if (n.attributes.frontmatter && n.attributes.frontmatter.length) {
                    yield "---" + NL + n.attributes.frontmatter + NL + "---" + NL + NL;
                }
                yield* trimStart(formatChildren(n, no));
                break;
            }
        case "heading":
            {
                yield NL;
                yield indent;
                yield "#".repeat(n.attributes.level || 1);
                yield SPACE;
                yield* trimStart(formatChildren(n, no));
                yield* formatAnnotations(n);
                yield NL;
                break;
            }
        case "paragraph":
            {
                yield NL;
                yield* formatChildren(n, no);
                yield* formatAnnotations(n);
                yield NL;
                break;
            }
        case "inline":
            {
                yield indent;
                yield* formatChildren(n, no);
                break;
            }
        case "image":
            {
                yield "!";
                yield "[";
                yield* formatValue(n.attributes.alt, no);
                yield "]";
                yield "(";
                yield* typeof n.attributes.src === "string" ? escapeMarkdownCharacters(n.attributes.src, /[()]/) : formatValue(n.attributes.src, no);
                if (n.attributes.title) {
                    yield SPACE + `"${n.attributes.title}"`;
                }
                yield ")";
                break;
            }
        case "link":
            {
                yield "[";
                yield* formatChildren(n, no);
                yield "]";
                yield "(";
                yield* typeof n.attributes.href === "string" ? escapeMarkdownCharacters(n.attributes.href, /[()]/g) : formatValue(n.attributes.href, no);
                if (n.attributes.title) {
                    yield SPACE + `"${n.attributes.title}"`;
                }
                yield ")";
                break;
            }
        case "text":
            {
                const { content } = n.attributes;
                if (ast_default.isAst(content)) {
                    yield OPEN + SPACE;
                    yield* formatValue(content, no);
                    yield SPACE + CLOSE;
                } else {
                    if (o.parent && WRAPPING_TYPES.includes(o.parent.type)) {
                        yield* escapeMarkdownCharacters(content, /[*_~]/g);
                    } else {
                        yield* escapeMarkdownCharacters(content, /^[*>#]/);
                    }
                }
                break;
            }
        case "blockquote":
            {
                const prefix = ">" + SPACE;
                yield n.children.map((child)=>format(child, no).trimStart()).map((d)=>NL + indent + prefix + d).join(indent + prefix);
                break;
            }
        case "hr":
            {
                yield NL;
                yield indent;
                yield "---";
                yield NL;
                break;
            }
        case "fence":
            {
                yield NL;
                yield indent;
                const innerFence = n.attributes.content.match(/`{3,}/g) || [];
                const innerFenceLength = innerFence.map((s2)=>s2.length).reduce(max, 0);
                const boundary = "`".repeat(innerFenceLength ? innerFenceLength + 1 : 3);
                yield boundary;
                if (n.attributes.language) yield n.attributes.language;
                if (n.annotations.length) yield SPACE;
                yield* formatAnnotations(n);
                yield NL;
                yield indent;
                yield n.attributes.content.split(NL).join(NL + indent);
                yield boundary;
                yield NL;
                break;
            }
        case "tag":
            {
                if (!n.inline) {
                    yield NL;
                    yield indent;
                }
                const open = OPEN + SPACE;
                const tag = [
                    open + n.tag,
                    ...formatAttributes(n)
                ];
                const inlineTag = tag.join(SPACE);
                const isLongTagOpening = inlineTag.length + open.length * 2 > (o.maxTagOpeningWidth || MAX_TAG_OPENING_WIDTH);
                yield (!n.inline && isLongTagOpening ? tag.join(NL + SPACE.repeat(open.length) + indent) : inlineTag) + SPACE + (n.children.length ? "" : "/") + CLOSE;
                if (n.children.length) {
                    yield* formatChildren(n, no.allowIndentation ? increment(no) : no);
                    if (!n.inline) {
                        yield indent;
                    }
                    yield OPEN + SPACE + "/" + n.tag + SPACE + CLOSE;
                }
                if (!n.inline) {
                    yield NL;
                }
                break;
            }
        case "list":
            {
                for(let i = 0; i < n.children.length; i++){
                    const prefix = n.attributes.ordered ? `${i === 0 ? n.attributes.start ?? "1" : "1"}${n.attributes.marker ?? OL}` : n.attributes.marker ?? UL;
                    const d = format(n.children[i], increment(no, prefix.length + 1)).trim();
                    yield NL + indent + prefix + " " + d;
                }
                yield NL;
                break;
            }
        case "item":
            {
                for(let i = 0; i < n.children.length; i++){
                    yield* formatValue(n.children[i], no);
                    if (i === 0) yield* formatAnnotations(n);
                }
                break;
            }
        case "strong":
            {
                yield n.attributes.marker ?? "**";
                yield* formatInline(formatChildren(n, no));
                yield n.attributes.marker ?? "**";
                break;
            }
        case "em":
            {
                yield n.attributes.marker ?? "*";
                yield* formatInline(formatChildren(n, no));
                yield n.attributes.marker ?? "*";
                break;
            }
        case "code":
            {
                yield "`";
                yield* formatInline(formatValue(n.attributes.content, no));
                yield "`";
                break;
            }
        case "s":
            {
                yield "~~";
                yield* formatInline(formatChildren(n, no));
                yield "~~";
                break;
            }
        case "hardbreak":
            {
                yield "\\" + NL;
                yield indent;
                break;
            }
        case "softbreak":
            {
                yield NL;
                yield indent;
                break;
            }
        case "table":
            {
                const table3 = [
                    ...formatChildren(n, increment(no))
                ];
                if (o.parent && o.parent.type === "tag" && o.parent.tag === "table") {
                    for(let i = 0; i < table3.length; i++){
                        const row = table3[i];
                        if (typeof row === "string") {
                            if (row.trim().length) {
                                yield NL;
                                yield row;
                            }
                        } else {
                            if (i !== 0) {
                                yield NL;
                                yield indent + "---";
                            }
                            for (const d of row){
                                yield NL + indent + UL + " " + d;
                            }
                        }
                    }
                    yield NL;
                } else {
                    yield NL;
                    const [head, ...rows] = table3;
                    const ml = table3.map((arr)=>arr.map((s2)=>s2.length).reduce(max)).reduce(max);
                    yield* formatTableRow(head.map((h)=>h + SPACE.repeat(ml - h.length)));
                    yield NL;
                    yield* formatTableRow(head.map(()=>"-".repeat(ml)));
                    yield NL;
                    for (const row of rows){
                        yield* formatTableRow(row.map((r)=>r + SPACE.repeat(ml - r.length)));
                        yield NL;
                    }
                }
                break;
            }
        case "thead":
            {
                const [head] = [
                    ...formatChildren(n, no)
                ];
                yield head || [];
                break;
            }
        case "tr":
            {
                yield [
                    ...formatChildren(n, no)
                ];
                break;
            }
        case "td":
        case "th":
            {
                yield [
                    ...formatChildren(n, no),
                    ...formatAnnotations(n)
                ].join("").trim();
                break;
            }
        case "tbody":
            {
                yield* formatChildren(n, no);
                break;
            }
        case "comment":
            {
                yield "<!-- " + n.attributes.content + " -->\n";
                break;
            }
        case "error":
        case "node":
            break;
    }
}
function* formatValue(v, o = {}) {
    switch(typeof v){
        case "undefined":
            break;
        case "boolean":
        case "number":
        case "string":
            {
                yield v.toString();
                break;
            }
        case "object":
            {
                if (v === null) break;
                if (Array.isArray(v)) {
                    for (const n of v)yield* formatValue(n, o);
                    break;
                }
                switch(v.$$mdtype){
                    case "Function":
                        {
                            yield* formatFunction(v);
                            break;
                        }
                    case "Node":
                        yield* formatNode(v, o);
                        break;
                    case "Variable":
                        {
                            yield* formatVariable(v);
                            break;
                        }
                    default:
                        throw new Error(`Unimplemented: "${v.$$mdtype}"`);
                }
                break;
            }
    }
}
function format(v, options) {
    let doc = "";
    for (const s2 of formatValue(v, options))doc += s2;
    return doc.trimStart();
}
// src/tags/conditional.ts
function truthy(value) {
    return value !== false && value !== void 0 && value !== null;
}
function renderConditions(node2) {
    const conditions = [
        {
            condition: node2.attributes.primary,
            children: []
        }
    ];
    for (const child of node2.children){
        if (child.type === "tag" && child.tag === "else") conditions.push({
            condition: "primary" in child.attributes ? child.attributes.primary : true,
            children: []
        });
        else conditions[conditions.length - 1].children.push(child);
    }
    return conditions;
}
var tagIf = {
    attributes: {
        primary: {
            type: Object,
            render: false
        }
    },
    transform (node2, config) {
        const conditions = renderConditions(node2);
        for (const { condition, children } of conditions)if (truthy(condition)) {
            const nodes = children.flatMap((child)=>child.transform(config));
            if (nodes.some(isPromise)) {
                return Promise.all(nodes).then((nodes2)=>nodes2.flat());
            }
            return nodes;
        }
        return [];
    }
};
var tagElse = {
    selfClosing: true,
    attributes: {
        primary: {
            type: Object,
            render: false
        }
    }
};
// src/functions/index.ts
var and = {
    transform (parameters) {
        return Object.values(parameters).every((x)=>truthy(x));
    }
};
var or = {
    transform (parameters) {
        return Object.values(parameters).find((x)=>truthy(x)) !== void 0;
    }
};
var not = {
    parameters: {
        0: {
            required: true
        }
    },
    transform (parameters) {
        return !truthy(parameters[0]);
    }
};
var equals = {
    transform (parameters) {
        const values = Object.values(parameters);
        return values.every((v)=>v === values[0]);
    }
};
var debug = {
    transform (parameters) {
        return JSON.stringify(parameters[0], null, 2);
    }
};
var defaultFn = {
    transform (parameters) {
        return parameters[0] === void 0 ? parameters[1] : parameters[0];
    }
};
var functions_default = {
    and,
    or,
    not,
    equals,
    default: defaultFn,
    debug
};
// src/transforms/table.ts
function convertToRow(node2, cellType = "td") {
    node2.type = "tr";
    node2.attributes = {};
    for (const cell of node2.children)cell.type = cellType;
    return node2;
}
function transform(document2) {
    for (const node2 of document2.walk()){
        if (node2.type !== "tag" || node2.tag !== "table") continue;
        const [first, ...rest] = node2.children;
        if (!first || first.type === "table") continue;
        const table3 = new ast_default.Node("table", node2.attributes, [
            new ast_default.Node("thead"),
            new ast_default.Node("tbody")
        ]);
        const [thead2, tbody2] = table3.children;
        if (first.type === "list") thead2.push(convertToRow(first, "th"));
        for (const row of rest){
            if (row.type === "list") convertToRow(row);
            else if (row.type === "tag" && row.tag === "if") {
                const children = [];
                for (const child of row.children){
                    if (child.type === "hr") continue;
                    if (child.type === "list") convertToRow(child);
                    children.push(child);
                }
                row.children = children;
            } else continue;
            tbody2.push(row);
        }
        node2.children = [
            table3
        ];
    }
}
// src/transforms/index.ts
var transforms_default = [
    transform
];
// src/parser.ts
var mappings = {
    ordered_list: "list",
    bullet_list: "list",
    code_inline: "code",
    list_item: "item",
    variable: "text"
};
function annotate(node2, attributes) {
    for (const attribute of attributes){
        node2.annotations.push(attribute);
        const { name, value, type } = attribute;
        if (type === "attribute") node2.attributes[name] = value;
        else if (type === "class") if (node2.attributes.class) node2.attributes.class[name] = value;
        else node2.attributes.class = {
            [name]: value
        };
    }
}
function handleAttrs(token, type) {
    switch(type){
        case "heading":
            return {
                level: Number(token.tag.replace("h", ""))
            };
        case "list":
            {
                const attrs = token.attrs ? Object.fromEntries(token.attrs) : void 0;
                const ordered = token.type.startsWith("ordered");
                return ordered && attrs?.start ? {
                    ordered: true,
                    start: attrs.start,
                    marker: token.markup
                } : {
                    ordered,
                    marker: token.markup
                };
            }
        case "link":
            {
                const attrs = Object.fromEntries(token.attrs);
                return attrs.title ? {
                    href: attrs.href,
                    title: attrs.title
                } : {
                    href: attrs.href
                };
            }
        case "image":
            {
                const attrs = Object.fromEntries(token.attrs);
                return attrs.title ? {
                    alt: token.content,
                    src: attrs.src,
                    title: attrs.title
                } : {
                    alt: token.content,
                    src: attrs.src
                };
            }
        case "em":
        case "strong":
            return {
                marker: token.markup
            };
        case "text":
        case "code":
        case "comment":
            return {
                content: (token.meta || {}).variable || token.content
            };
        case "fence":
            {
                const [language] = token.info.split(" ", 1);
                return language === "" || language === OPEN ? {
                    content: token.content
                } : {
                    content: token.content,
                    language
                };
            }
        case "td":
        case "th":
            {
                if (token.attrs) {
                    const attrs = Object.fromEntries(token.attrs);
                    let align;
                    if (attrs.style) {
                        if (attrs.style.includes("left")) {
                            align = "left";
                        } else if (attrs.style.includes("center")) {
                            align = "center";
                        } else if (attrs.style.includes("right")) {
                            align = "right";
                        }
                    }
                    if (align) {
                        return {
                            align
                        };
                    }
                }
                return {};
            }
        default:
            return {};
    }
}
function handleToken(token, nodes, file, handleSlots, inlineParent) {
    if (token.type === "frontmatter") {
        nodes[0].attributes.frontmatter = token.content;
        return;
    }
    if (token.hidden || token.type === "text" && token.content === "") return;
    const errors = token.errors || [];
    const parent = nodes[nodes.length - 1];
    const { tag, attributes, error: error2 } = token.meta || {};
    if (token.type === "annotation") {
        if (inlineParent) return annotate(inlineParent, attributes);
        return parent.errors.push({
            id: "no-inline-annotations",
            level: "error",
            message: `Can't apply inline annotations to '${parent.type}'`
        });
    }
    let typeName = token.type.replace(/_(open|close)$/, "");
    if (mappings[typeName]) typeName = mappings[typeName];
    if (typeName === "error") {
        const { message, location } = error2;
        errors.push({
            id: "parse-error",
            level: "critical",
            message,
            location
        });
    }
    if (token.nesting < 0) {
        if (parent.type === typeName && parent.tag === tag) {
            if (parent.lines && token.map) parent.lines.push(...token.map);
            return nodes.pop();
        }
        errors.push({
            id: "missing-opening",
            level: "critical",
            message: `Node '${typeName}' is missing opening`
        });
    }
    const attrs = handleAttrs(token, typeName);
    const node2 = new Node(typeName, attrs, void 0, tag || void 0);
    const { position = {} } = token;
    node2.errors = errors;
    node2.lines = token.map || parent.lines || [];
    node2.location = {
        file,
        start: {
            line: node2.lines[0],
            character: position.start
        },
        end: {
            line: node2.lines[1],
            character: position.end
        }
    };
    if (inlineParent) node2.inline = true;
    if (attributes && [
        "tag",
        "fence",
        "image"
    ].includes(typeName)) annotate(node2, attributes);
    if (handleSlots && tag === "slot" && typeof node2.attributes.primary === "string") parent.slots[node2.attributes.primary] = node2;
    else parent.push(node2);
    if (token.nesting > 0) nodes.push(node2);
    if (!Array.isArray(token.children)) return;
    inlineParent = parent;
    nodes.push(node2);
    const isLeafNode = typeName === "image";
    if (!isLeafNode) {
        for (const child of token.children)handleToken(child, nodes, file, handleSlots, inlineParent);
    }
    nodes.pop();
}
function parser(tokens, args) {
    const doc = new Node("document");
    const nodes = [
        doc
    ];
    if (typeof args === "string") args = {
        file: args
    };
    for (const token of tokens)handleToken(token, nodes, args?.file, args?.slots);
    if (nodes.length > 1) for (const node2 of nodes.slice(1))node2.errors.push({
        id: "missing-closing",
        level: "critical",
        message: `Node '${node2.tag || node2.type}' is missing closing`
    });
    for (const transform3 of transforms_default)transform3(doc);
    return doc;
}
// src/schema.ts
var schema_exports = {};
__export(schema_exports, {
    blockquote: ()=>blockquote,
    code: ()=>code,
    comment: ()=>comment,
    document: ()=>document,
    em: ()=>em,
    error: ()=>error,
    fence: ()=>fence,
    hardbreak: ()=>hardbreak,
    heading: ()=>heading,
    hr: ()=>hr,
    image: ()=>image,
    inline: ()=>inline,
    item: ()=>item,
    link: ()=>link,
    list: ()=>list,
    node: ()=>node,
    paragraph: ()=>paragraph,
    s: ()=>s,
    softbreak: ()=>softbreak,
    strong: ()=>strong,
    table: ()=>table,
    tbody: ()=>tbody,
    td: ()=>td,
    text: ()=>text,
    th: ()=>th,
    thead: ()=>thead,
    tr: ()=>tr
});
var document = {
    render: "article",
    children: [
        "heading",
        "paragraph",
        "image",
        "table",
        "tag",
        "fence",
        "blockquote",
        "comment",
        "list",
        "hr"
    ],
    attributes: {
        frontmatter: {
            render: false
        }
    }
};
var heading = {
    children: [
        "inline"
    ],
    attributes: {
        level: {
            type: Number,
            render: false,
            required: true
        }
    },
    transform (node2, config) {
        return new Tag(`h${node2.attributes["level"]}`, node2.transformAttributes(config), node2.transformChildren(config));
    }
};
var paragraph = {
    render: "p",
    children: [
        "inline"
    ]
};
var image = {
    render: "img",
    attributes: {
        src: {
            type: String,
            required: true
        },
        alt: {
            type: String
        },
        title: {
            type: String
        }
    }
};
var fence = {
    render: "pre",
    attributes: {
        content: {
            type: String,
            render: false,
            required: true
        },
        language: {
            type: String,
            render: "data-language"
        },
        process: {
            type: Boolean,
            render: false,
            default: true
        }
    },
    transform (node2, config) {
        const attributes = node2.transformAttributes(config);
        const children = node2.children.length ? node2.transformChildren(config) : [
            node2.attributes.content
        ];
        return new Tag("pre", attributes, children);
    }
};
var blockquote = {
    render: "blockquote",
    children: [
        "heading",
        "paragraph",
        "image",
        "table",
        "tag",
        "fence",
        "blockquote",
        "list",
        "hr"
    ]
};
var item = {
    render: "li",
    children: [
        "inline",
        "heading",
        "paragraph",
        "image",
        "table",
        "tag",
        "fence",
        "blockquote",
        "list",
        "hr"
    ]
};
var list = {
    children: [
        "item"
    ],
    attributes: {
        ordered: {
            type: Boolean,
            render: false,
            required: true
        },
        start: {
            type: Number
        },
        marker: {
            type: String,
            render: false
        }
    },
    transform (node2, config) {
        return new Tag(node2.attributes.ordered ? "ol" : "ul", node2.transformAttributes(config), node2.transformChildren(config));
    }
};
var hr = {
    render: "hr"
};
var table = {
    render: "table"
};
var td = {
    render: "td",
    children: [
        "inline",
        "heading",
        "paragraph",
        "image",
        "table",
        "tag",
        "fence",
        "blockquote",
        "list",
        "hr"
    ],
    attributes: {
        colspan: {
            type: Number
        },
        rowspan: {
            type: Number
        },
        align: {
            type: String
        }
    }
};
var th = {
    render: "th",
    attributes: {
        width: {
            type: Number
        },
        align: {
            type: String
        }
    }
};
var tr = {
    render: "tr",
    children: [
        "th",
        "td"
    ]
};
var tbody = {
    render: "tbody",
    children: [
        "tr",
        "tag"
    ]
};
var thead = {
    render: "thead",
    children: [
        "tr"
    ]
};
var strong = {
    render: "strong",
    children: [
        "em",
        "s",
        "link",
        "code",
        "text",
        "tag"
    ],
    attributes: {
        marker: {
            type: String,
            render: false
        }
    }
};
var em = {
    render: "em",
    children: [
        "strong",
        "s",
        "link",
        "code",
        "text",
        "tag"
    ],
    attributes: {
        marker: {
            type: String,
            render: false
        }
    }
};
var s = {
    render: "s",
    children: [
        "strong",
        "em",
        "link",
        "code",
        "text",
        "tag"
    ]
};
var inline = {
    children: [
        "strong",
        "em",
        "s",
        "code",
        "text",
        "tag",
        "link",
        "image",
        "hardbreak",
        "softbreak",
        "comment"
    ]
};
var link = {
    render: "a",
    children: [
        "strong",
        "em",
        "s",
        "code",
        "text",
        "tag"
    ],
    attributes: {
        href: {
            type: String,
            required: true
        },
        title: {
            type: String
        }
    }
};
var code = {
    render: "code",
    attributes: {
        content: {
            type: String,
            render: false,
            required: true
        }
    },
    transform (node2, config) {
        const attributes = node2.transformAttributes(config);
        return new Tag("code", attributes, [
            node2.attributes.content
        ]);
    }
};
var text = {
    attributes: {
        content: {
            type: String,
            required: true
        }
    },
    transform (node2) {
        return node2.attributes.content;
    }
};
var hardbreak = {
    render: "br"
};
var softbreak = {
    transform () {
        return " ";
    }
};
var comment = {
    attributes: {
        content: {
            type: String,
            required: true
        }
    }
};
var error = {};
var node = {};
// src/renderers/html.ts
var import_markdown_it = __toModule(require_markdown_it());
var { escapeHtml } = (0, import_markdown_it.default)().utils;
var voidElements = new Set([
    "area",
    "base",
    "br",
    "col",
    "embed",
    "hr",
    "img",
    "input",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
]);
function render(node2) {
    if (typeof node2 === "string" || typeof node2 === "number") return escapeHtml(String(node2));
    if (Array.isArray(node2)) return node2.map(render).join("");
    if (node2 === null || typeof node2 !== "object" || !Tag.isTag(node2)) return "";
    const { name, attributes, children = [] } = node2;
    if (!name) return render(children);
    let output = `<${name}`;
    for (const [k, v] of Object.entries(attributes ?? {}))output += ` ${k}="${escapeHtml(String(v))}"`;
    output += ">";
    if (voidElements.has(name)) return output;
    if (children.length) output += render(children);
    output += `</${name}>`;
    return output;
}
// src/renderers/react/react.ts
function tagName(name, components) {
    return typeof name !== "string" ? name : name[0] !== name[0].toUpperCase() ? name : components instanceof Function ? components(name) : components[name];
}
function dynamic(node2, React, { components = {} } = {}) {
    function deepRender2(value) {
        if (value == null || typeof value !== "object") return value;
        if (Array.isArray(value)) return value.map((item2)=>deepRender2(item2));
        if (value.$$mdtype === "Tag") return render3(value);
        if (typeof value !== "object") return value;
        const output = {};
        for (const [k, v] of Object.entries(value))output[k] = deepRender2(v);
        return output;
    }
    function render3(node3) {
        if (Array.isArray(node3)) return React.createElement(React.Fragment, null, ...node3.map(render3));
        if (node3 === null || typeof node3 !== "object" || !Tag.isTag(node3)) return node3;
        const { name, attributes: { class: className, ...attrs } = {}, children = [] } = node3;
        if (className) attrs.className = className;
        return React.createElement(tagName(name, components), Object.keys(attrs).length == 0 ? null : deepRender2(attrs), ...children.map(render3));
    }
    return render3(node2);
}
// src/renderers/react/static.ts
function tagName2(name, components) {
    return typeof name !== "string" ? "Fragment" : name[0] !== name[0].toUpperCase() ? name : components instanceof Function ? components(name) : components[name];
}
function renderArray(children) {
    return children.map(render2).join(", ");
}
function deepRender(value) {
    if (value == null || typeof value !== "object") return JSON.stringify(value);
    if (Array.isArray(value)) return `[${value.map((item2)=>deepRender(item2)).join(", ")}]`;
    if (value.$$mdtype === "Tag") return render2(value);
    if (typeof value !== "object") return JSON.stringify(value);
    const object = Object.entries(value).map(([k, v])=>[
            JSON.stringify(k),
            deepRender(v)
        ].join(": ")).join(", ");
    return `{${object}}`;
}
function render2(node2) {
    if (Array.isArray(node2)) return `React.createElement(React.Fragment, null, ${renderArray(node2)})`;
    if (node2 === null || typeof node2 !== "object" || !Tag.isTag(node2)) return JSON.stringify(node2);
    const { name, attributes: { class: className, ...attrs } = {}, children = [] } = node2;
    if (className) attrs.className = className;
    return `React.createElement(
    tagName(${JSON.stringify(name)}, components),
    ${Object.keys(attrs).length == 0 ? "null" : deepRender(attrs)},
    ${renderArray(children)})`;
}
function reactStatic(node2) {
    return `
  (({components = {}} = {}) => {
    ${tagName2}
    return ${render2(node2)};
  })
`;
}
// src/renderers/index.ts
var renderers_default = {
    html: render,
    react: dynamic,
    reactStatic
};
// src/tags/partial.ts
var PartialFile = class {
    validate(file, config) {
        const { partials = {} } = config;
        const partial2 = partials[file];
        if (!partial2) return [
            {
                id: "attribute-value-invalid",
                level: "error",
                message: `Partial \`${file}\` not found. The 'file' attribute must be set in \`config.partials\``
            }
        ];
        return [];
    }
};
var partial = {
    inline: false,
    selfClosing: true,
    attributes: {
        file: {
            type: PartialFile,
            render: false,
            required: true
        },
        variables: {
            type: Object,
            render: false
        }
    },
    transform (node2, config) {
        const { partials = {} } = config;
        const { file, variables } = node2.attributes;
        const partial2 = partials[file];
        if (!partial2) return null;
        const scopedConfig = {
            ...config,
            variables: {
                ...config.variables,
                ...variables,
                ["$$partial:filename"]: file
            }
        };
        const transformChildren = (part)=>part.resolve(scopedConfig).transformChildren(scopedConfig);
        return Array.isArray(partial2) ? partial2.flatMap(transformChildren) : transformChildren(partial2);
    }
};
// src/tags/table.ts
var table2 = {
    children: [
        "table"
    ],
    inline: false
};
// src/tags/slot.ts
var slot = {
    attributes: {
        primary: {
            type: String,
            required: true
        }
    }
};
// src/tags/index.ts
var tags_default = {
    else: tagElse,
    if: tagIf,
    partial,
    slot,
    table: table2
};
// src/tokenizer/index.ts
var import_lib = __toModule(require_lib());
// src/tokenizer/plugins/annotations.ts
var import_tag7 = __toModule(require_tag());
function createToken(state, content, contentStart) {
    try {
        const { type, meta, nesting = 0 } = (0, import_tag7.parse)(content, {
            Variable,
            Function: Function2
        });
        const token = state.push(type, "", nesting);
        token.info = content;
        token.meta = meta;
        if (!state.delimiters) {
            state.delimiters = [];
        }
        return token;
    } catch (error2) {
        if (!(error2 instanceof import_tag7.SyntaxError)) throw error2;
        const { message, location: { start, end } } = error2;
        const location = contentStart ? {
            start: {
                offset: start.offset + contentStart
            },
            end: {
                offset: end.offset + contentStart
            }
        } : null;
        const token = state.push("error", "", 0);
        token.meta = {
            error: {
                message,
                location
            }
        };
        return token;
    }
}
function block(state, startLine, endLine, silent) {
    const start = state.bMarks[startLine] + state.tShift[startLine];
    const finish = state.eMarks[startLine];
    if (!state.src.startsWith(OPEN, start)) return false;
    const tagEnd = findTagEnd(state.src, start);
    const lastPossible = state.src.slice(0, finish).trim().length;
    if (!tagEnd || tagEnd < lastPossible - CLOSE.length) return false;
    const contentStart = start + OPEN.length;
    const content = state.src.slice(contentStart, tagEnd).trim();
    const lines = content.split("\n").length;
    if (content[0] === "$") return false;
    if (silent) return true;
    const token = createToken(state, content, contentStart);
    token.map = [
        startLine,
        startLine + lines
    ];
    state.line += lines;
    return true;
}
function inline2(state, silent) {
    if (!state.src.startsWith(OPEN, state.pos)) return false;
    const tagEnd = findTagEnd(state.src, state.pos);
    if (!tagEnd) return false;
    const content = state.src.slice(state.pos + OPEN.length, tagEnd);
    if (!silent) createToken(state, content.trim());
    state.pos = tagEnd + CLOSE.length;
    return true;
}
function core(state) {
    let token;
    for (token of state.tokens){
        if (token.type !== "fence") continue;
        if (token.info.includes(OPEN)) {
            const start = token.info.indexOf(OPEN);
            const end = findTagEnd(token.info, start);
            const content = token.info.slice(start + OPEN.length, end);
            try {
                const { meta } = (0, import_tag7.parse)(content.trim(), {
                    Variable,
                    Function: Function2
                });
                token.meta = meta;
            } catch (error2) {
                if (!(error2 instanceof import_tag7.SyntaxError)) throw error2;
                if (!token.errors) token.errors = [];
                token.errors.push({
                    id: "fence-tag-error",
                    level: "error",
                    message: `Syntax error in fence tag: ${error2.message}`
                });
            }
        }
        if (token?.meta?.attributes?.find((attr)=>attr.name === "process" && !attr.value)) continue;
        token.children = parseTags(token.content, token.map[0]);
    }
}
function plugin(md) {
    md.block.ruler.before("paragraph", "annotations", block, {
        alt: [
            "paragraph",
            "blockquote"
        ]
    });
    md.inline.ruler.push("containers", inline2);
    md.core.ruler.push("annotations", core);
}
// src/tokenizer/plugins/frontmatter.ts
var fence2 = "---";
function getLine(state, n) {
    return state.src.slice(state.bMarks[n], state.eMarks[n]).trim();
}
function findClose(state, endLine) {
    for(let line = 1; line < endLine; line++)if (getLine(state, line) === fence2) return line;
}
function block2(state, startLine, endLine, silent) {
    if (startLine != 0 || getLine(state, 0) != fence2) return false;
    const close = findClose(state, endLine);
    if (!close) return false;
    if (silent) return true;
    const token = state.push("frontmatter", "", 0);
    token.content = state.src.slice(state.eMarks[0], state.bMarks[close]).trim();
    token.map = [
        0,
        close
    ];
    token.hidden = true;
    state.line = close + 1;
    return true;
}
function plugin2(md) {
    md.block.ruler.before("hr", "frontmatter", block2);
}
// src/tokenizer/plugins/comments.ts
var OPEN2 = "<!--";
var CLOSE2 = "-->";
function block3(state, startLine, endLine, silent) {
    const start = state.bMarks[startLine] + state.tShift[startLine];
    if (!state.src.startsWith(OPEN2, start)) return false;
    const close = state.src.indexOf(CLOSE2, start);
    if (!close) return false;
    if (silent) return true;
    const content = state.src.slice(start + OPEN2.length, close);
    const lines = content.split("\n").length;
    const token = state.push("comment", "", 0);
    token.content = content.trim();
    token.map = [
        startLine,
        startLine + lines
    ];
    state.line += lines;
    return true;
}
function inline3(state, silent) {
    if (!state.src.startsWith(OPEN2, state.pos)) return false;
    const close = state.src.indexOf(CLOSE2, state.pos);
    if (!close) return false;
    if (silent) return true;
    const content = state.src.slice(state.pos + OPEN2.length, close);
    const token = state.push("comment", "", 0);
    token.content = content.trim();
    state.pos = close + CLOSE2.length;
    return true;
}
function plugin3(md) {
    md.block.ruler.before("table", "comment", block3, {
        alt: [
            "paragraph"
        ]
    });
    md.inline.ruler.push("comment", inline3);
}
// src/tokenizer/index.ts
var Tokenizer = class {
    constructor(config = {}){
        this.parser = new import_lib.default(config);
        this.parser.use(plugin, "annotations", {});
        this.parser.use(plugin2, "frontmatter", {});
        this.parser.disable([
            "lheading",
            "code"
        ]);
        if (config.allowComments) this.parser.use(plugin3, "comments", {});
    }
    tokenize(content) {
        return this.parser.parse(content.toString(), {});
    }
};
// src/validator.ts
var TypeMappings = {
    String,
    Number,
    Array,
    Object,
    Boolean
};
function validateType(type, value, config) {
    if (!type) return true;
    if (ast_default.isFunction(value) && config.validation?.validateFunctions) {
        const schema = config.functions?.[value.name];
        return !schema?.returns ? true : Array.isArray(schema.returns) ? schema.returns.find((t)=>t === type) !== void 0 : schema.returns === type;
    }
    if (ast_default.isAst(value)) return true;
    if (Array.isArray(type)) return type.some((t)=>validateType(t, value, config));
    if (typeof type === "string") type = TypeMappings[type];
    if (typeof type === "function") {
        const instance = new type();
        if (instance.validate) {
            return instance.validate(value, config);
        }
    }
    return value != null && value.constructor === type;
}
function typeToString(type) {
    if (typeof type === "string") return type;
    if (Array.isArray(type)) return type.map(typeToString).join(" | ");
    return type.name;
}
function validateFunction(fn, config) {
    const schema = config.functions?.[fn.name];
    const errors = [];
    if (!schema) return [
        {
            id: "function-undefined",
            level: "critical",
            message: `Undefined function: '${fn.name}'`
        }
    ];
    if (schema.validate) errors.push(...schema.validate(fn, config));
    if (schema.parameters) {
        for (const [key, value] of Object.entries(fn.parameters)){
            const param = schema.parameters?.[key];
            if (!param) {
                errors.push({
                    id: "parameter-undefined",
                    level: "error",
                    message: `Invalid parameter: '${key}'`
                });
                continue;
            }
            if (ast_default.isAst(value) && !ast_default.isFunction(value)) continue;
            if (param.type) {
                const valid = validateType(param.type, value, config);
                if (valid === false) {
                    errors.push({
                        id: "parameter-type-invalid",
                        level: "error",
                        message: `Parameter '${key}' of '${fn.name}' must be type of '${typeToString(param.type)}'`
                    });
                } else if (Array.isArray(valid)) {
                    errors.push(...valid);
                }
            }
        }
    }
    for (const [key, { required }] of Object.entries(schema.parameters ?? {}))if (required && fn.parameters[key] === void 0) errors.push({
        id: "parameter-missing-required",
        level: "error",
        message: `Missing required parameter: '${key}'`
    });
    return errors;
}
function displayMatches(matches, n) {
    if (matches.length <= n) return JSON.stringify(matches);
    const items = matches.slice(0, n).map((item2)=>JSON.stringify(item2));
    return `[${items.join(",")}, ... ${matches.length - n} more]`;
}
function validator(node2, config) {
    const schema = node2.findSchema(config);
    const errors = [
        ...node2.errors || []
    ];
    if (!schema) {
        errors.push({
            id: node2.tag ? "tag-undefined" : "node-undefined",
            level: "critical",
            message: node2.tag ? `Undefined tag: '${node2.tag}'` : `Undefined node: '${node2.type}'`
        });
        return errors;
    }
    if (schema.inline != void 0 && node2.inline !== schema.inline) errors.push({
        id: "tag-placement-invalid",
        level: "critical",
        message: `'${node2.tag}' tag should be ${schema.inline ? "inline" : "block"}`
    });
    if (schema.selfClosing && node2.children.length > 0) errors.push({
        id: "tag-selfclosing-has-children",
        level: "critical",
        message: `'${node2.tag}' tag should be self-closing`
    });
    const attributes = {
        ...globalAttributes,
        ...schema.attributes
    };
    for (const key of Object.keys(node2.slots)){
        const slot2 = schema.slots?.[key];
        if (!slot2) errors.push({
            id: "slot-undefined",
            level: "error",
            message: `Invalid slot: '${key}'`
        });
    }
    for (let [key, value] of Object.entries(node2.attributes)){
        const attrib = attributes[key];
        if (!attrib) {
            errors.push({
                id: "attribute-undefined",
                level: "error",
                message: `Invalid attribute: '${key}'`
            });
            continue;
        }
        let { type, matches, errorLevel } = attrib;
        if (ast_default.isAst(value)) {
            if (ast_default.isFunction(value) && config.validation?.validateFunctions) errors.push(...validateFunction(value, config));
            else if (ast_default.isVariable(value) && config.variables) {
                let missing = false;
                let variables = config.variables;
                for (const key2 of value.path){
                    if (!Object.prototype.hasOwnProperty.call(variables, key2)) {
                        missing = true;
                        break;
                    }
                    variables = variables[key2];
                }
                if (missing) {
                    errors.push({
                        id: "variable-undefined",
                        level: "error",
                        message: `Undefined variable: '${value.path.join(".")}'`
                    });
                }
            } else continue;
        }
        value = value;
        if (type) {
            const valid = validateType(type, value, config);
            if (valid === false) {
                errors.push({
                    id: "attribute-type-invalid",
                    level: errorLevel || "error",
                    message: `Attribute '${key}' must be type of '${typeToString(type)}'`
                });
            }
            if (Array.isArray(valid)) {
                errors.push(...valid);
            }
        }
        if (typeof matches === "function") matches = matches(config);
        if (Array.isArray(matches) && !matches.includes(value)) errors.push({
            id: "attribute-value-invalid",
            level: errorLevel || "error",
            message: `Attribute '${key}' must match one of ${displayMatches(matches, 8)}. Got '${value}' instead.`
        });
        if (matches instanceof RegExp && !matches.test(value)) errors.push({
            id: "attribute-value-invalid",
            level: errorLevel || "error",
            message: `Attribute '${key}' must match ${matches}. Got '${value}' instead.`
        });
        if (typeof attrib.validate === "function") {
            const attribErrors = attrib.validate(value, config);
            if (Array.isArray(attribErrors)) errors.push(...attribErrors);
        }
    }
    for (const [key, { required }] of Object.entries(attributes))if (required && node2.attributes[key] === void 0) errors.push({
        id: "attribute-missing-required",
        level: "error",
        message: `Missing required attribute: '${key}'`
    });
    if (schema.slots) {
        for (const [key, { required }] of Object.entries(schema.slots))if (required && node2.slots[key] === void 0) errors.push({
            id: "slot-missing-required",
            level: "error",
            message: `Missing required slot: '${key}'`
        });
    }
    for (const { type } of node2.children){
        if (schema.children && type !== "error" && !schema.children.includes(type)) errors.push({
            id: "child-invalid",
            level: "warning",
            message: `Can't nest '${type}' in '${node2.tag || node2.type}'`
        });
    }
    if (schema.validate) {
        const schemaErrors = schema.validate(node2, config);
        if (isPromise(schemaErrors)) {
            return schemaErrors.then((e)=>errors.concat(e));
        }
        errors.push(...schemaErrors);
    }
    return errors;
}
// index.ts
var tokenizer = new Tokenizer();
function mergeConfig(config = {}) {
    return {
        ...config,
        tags: {
            ...tags_default,
            ...config.tags
        },
        nodes: {
            ...schema_exports,
            ...config.nodes
        },
        functions: {
            ...functions_default,
            ...config.functions
        }
    };
}
function parse3(content, args) {
    if (typeof content === "string") content = tokenizer.tokenize(content);
    return parser(content, args);
}
function resolve2(content, config) {
    if (Array.isArray(content)) return content.flatMap((child)=>child.resolve(config));
    return content.resolve(config);
}
function transform2(nodes, options) {
    const config = mergeConfig(options);
    const content = resolve2(nodes, config);
    if (Array.isArray(content)) return content.flatMap((child)=>child.transform(config));
    return content.transform(config);
}
function validate(content, options) {
    const config = mergeConfig(options);
    const output = [
        content,
        ...content.walk()
    ].map((node2)=>{
        const { type, lines, location } = node2;
        const errors = validator(node2, config);
        if (isPromise(errors)) {
            return errors.then((e)=>e.map((error2)=>({
                        type,
                        lines,
                        location,
                        error: error2
                    })));
        }
        return errors.map((error2)=>({
                type,
                lines,
                location,
                error: error2
            }));
    });
    if (output.some(isPromise)) {
        return Promise.all(output).then((o)=>o.flat());
    }
    return output.flat();
}
function createElement(name, attributes = {}, ...children) {
    return {
        name,
        attributes,
        children
    };
}
var Markdoc = class {
    constructor(config){
        this.parse = parse3;
        this.resolve = (content)=>resolve2(content, this.config);
        this.transform = (content)=>transform2(content, this.config);
        this.validate = (content)=>validate(content, this.config);
        this.config = config;
    }
};
Markdoc.nodes = schema_exports;
Markdoc.tags = tags_default;
Markdoc.functions = functions_default;
Markdoc.globalAttributes = globalAttributes;
Markdoc.renderers = renderers_default;
Markdoc.transforms = transforms_default;
Markdoc.Ast = ast_default;
Markdoc.Tag = Tag;
Markdoc.Tokenizer = Tokenizer;
Markdoc.parseTags = parseTags;
Markdoc.transformer = transformer_default;
Markdoc.validator = validator;
Markdoc.parse = parse3;
Markdoc.transform = transform2;
Markdoc.validate = validate;
Markdoc.createElement = createElement;
Markdoc.truthy = truthy;
Markdoc.format = format;


/***/ }),

/***/ 66615:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const escapeStringRegexp = __webpack_require__(50918);
const transliterate = __webpack_require__(45969);
const builtinOverridableReplacements = __webpack_require__(31699);
const decamelize = (string)=>{
    return string// Separate capitalized words.
    .replace(/([A-Z]{2,})(\d+)/g, "$1 $2").replace(/([a-z\d]+)([A-Z]{2,})/g, "$1 $2").replace(/([a-z\d])([A-Z])/g, "$1 $2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1 $2");
};
const removeMootSeparators = (string, separator)=>{
    const escapedSeparator = escapeStringRegexp(separator);
    return string.replace(new RegExp(`${escapedSeparator}{2,}`, "g"), separator).replace(new RegExp(`^${escapedSeparator}|${escapedSeparator}$`, "g"), "");
};
const slugify = (string, options)=>{
    if (typeof string !== "string") {
        throw new TypeError(`Expected a string, got \`${typeof string}\``);
    }
    options = {
        separator: "-",
        lowercase: true,
        decamelize: true,
        customReplacements: [],
        preserveLeadingUnderscore: false,
        ...options
    };
    const shouldPrependUnderscore = options.preserveLeadingUnderscore && string.startsWith("_");
    const customReplacements = new Map([
        ...builtinOverridableReplacements,
        ...options.customReplacements
    ]);
    string = transliterate(string, {
        customReplacements
    });
    if (options.decamelize) {
        string = decamelize(string);
    }
    let patternSlug = /[^a-zA-Z\d]+/g;
    if (options.lowercase) {
        string = string.toLowerCase();
        patternSlug = /[^a-z\d]+/g;
    }
    string = string.replace(patternSlug, options.separator);
    string = string.replace(/\\/g, "");
    if (options.separator) {
        string = removeMootSeparators(string, options.separator);
    }
    if (shouldPrependUnderscore) {
        string = `_${string}`;
    }
    return string;
};
const counter = ()=>{
    const occurrences = new Map();
    const countable = (string, options)=>{
        string = slugify(string, options);
        if (!string) {
            return "";
        }
        const stringLower = string.toLowerCase();
        const numberless = occurrences.get(stringLower.replace(/(?:-\d+?)+?$/, "")) || 0;
        const counter = occurrences.get(stringLower);
        occurrences.set(stringLower, typeof counter === "number" ? counter + 1 : 1);
        const newCounter = occurrences.get(stringLower) || 2;
        if (newCounter >= 2 || numberless > 2) {
            string = `${string}-${newCounter}`;
        }
        return string;
    };
    countable.reset = ()=>{
        occurrences.clear();
    };
    return countable;
};
module.exports = slugify;
module.exports.counter = counter;


/***/ }),

/***/ 50918:
/***/ ((module) => {

"use strict";

module.exports = (string)=>{
    if (typeof string !== "string") {
        throw new TypeError("Expected a string");
    }
    // Escape characters with special meaning either inside or outside character sets.
    // Use a simple backslash escape when its always valid, and a \unnnn escape when the simpler form would be disallowed by Unicode patterns stricter grammar.
    return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};


/***/ }),

/***/ 31699:
/***/ ((module) => {

"use strict";

module.exports = [
    [
        "&",
        " and "
    ],
    [
        "\uD83E\uDD84",
        " unicorn "
    ],
    [
        "",
        " love "
    ]
];


/***/ }),

/***/ 45969:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const deburr = __webpack_require__(46136);
const escapeStringRegexp = __webpack_require__(82268);
const builtinReplacements = __webpack_require__(96367);
const doCustomReplacements = (string, replacements)=>{
    for (const [key, value] of replacements){
        // TODO: Use `String#replaceAll()` when targeting Node.js 16.
        string = string.replace(new RegExp(escapeStringRegexp(key), "g"), value);
    }
    return string;
};
module.exports = (string, options)=>{
    if (typeof string !== "string") {
        throw new TypeError(`Expected a string, got \`${typeof string}\``);
    }
    options = {
        customReplacements: [],
        ...options
    };
    const customReplacements = new Map([
        ...builtinReplacements,
        ...options.customReplacements
    ]);
    string = string.normalize();
    string = doCustomReplacements(string, customReplacements);
    string = deburr(string);
    return string;
};


/***/ }),

/***/ 82268:
/***/ ((module) => {

"use strict";

const matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
module.exports = (string)=>{
    if (typeof string !== "string") {
        throw new TypeError("Expected a string");
    }
    return string.replace(matchOperatorsRegex, "\\$&");
};


/***/ }),

/***/ 96367:
/***/ ((module) => {

"use strict";

module.exports = [
    // German umlauts
    [
        "\xdf",
        "ss"
    ],
    [
        "\xe4",
        "ae"
    ],
    [
        "\xc4",
        "Ae"
    ],
    [
        "\xf6",
        "oe"
    ],
    [
        "\xd6",
        "Oe"
    ],
    [
        "\xfc",
        "ue"
    ],
    [
        "\xdc",
        "Ue"
    ],
    // Latin
    [
        "\xc0",
        "A"
    ],
    [
        "\xc1",
        "A"
    ],
    [
        "\xc2",
        "A"
    ],
    [
        "\xc3",
        "A"
    ],
    [
        "\xc4",
        "Ae"
    ],
    [
        "\xc5",
        "A"
    ],
    [
        "\xc6",
        "AE"
    ],
    [
        "\xc7",
        "C"
    ],
    [
        "\xc8",
        "E"
    ],
    [
        "\xc9",
        "E"
    ],
    [
        "\xca",
        "E"
    ],
    [
        "\xcb",
        "E"
    ],
    [
        "\xcc",
        "I"
    ],
    [
        "\xcd",
        "I"
    ],
    [
        "\xce",
        "I"
    ],
    [
        "\xcf",
        "I"
    ],
    [
        "\xd0",
        "D"
    ],
    [
        "\xd1",
        "N"
    ],
    [
        "\xd2",
        "O"
    ],
    [
        "\xd3",
        "O"
    ],
    [
        "\xd4",
        "O"
    ],
    [
        "\xd5",
        "O"
    ],
    [
        "\xd6",
        "Oe"
    ],
    [
        "",
        "O"
    ],
    [
        "\xd8",
        "O"
    ],
    [
        "\xd9",
        "U"
    ],
    [
        "\xda",
        "U"
    ],
    [
        "\xdb",
        "U"
    ],
    [
        "\xdc",
        "Ue"
    ],
    [
        "",
        "U"
    ],
    [
        "\xdd",
        "Y"
    ],
    [
        "\xde",
        "TH"
    ],
    [
        "\xdf",
        "ss"
    ],
    [
        "\xe0",
        "a"
    ],
    [
        "\xe1",
        "a"
    ],
    [
        "\xe2",
        "a"
    ],
    [
        "\xe3",
        "a"
    ],
    [
        "\xe4",
        "ae"
    ],
    [
        "\xe5",
        "a"
    ],
    [
        "\xe6",
        "ae"
    ],
    [
        "\xe7",
        "c"
    ],
    [
        "\xe8",
        "e"
    ],
    [
        "\xe9",
        "e"
    ],
    [
        "\xea",
        "e"
    ],
    [
        "\xeb",
        "e"
    ],
    [
        "\xec",
        "i"
    ],
    [
        "\xed",
        "i"
    ],
    [
        "\xee",
        "i"
    ],
    [
        "\xef",
        "i"
    ],
    [
        "\xf0",
        "d"
    ],
    [
        "\xf1",
        "n"
    ],
    [
        "\xf2",
        "o"
    ],
    [
        "\xf3",
        "o"
    ],
    [
        "\xf4",
        "o"
    ],
    [
        "\xf5",
        "o"
    ],
    [
        "\xf6",
        "oe"
    ],
    [
        "",
        "o"
    ],
    [
        "\xf8",
        "o"
    ],
    [
        "\xf9",
        "u"
    ],
    [
        "\xfa",
        "u"
    ],
    [
        "\xfb",
        "u"
    ],
    [
        "\xfc",
        "ue"
    ],
    [
        "",
        "u"
    ],
    [
        "\xfd",
        "y"
    ],
    [
        "\xfe",
        "th"
    ],
    [
        "\xff",
        "y"
    ],
    [
        "",
        "SS"
    ],
    // Vietnamese
    [
        "\xe0",
        "a"
    ],
    [
        "\xc0",
        "A"
    ],
    [
        "\xe1",
        "a"
    ],
    [
        "\xc1",
        "A"
    ],
    [
        "\xe2",
        "a"
    ],
    [
        "\xc2",
        "A"
    ],
    [
        "\xe3",
        "a"
    ],
    [
        "\xc3",
        "A"
    ],
    [
        "\xe8",
        "e"
    ],
    [
        "\xc8",
        "E"
    ],
    [
        "\xe9",
        "e"
    ],
    [
        "\xc9",
        "E"
    ],
    [
        "\xea",
        "e"
    ],
    [
        "\xca",
        "E"
    ],
    [
        "\xec",
        "i"
    ],
    [
        "\xcc",
        "I"
    ],
    [
        "\xed",
        "i"
    ],
    [
        "\xcd",
        "I"
    ],
    [
        "\xf2",
        "o"
    ],
    [
        "\xd2",
        "O"
    ],
    [
        "\xf3",
        "o"
    ],
    [
        "\xd3",
        "O"
    ],
    [
        "\xf4",
        "o"
    ],
    [
        "\xd4",
        "O"
    ],
    [
        "\xf5",
        "o"
    ],
    [
        "\xd5",
        "O"
    ],
    [
        "\xf9",
        "u"
    ],
    [
        "\xd9",
        "U"
    ],
    [
        "\xfa",
        "u"
    ],
    [
        "\xda",
        "U"
    ],
    [
        "\xfd",
        "y"
    ],
    [
        "\xdd",
        "Y"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "A"
    ],
    [
        "",
        "D"
    ],
    [
        "",
        "d"
    ],
    [
        "",
        "i"
    ],
    [
        "",
        "I"
    ],
    [
        "",
        "u"
    ],
    [
        "",
        "U"
    ],
    [
        "",
        "o"
    ],
    [
        "",
        "O"
    ],
    [
        "",
        "u"
    ],
    [
        "",
        "U"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "A"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "A"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "A"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "A"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "A"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "A"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "A"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "A"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "A"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "A"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "A"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "A"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "E"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "E"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "E"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "E"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "E"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "E"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "E"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "E"
    ],
    [
        "",
        "i"
    ],
    [
        "",
        "I"
    ],
    [
        "",
        "i"
    ],
    [
        "",
        "I"
    ],
    [
        "",
        "o"
    ],
    [
        "",
        "O"
    ],
    [
        "",
        "o"
    ],
    [
        "",
        "O"
    ],
    [
        "",
        "o"
    ],
    [
        "",
        "O"
    ],
    [
        "",
        "o"
    ],
    [
        "",
        "O"
    ],
    [
        "",
        "o"
    ],
    [
        "",
        "O"
    ],
    [
        "",
        "o"
    ],
    [
        "",
        "O"
    ],
    [
        "",
        "o"
    ],
    [
        "",
        "O"
    ],
    [
        "",
        "o"
    ],
    [
        "",
        "O"
    ],
    [
        "",
        "o"
    ],
    [
        "",
        "O"
    ],
    [
        "",
        "o"
    ],
    [
        "",
        "O"
    ],
    [
        "",
        "o"
    ],
    [
        "",
        "O"
    ],
    [
        "",
        "o"
    ],
    [
        "",
        "O"
    ],
    [
        "",
        "u"
    ],
    [
        "",
        "U"
    ],
    [
        "",
        "u"
    ],
    [
        "",
        "U"
    ],
    [
        "",
        "u"
    ],
    [
        "",
        "U"
    ],
    [
        "",
        "u"
    ],
    [
        "",
        "U"
    ],
    [
        "",
        "u"
    ],
    [
        "",
        "U"
    ],
    [
        "",
        "u"
    ],
    [
        "",
        "U"
    ],
    [
        "",
        "u"
    ],
    [
        "",
        "U"
    ],
    [
        "",
        "y"
    ],
    [
        "",
        "Y"
    ],
    [
        "",
        "y"
    ],
    [
        "",
        "Y"
    ],
    [
        "",
        "y"
    ],
    [
        "",
        "Y"
    ],
    [
        "",
        "y"
    ],
    [
        "",
        "Y"
    ],
    // Arabic
    [
        "",
        "e"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "w"
    ],
    [
        "",
        "i"
    ],
    [
        "",
        "y"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "b"
    ],
    [
        "",
        "t"
    ],
    [
        "",
        "t"
    ],
    [
        "",
        "th"
    ],
    [
        "",
        "j"
    ],
    [
        "",
        "h"
    ],
    [
        "",
        "kh"
    ],
    [
        "",
        "d"
    ],
    [
        "",
        "dh"
    ],
    [
        "",
        "r"
    ],
    [
        "",
        "z"
    ],
    [
        "",
        "s"
    ],
    [
        "",
        "sh"
    ],
    [
        "",
        "s"
    ],
    [
        "",
        "d"
    ],
    [
        "",
        "t"
    ],
    [
        "",
        "z"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "gh"
    ],
    [
        "",
        "_"
    ],
    [
        "",
        "f"
    ],
    [
        "",
        "q"
    ],
    [
        "",
        "k"
    ],
    [
        "",
        "l"
    ],
    [
        "",
        "m"
    ],
    [
        "",
        "n"
    ],
    [
        "",
        "h"
    ],
    [
        "",
        "w"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "y"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "u"
    ],
    [
        "",
        "i"
    ],
    [
        "",
        "0"
    ],
    [
        "",
        "1"
    ],
    [
        "",
        "2"
    ],
    [
        "",
        "3"
    ],
    [
        "",
        "4"
    ],
    [
        "",
        "5"
    ],
    [
        "",
        "6"
    ],
    [
        "",
        "7"
    ],
    [
        "",
        "8"
    ],
    [
        "",
        "9"
    ],
    // Persian / Farsi
    [
        "",
        "ch"
    ],
    [
        "",
        "k"
    ],
    [
        "",
        "g"
    ],
    [
        "",
        "p"
    ],
    [
        "",
        "zh"
    ],
    [
        "",
        "y"
    ],
    [
        "",
        "0"
    ],
    [
        "",
        "1"
    ],
    [
        "",
        "2"
    ],
    [
        "",
        "3"
    ],
    [
        "",
        "4"
    ],
    [
        "",
        "5"
    ],
    [
        "",
        "6"
    ],
    [
        "",
        "7"
    ],
    [
        "",
        "8"
    ],
    [
        "",
        "9"
    ],
    // Pashto
    [
        "",
        "p"
    ],
    [
        "",
        "z"
    ],
    [
        "",
        "c"
    ],
    [
        "",
        "d"
    ],
    [
        "",
        "d"
    ],
    [
        "",
        "r"
    ],
    [
        "",
        "r"
    ],
    [
        "",
        "z"
    ],
    [
        "",
        "g"
    ],
    [
        "",
        "x"
    ],
    [
        "",
        "g"
    ],
    [
        "",
        "n"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "ai"
    ],
    // Urdu
    [
        "",
        "t"
    ],
    [
        "",
        "d"
    ],
    [
        "",
        "r"
    ],
    [
        "",
        "n"
    ],
    [
        "",
        "h"
    ],
    [
        "",
        "h"
    ],
    [
        "",
        "e"
    ],
    // Russian
    [
        "",
        "A"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "B"
    ],
    [
        "",
        "b"
    ],
    [
        "",
        "V"
    ],
    [
        "",
        "v"
    ],
    [
        "",
        "G"
    ],
    [
        "",
        "g"
    ],
    [
        "",
        "D"
    ],
    [
        "",
        "d"
    ],
    [
        "",
        "E"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "Zh"
    ],
    [
        "",
        "zh"
    ],
    [
        "",
        "Z"
    ],
    [
        "",
        "z"
    ],
    [
        "",
        "I"
    ],
    [
        "",
        "i"
    ],
    [
        "",
        "J"
    ],
    [
        "",
        "j"
    ],
    [
        "",
        "K"
    ],
    [
        "",
        "k"
    ],
    [
        "",
        "L"
    ],
    [
        "",
        "l"
    ],
    [
        "",
        "M"
    ],
    [
        "",
        "m"
    ],
    [
        "",
        "N"
    ],
    [
        "",
        "n"
    ],
    [
        "",
        "O"
    ],
    [
        "",
        "o"
    ],
    [
        "",
        "P"
    ],
    [
        "",
        "p"
    ],
    [
        "",
        "R"
    ],
    [
        "",
        "r"
    ],
    [
        "",
        "S"
    ],
    [
        "",
        "s"
    ],
    [
        "",
        "T"
    ],
    [
        "",
        "t"
    ],
    [
        "",
        "U"
    ],
    [
        "",
        "u"
    ],
    [
        "",
        "F"
    ],
    [
        "",
        "f"
    ],
    [
        "",
        "H"
    ],
    [
        "",
        "h"
    ],
    [
        "",
        "Cz"
    ],
    [
        "",
        "cz"
    ],
    [
        "",
        "Ch"
    ],
    [
        "",
        "ch"
    ],
    [
        "",
        "Sh"
    ],
    [
        "",
        "sh"
    ],
    [
        "",
        "Shh"
    ],
    [
        "",
        "shh"
    ],
    [
        "",
        ""
    ],
    [
        "",
        ""
    ],
    [
        "",
        "Y"
    ],
    [
        "",
        "y"
    ],
    [
        "",
        ""
    ],
    [
        "",
        ""
    ],
    [
        "",
        "E"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "Yu"
    ],
    [
        "",
        "yu"
    ],
    [
        "",
        "Ya"
    ],
    [
        "",
        "ya"
    ],
    [
        "",
        "Yo"
    ],
    [
        "",
        "yo"
    ],
    // Romanian
    [
        "",
        "a"
    ],
    [
        "",
        "A"
    ],
    [
        "",
        "s"
    ],
    [
        "",
        "S"
    ],
    [
        "",
        "t"
    ],
    [
        "",
        "T"
    ],
    [
        "",
        "t"
    ],
    [
        "",
        "T"
    ],
    // Turkish
    [
        "",
        "s"
    ],
    [
        "",
        "S"
    ],
    [
        "\xe7",
        "c"
    ],
    [
        "\xc7",
        "C"
    ],
    [
        "",
        "g"
    ],
    [
        "",
        "G"
    ],
    [
        "",
        "i"
    ],
    [
        "",
        "I"
    ],
    // Armenian
    [
        "",
        "a"
    ],
    [
        "",
        "A"
    ],
    [
        "",
        "b"
    ],
    [
        "",
        "B"
    ],
    [
        "",
        "g"
    ],
    [
        "",
        "G"
    ],
    [
        "",
        "d"
    ],
    [
        "",
        "D"
    ],
    [
        "",
        "ye"
    ],
    [
        "",
        "Ye"
    ],
    [
        "",
        "z"
    ],
    [
        "",
        "Z"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "E"
    ],
    [
        "",
        "y"
    ],
    [
        "",
        "Y"
    ],
    [
        "",
        "t"
    ],
    [
        "",
        "T"
    ],
    [
        "",
        "zh"
    ],
    [
        "",
        "Zh"
    ],
    [
        "",
        "i"
    ],
    [
        "",
        "I"
    ],
    [
        "",
        "l"
    ],
    [
        "",
        "L"
    ],
    [
        "",
        "kh"
    ],
    [
        "",
        "Kh"
    ],
    [
        "",
        "ts"
    ],
    [
        "",
        "Ts"
    ],
    [
        "",
        "k"
    ],
    [
        "",
        "K"
    ],
    [
        "",
        "h"
    ],
    [
        "",
        "H"
    ],
    [
        "",
        "dz"
    ],
    [
        "",
        "Dz"
    ],
    [
        "",
        "gh"
    ],
    [
        "",
        "Gh"
    ],
    [
        "",
        "tch"
    ],
    [
        "",
        "Tch"
    ],
    [
        "",
        "m"
    ],
    [
        "",
        "M"
    ],
    [
        "",
        "y"
    ],
    [
        "",
        "Y"
    ],
    [
        "",
        "n"
    ],
    [
        "",
        "N"
    ],
    [
        "",
        "sh"
    ],
    [
        "",
        "Sh"
    ],
    [
        "",
        "vo"
    ],
    [
        "",
        "Vo"
    ],
    [
        "",
        "ch"
    ],
    [
        "",
        "Ch"
    ],
    [
        "",
        "p"
    ],
    [
        "",
        "P"
    ],
    [
        "",
        "j"
    ],
    [
        "",
        "J"
    ],
    [
        "",
        "r"
    ],
    [
        "",
        "R"
    ],
    [
        "",
        "s"
    ],
    [
        "",
        "S"
    ],
    [
        "",
        "v"
    ],
    [
        "",
        "V"
    ],
    [
        "",
        "t"
    ],
    [
        "",
        "T"
    ],
    [
        "",
        "r"
    ],
    [
        "",
        "R"
    ],
    [
        "",
        "c"
    ],
    [
        "",
        "C"
    ],
    [
        "",
        "u"
    ],
    [
        "",
        "U"
    ],
    [
        "",
        "U"
    ],
    [
        "",
        "p"
    ],
    [
        "",
        "P"
    ],
    [
        "",
        "q"
    ],
    [
        "",
        "Q"
    ],
    [
        "",
        "o"
    ],
    [
        "",
        "O"
    ],
    [
        "",
        "f"
    ],
    [
        "",
        "F"
    ],
    [
        "",
        "yev"
    ],
    // Georgian
    [
        "",
        "a"
    ],
    [
        "",
        "b"
    ],
    [
        "",
        "g"
    ],
    [
        "",
        "d"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "v"
    ],
    [
        "",
        "z"
    ],
    [
        "",
        "t"
    ],
    [
        "",
        "i"
    ],
    [
        "",
        "k"
    ],
    [
        "",
        "l"
    ],
    [
        "",
        "m"
    ],
    [
        "",
        "n"
    ],
    [
        "",
        "o"
    ],
    [
        "",
        "p"
    ],
    [
        "",
        "zh"
    ],
    [
        "",
        "r"
    ],
    [
        "",
        "s"
    ],
    [
        "",
        "t"
    ],
    [
        "",
        "u"
    ],
    [
        "",
        "ph"
    ],
    [
        "",
        "q"
    ],
    [
        "",
        "gh"
    ],
    [
        "",
        "k"
    ],
    [
        "",
        "sh"
    ],
    [
        "",
        "ch"
    ],
    [
        "",
        "ts"
    ],
    [
        "",
        "dz"
    ],
    [
        "",
        "ts"
    ],
    [
        "",
        "tch"
    ],
    [
        "",
        "kh"
    ],
    [
        "",
        "j"
    ],
    [
        "",
        "h"
    ],
    // Czech
    [
        "",
        "c"
    ],
    [
        "",
        "d"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "n"
    ],
    [
        "",
        "r"
    ],
    [
        "",
        "s"
    ],
    [
        "",
        "t"
    ],
    [
        "",
        "u"
    ],
    [
        "",
        "z"
    ],
    [
        "",
        "C"
    ],
    [
        "",
        "D"
    ],
    [
        "",
        "E"
    ],
    [
        "",
        "N"
    ],
    [
        "",
        "R"
    ],
    [
        "",
        "S"
    ],
    [
        "",
        "T"
    ],
    [
        "",
        "U"
    ],
    [
        "",
        "Z"
    ],
    // Dhivehi
    [
        "",
        "h"
    ],
    [
        "",
        "sh"
    ],
    [
        "",
        "n"
    ],
    [
        "",
        "r"
    ],
    [
        "",
        "b"
    ],
    [
        "",
        "lh"
    ],
    [
        "",
        "k"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "v"
    ],
    [
        "",
        "m"
    ],
    [
        "",
        "f"
    ],
    [
        "",
        "dh"
    ],
    [
        "",
        "th"
    ],
    [
        "",
        "l"
    ],
    [
        "",
        "g"
    ],
    [
        "",
        "gn"
    ],
    [
        "",
        "s"
    ],
    [
        "",
        "d"
    ],
    [
        "",
        "z"
    ],
    [
        "",
        "t"
    ],
    [
        "",
        "y"
    ],
    [
        "",
        "p"
    ],
    [
        "",
        "j"
    ],
    [
        "",
        "ch"
    ],
    [
        "",
        "tt"
    ],
    [
        "",
        "hh"
    ],
    [
        "",
        "kh"
    ],
    [
        "",
        "th"
    ],
    [
        "",
        "z"
    ],
    [
        "",
        "sh"
    ],
    [
        "",
        "s"
    ],
    [
        "",
        "d"
    ],
    [
        "",
        "t"
    ],
    [
        "",
        "z"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "gh"
    ],
    [
        "",
        "q"
    ],
    [
        "",
        "w"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "aa"
    ],
    [
        "",
        "i"
    ],
    [
        "",
        "ee"
    ],
    [
        "",
        "u"
    ],
    [
        "",
        "oo"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "ey"
    ],
    [
        "",
        "o"
    ],
    [
        "",
        "oa"
    ],
    [
        "",
        ""
    ],
    // Greek
    [
        "",
        "a"
    ],
    [
        "",
        "v"
    ],
    [
        "",
        "g"
    ],
    [
        "",
        "d"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "z"
    ],
    [
        "",
        "i"
    ],
    [
        "",
        "th"
    ],
    [
        "",
        "i"
    ],
    [
        "",
        "k"
    ],
    [
        "",
        "l"
    ],
    [
        "",
        "m"
    ],
    [
        "",
        "n"
    ],
    [
        "",
        "ks"
    ],
    [
        "",
        "o"
    ],
    [
        "",
        "p"
    ],
    [
        "",
        "r"
    ],
    [
        "",
        "s"
    ],
    [
        "",
        "t"
    ],
    [
        "",
        "y"
    ],
    [
        "",
        "f"
    ],
    [
        "",
        "x"
    ],
    [
        "",
        "ps"
    ],
    [
        "",
        "o"
    ],
    [
        "",
        "a"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "i"
    ],
    [
        "",
        "o"
    ],
    [
        "",
        "y"
    ],
    [
        "",
        "i"
    ],
    [
        "",
        "o"
    ],
    [
        "",
        "s"
    ],
    [
        "",
        "i"
    ],
    [
        "",
        "y"
    ],
    [
        "",
        "y"
    ],
    [
        "",
        "i"
    ],
    [
        "",
        "A"
    ],
    [
        "",
        "B"
    ],
    [
        "",
        "G"
    ],
    [
        "",
        "D"
    ],
    [
        "",
        "E"
    ],
    [
        "",
        "Z"
    ],
    [
        "",
        "I"
    ],
    [
        "",
        "TH"
    ],
    [
        "",
        "I"
    ],
    [
        "",
        "K"
    ],
    [
        "",
        "L"
    ],
    [
        "",
        "M"
    ],
    [
        "",
        "N"
    ],
    [
        "",
        "KS"
    ],
    [
        "",
        "O"
    ],
    [
        "",
        "P"
    ],
    [
        "",
        "R"
    ],
    [
        "",
        "S"
    ],
    [
        "",
        "T"
    ],
    [
        "",
        "Y"
    ],
    [
        "",
        "F"
    ],
    [
        "",
        "X"
    ],
    [
        "",
        "PS"
    ],
    [
        "",
        "O"
    ],
    [
        "",
        "A"
    ],
    [
        "",
        "E"
    ],
    [
        "",
        "I"
    ],
    [
        "",
        "O"
    ],
    [
        "",
        "Y"
    ],
    [
        "",
        "I"
    ],
    [
        "",
        "O"
    ],
    [
        "",
        "I"
    ],
    [
        "",
        "Y"
    ],
    // Disabled as it conflicts with German and Latin.
    // Hungarian
    // ['', 'a'],
    // ['', 'A'],
    // ['', 'o'],
    // ['', 'O'],
    // ['', 'u'],
    // ['', 'U'],
    // ['', 'u'],
    // ['', 'U'],
    // Latvian
    [
        "",
        "a"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "g"
    ],
    [
        "",
        "i"
    ],
    [
        "",
        "k"
    ],
    [
        "",
        "l"
    ],
    [
        "",
        "n"
    ],
    [
        "",
        "u"
    ],
    [
        "",
        "A"
    ],
    [
        "",
        "E"
    ],
    [
        "",
        "G"
    ],
    [
        "",
        "I"
    ],
    [
        "",
        "K"
    ],
    [
        "",
        "L"
    ],
    [
        "",
        "N"
    ],
    [
        "",
        "U"
    ],
    [
        "",
        "c"
    ],
    [
        "",
        "s"
    ],
    [
        "",
        "z"
    ],
    [
        "",
        "C"
    ],
    [
        "",
        "S"
    ],
    [
        "",
        "Z"
    ],
    // Lithuanian
    [
        "",
        "a"
    ],
    [
        "",
        "c"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "i"
    ],
    [
        "",
        "s"
    ],
    [
        "",
        "u"
    ],
    [
        "",
        "u"
    ],
    [
        "",
        "z"
    ],
    [
        "",
        "A"
    ],
    [
        "",
        "C"
    ],
    [
        "",
        "E"
    ],
    [
        "",
        "E"
    ],
    [
        "",
        "I"
    ],
    [
        "",
        "S"
    ],
    [
        "",
        "U"
    ],
    [
        "",
        "U"
    ],
    // Macedonian
    [
        "",
        "Kj"
    ],
    [
        "",
        "kj"
    ],
    [
        "",
        "Lj"
    ],
    [
        "",
        "lj"
    ],
    [
        "",
        "Nj"
    ],
    [
        "",
        "nj"
    ],
    [
        "",
        "Ts"
    ],
    [
        "",
        "ts"
    ],
    // Polish
    [
        "",
        "a"
    ],
    [
        "",
        "c"
    ],
    [
        "",
        "e"
    ],
    [
        "",
        "l"
    ],
    [
        "",
        "n"
    ],
    [
        "",
        "s"
    ],
    [
        "",
        "z"
    ],
    [
        "",
        "z"
    ],
    [
        "",
        "A"
    ],
    [
        "",
        "C"
    ],
    [
        "",
        "E"
    ],
    [
        "",
        "L"
    ],
    [
        "",
        "N"
    ],
    [
        "",
        "S"
    ],
    [
        "",
        "Z"
    ],
    [
        "",
        "Z"
    ],
    // Disabled as it conflicts with Vietnamese.
    // Serbian
    // ['', 'lj'],
    // ['', 'nj'],
    // ['', 'Lj'],
    // ['', 'Nj'],
    // ['', 'dj'],
    // ['', 'Dj'],
    // ['', 'dj'],
    // ['', 'j'],
    // ['', 'c'],
    // ['', 'dz'],
    // ['', 'Dj'],
    // ['', 'j'],
    // ['', 'C'],
    // ['', 'Dz'],
    // Disabled as it conflicts with German and Latin.
    // Slovak
    // ['', 'a'],
    // ['', 'A'],
    // ['', 'l'],
    // ['', 'l'],
    // ['', 'r'],
    // ['', 'L'],
    // ['', 'L'],
    // ['', 'R'],
    // Disabled as it conflicts with German and Latin.
    // Swedish
    // ['', 'o'],
    // ['', 'o'],
    // ['', 'a'],
    // ['', 'A'],
    // ['', 'e'],
    // ['', 'E'],
    // ['', 'o'],
    // ['', 'O'],
    // Ukrainian
    [
        "",
        "Ye"
    ],
    [
        "",
        "I"
    ],
    [
        "",
        "Yi"
    ],
    [
        "",
        "G"
    ],
    [
        "",
        "ye"
    ],
    [
        "",
        "i"
    ],
    [
        "",
        "yi"
    ],
    [
        "",
        "g"
    ]
];


/***/ }),

/***/ 42220:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

if (true) {
    module.exports = __webpack_require__(65272);
} else {}


/***/ }),

/***/ 65272:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * Asserts that a condition is `true`, ensuring that whatever condition is being
 * checked must be true for the remainder of the containing scope.
 *
 * @throws when the condition is `false`
 */ // NOTE: The narrow type of `boolean` instead of something like `unknown` is an
// intentional design decision. The goal is to promote consideration from
// consumers when dealing with potentially ambiguous conditions like `0` or
// `''`, which can introduce "subtle" bugs.
function assert(condition) {
    var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Assert failed";
    if (!condition) {
        throw new TypeError(message);
    }
}
/**
 * Asserts that allegedly unreachable code has been executed.
 *
 * @throws always
 */ function assertNever(arg) {
    throw new Error("Expected never to be called, but received: " + JSON.stringify(arg));
}
/**
 * Similar to `assert` but only logs a warning if the condition is not met. Only
 * logs in development.
 */ function warning(condition, message) {}
exports.assert = assert;
exports.assertNever = assertNever;
exports.warning = warning;


/***/ }),

/***/ 45603:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

if (true) {
    module.exports = __webpack_require__(63929);
} else {}


/***/ }),

/***/ 63929:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({
    value: true
});
var assertions_dist_emeryAssertions = __webpack_require__(65272);
var number = __webpack_require__(51002);
var guards_dist_emeryGuards = __webpack_require__(28338);
var opaques_dist_emeryOpaques = __webpack_require__(57349);
var object = __webpack_require__(37471);
exports.assert = assertions_dist_emeryAssertions.assert;
exports.assertNever = assertions_dist_emeryAssertions.assertNever;
__webpack_unused_export__ = assertions_dist_emeryAssertions.warning;
__webpack_unused_export__ = number.checkAll;
__webpack_unused_export__ = number.checkAllWith;
__webpack_unused_export__ = number.isEven;
__webpack_unused_export__ = number.isFinite;
__webpack_unused_export__ = number.isFloat;
__webpack_unused_export__ = number.isInfinite;
__webpack_unused_export__ = number.isInteger;
__webpack_unused_export__ = number.isNegative;
__webpack_unused_export__ = number.isNegativeZero;
__webpack_unused_export__ = number.isNonNegative;
__webpack_unused_export__ = number.isNonPositive;
__webpack_unused_export__ = number.isOdd;
__webpack_unused_export__ = number.isPositive;
__webpack_unused_export__ = number.negate;
__webpack_unused_export__ = guards_dist_emeryGuards.isBoolean;
__webpack_unused_export__ = guards_dist_emeryGuards.isDefined;
__webpack_unused_export__ = guards_dist_emeryGuards.isFulfilled;
__webpack_unused_export__ = guards_dist_emeryGuards.isNonEmptyArray;
__webpack_unused_export__ = guards_dist_emeryGuards.isNull;
__webpack_unused_export__ = guards_dist_emeryGuards.isNullish;
__webpack_unused_export__ = guards_dist_emeryGuards.isNumber;
__webpack_unused_export__ = guards_dist_emeryGuards.isRejected;
__webpack_unused_export__ = guards_dist_emeryGuards.isString;
__webpack_unused_export__ = guards_dist_emeryGuards.isUndefined;
__webpack_unused_export__ = opaques_dist_emeryOpaques.castToOpaque;
__webpack_unused_export__ = object.getErrorMessage;
__webpack_unused_export__ = object.typedEntries;
__webpack_unused_export__ = object.typedKeys;


/***/ }),

/***/ 51002:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Returns a new function for checking *all* cases against a value, a bit
 * like `pipe` for predicates.
 */ function checkAll() {
    for(var _len = arguments.length, predicates = new Array(_len), _key = 0; _key < _len; _key++){
        predicates[_key] = arguments[_key];
    }
    return function(value) {
        return predicates.every(function(p) {
            return p(value);
        });
    };
}
/** Apply *all* checks against a value. */ function checkAllWith(value) {
    for(var _len2 = arguments.length, predicates = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
        predicates[_key2 - 1] = arguments[_key2];
    }
    return checkAll.apply(void 0, predicates)(value);
}
/** Returns a new negated version of the stated predicate function. */ function negate(predicate) {
    return function(value) {
        return !predicate(value);
    };
}
/** Checks whether a number is a finite */ var isFinite = Number.isFinite;
/** Checks whether a number is a infinite */ var isInfinite = negate(isFinite);
/** Checks whether a number is an integer */ var isInteger = Number.isInteger;
/** Checks whether a number is a float */ var isFloat = negate(isInteger);
/** Checks whether a number is even. */ var isEven = function isEven(value) {
    return value % 2 === 0;
};
/** Checks whether a number is odd. */ var isOdd = function isOdd(value) {
    return Math.abs(value % 2) === 1;
};
/** Checks whether a number is negative zero */ var isNegativeZero = function isNegativeZero(value) {
    return 1 / value === Number.NEGATIVE_INFINITY;
};
/** Checks whether a number is negative */ var isNegative = function isNegative(value) {
    return value < 0;
};
/** Checks whether a number is positive */ var isPositive = function isPositive(value) {
    return value > 0;
};
/** Checks whether a number is non-negative */ var isNonNegative = function isNonNegative(value) {
    return value >= 0;
};
/** Checks whether a number is non-positive */ var isNonPositive = function isNonPositive(value) {
    return value <= 0;
};
exports.checkAll = checkAll;
exports.checkAllWith = checkAllWith;
exports.isEven = isEven;
exports.isFinite = isFinite;
exports.isFloat = isFloat;
exports.isInfinite = isInfinite;
exports.isInteger = isInteger;
exports.isNegative = isNegative;
exports.isNegativeZero = isNegativeZero;
exports.isNonNegative = isNonNegative;
exports.isNonPositive = isNonPositive;
exports.isOdd = isOdd;
exports.isPositive = isPositive;
exports.negate = negate;


/***/ }),

/***/ 37471:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
}
/**
 * Simplifies `error` handling in `try...catch` statements.
 *
 * JavaScript is weird, you can `throw` anything. Since it's possible for
 * library authors to throw something unexpected, we have to take precautions.
 */ function getErrorMessage(error) {
    var fallbackMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Unknown error";
    if (isErrorLike(error)) {
        return error.message;
    }
    return error ? JSON.stringify(error) : fallbackMessage;
}
/** Handle situations where the error object isn't an _actual_ error. */ function isErrorLike(error) {
    return _typeof(error) === "object" && error !== null && "message" in error && typeof error.message === "string";
}
/**
 * An alternative to `Object.entries()` that avoids type widening.
 *
 * @example
 * Object.entries({ foo: 1, bar: 2 }) // [string, number][]
 * typedEntries({ foo: 1, bar: 2 }) // ["foo" | "bar", number][]
 */ function typedEntries(value) {
    return Object.entries(value);
}
/**
 * An alternative to `Object.keys()` that avoids type widening.
 *
 * @example
 * Object.keys({ foo: 1, bar: 2 }) // string[]
 * typedKeys({ foo: 1, bar: 2 }) // ("foo" | "bar")[]
 */ function typedKeys(value) {
    return Object.keys(value);
}
exports.getErrorMessage = getErrorMessage;
exports.typedEntries = typedEntries;
exports.typedKeys = typedKeys;


/***/ }),

/***/ 28338:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/// <reference lib="es2020.promise" />
// Primitives
// ------------------------------
/** Checks whether a value is a boolean */ function isBoolean(value) {
    return typeof value === "boolean";
}
/** Checks whether a value is null */ function isNull(value) {
    return value === null;
}
/** Checks whether a value is a number */ function isNumber(value) {
    return typeof value === "number" && !isNaN(value);
}
/** Checks whether a value is a string */ function isString(value) {
    return typeof value === "string";
}
/** Checks whether a value is undefined */ function isUndefined(value) {
    return value === undefined;
} // Array
// ------------------------------
/** Checks whether or not an array is empty. */ function isNonEmptyArray(value) {
    return value.length > 0;
} // Convenience
// ------------------------------
/** Checks whether a value is null or undefined */ function isNullish(value) {
    return value === null || value === undefined;
}
/** Checks whether a value is defined */ function isDefined(value) {
    return !isNullish(value);
} // Promise
// ------------------------------
/**
 * Checks whether a result from `Promise.allSettled` is fulfilled
 *
 * ```ts
 * const results = await Promise.allSettled(promises);
 * const fulfilledValues = results.filter(isFulfilled).map(result => result.value);
 * ```
 */ function isFulfilled(result) {
    return result.status === "fulfilled";
}
/**
 * Checks whether a result from `Promise.allSettled` is rejected
 *
 * ```ts
 * const results = await Promise.allSettled(promises);
 * const rejectionReasons = results.filter(isRejected).map(result => result.reason);
 * ```
 */ function isRejected(result) {
    return result.status === "rejected";
}
exports.isBoolean = isBoolean;
exports.isDefined = isDefined;
exports.isFulfilled = isFulfilled;
exports.isNonEmptyArray = isNonEmptyArray;
exports.isNull = isNull;
exports.isNullish = isNullish;
exports.isNumber = isNumber;
exports.isRejected = isRejected;
exports.isString = isString;
exports.isUndefined = isUndefined;


/***/ }),

/***/ 57349:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * A generic helper function that takes a primitive value, and returns the value
 * after casting it to the provided opaque type.
 */ // 1. extend `Opaque` to exclude transparent types e.g. `castToOpaque<number>(1)`
// 2. default `never` to prohibit unfulfilled type e.g. `castToOpaque(1)`
// 3. explicit `Transparent` to prevent invalid values e.g. `castToOpaque<OpaqueString>(1)`
// 4. cast `unknown` first to avoid invalid expression instantiation
function castToOpaque(value) {
    /* 4. */ return value;
}
exports.castToOpaque = castToOpaque;


/***/ }),

/***/ 42973:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

function n(n) {
    for(var r = arguments.length, t = Array(r > 1 ? r - 1 : 0), e = 1; e < r; e++)t[e - 1] = arguments[e];
    throw Error("[Immer] minified error nr: " + n + (t.length ? " " + t.map(function(n) {
        return "'" + n + "'";
    }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function r(n) {
    return !!n && !!n[H];
}
function t(n) {
    var r;
    return !!n && (function(n) {
        if (!n || "object" != typeof n) return !1;
        var r = Object.getPrototypeOf(n);
        if (null === r) return !0;
        var t = Object.hasOwnProperty.call(r, "constructor") && r.constructor;
        return t === Object || "function" == typeof t && Function.toString.call(t) === Q;
    }(n) || Array.isArray(n) || !!n[G] || !!(null === (r = n.constructor) || void 0 === r ? void 0 : r[G]) || c(n) || v(n));
}
function e(n, r, t) {
    void 0 === t && (t = !1), 0 === i(n) ? (t ? Object.keys : T)(n).forEach(function(e) {
        t && "symbol" == typeof e || r(e, n[e], n);
    }) : n.forEach(function(t, e) {
        return r(e, t, n);
    });
}
function i(n) {
    var r = n[H];
    return r ? r.t > 3 ? r.t - 4 : r.t : Array.isArray(n) ? 1 : c(n) ? 2 : v(n) ? 3 : 0;
}
function u(n, r) {
    return 2 === i(n) ? n.has(r) : Object.prototype.hasOwnProperty.call(n, r);
}
function o(n, r) {
    return 2 === i(n) ? n.get(r) : n[r];
}
function f(n, r, t) {
    var e = i(n);
    2 === e ? n.set(r, t) : 3 === e ? n.add(t) : n[r] = t;
}
function a(n, r) {
    return n === r ? 0 !== n || 1 / n == 1 / r : n != n && r != r;
}
function c(n) {
    return W && n instanceof Map;
}
function v(n) {
    return X && n instanceof Set;
}
function s(n) {
    return n.i || n.u;
}
function p(n) {
    if (Array.isArray(n)) return Array.prototype.slice.call(n);
    var r = U(n);
    delete r[H];
    for(var t = T(r), e = 0; e < t.length; e++){
        var i = t[e], u = r[i];
        !1 === u.writable && (u.writable = !0, u.configurable = !0), (u.get || u.set) && (r[i] = {
            configurable: !0,
            writable: !0,
            enumerable: u.enumerable,
            value: n[i]
        });
    }
    return Object.create(Object.getPrototypeOf(n), r);
}
function l(n, u) {
    return void 0 === u && (u = !1), h(n) || r(n) || !t(n) || (i(n) > 1 && (n.set = n.add = n.clear = n.delete = d), Object.freeze(n), u && e(n, function(n, r) {
        return l(r, !0);
    }, !0)), n;
}
function d() {
    n(2);
}
function h(n) {
    return null == n || "object" != typeof n || Object.isFrozen(n);
}
function y(r) {
    var t = V[r];
    return t || n(18, r), t;
}
function _(n, r) {
    V[n] || (V[n] = r);
}
function b() {
    return I;
}
function m(n, r) {
    r && (y("Patches"), n.o = [], n.v = [], n.s = r);
}
function j(n) {
    O(n), n.p.forEach(w), n.p = null;
}
function O(n) {
    n === I && (I = n.l);
}
function x(n) {
    return I = {
        p: [],
        l: I,
        h: n,
        _: !0,
        m: 0
    };
}
function w(n) {
    var r = n[H];
    0 === r.t || 1 === r.t ? r.j() : r.O = !0;
}
function S(r, e) {
    e.m = e.p.length;
    var i = e.p[0], u = void 0 !== r && r !== i;
    return e.h.S || y("ES5").P(e, r, u), u ? (i[H].g && (j(e), n(4)), t(r) && (r = P(e, r), e.l || M(e, r)), e.o && y("Patches").M(i[H].u, r, e.o, e.v)) : r = P(e, i, []), j(e), e.o && e.s(e.o, e.v), r !== B ? r : void 0;
}
function P(n, r, t) {
    if (h(r)) return r;
    var i = r[H];
    if (!i) return e(r, function(e, u) {
        return g(n, i, r, e, u, t);
    }, !0), r;
    if (i.A !== n) return r;
    if (!i.g) return M(n, i.u, !0), i.u;
    if (!i.R) {
        i.R = !0, i.A.m--;
        var u = 4 === i.t || 5 === i.t ? i.i = p(i.k) : i.i, o = u, f = !1;
        3 === i.t && (o = new Set(u), u.clear(), f = !0), e(o, function(r, e) {
            return g(n, i, u, r, e, t, f);
        }), M(n, u, !1), t && n.o && y("Patches").F(i, t, n.o, n.v);
    }
    return i.i;
}
function g(n, e, i, o, a, c, v) {
    if (r(a)) {
        var s = P(n, a, c && e && 3 !== e.t && !u(e.N, o) ? c.concat(o) : void 0);
        if (f(i, o, s), !r(s)) return;
        n._ = !1;
    } else v && i.add(a);
    if (t(a) && !h(a)) {
        if (!n.h.D && n.m < 1) return;
        P(n, a), e && e.A.l || M(n, a);
    }
}
function M(n, r, t) {
    void 0 === t && (t = !1), !n.l && n.h.D && n._ && l(r, t);
}
function A(n, r) {
    var t = n[H];
    return (t ? s(t) : n)[r];
}
function z(n, r) {
    if (r in n) for(var t = Object.getPrototypeOf(n); t;){
        var e = Object.getOwnPropertyDescriptor(t, r);
        if (e) return e;
        t = Object.getPrototypeOf(t);
    }
}
function E(n) {
    n.g || (n.g = !0, n.l && E(n.l));
}
function R(n) {
    n.i || (n.i = p(n.u));
}
function k(n, r, t) {
    var e = c(r) ? y("MapSet").K(r, t) : v(r) ? y("MapSet").$(r, t) : n.S ? function(n, r) {
        var t = Array.isArray(n), e = {
            t: t ? 1 : 0,
            A: r ? r.A : b(),
            g: !1,
            R: !1,
            N: {},
            l: r,
            u: n,
            k: null,
            i: null,
            j: null,
            C: !1
        }, i = e, u = Y;
        t && (i = [
            e
        ], u = Z);
        var o = Proxy.revocable(i, u), f = o.revoke, a = o.proxy;
        return e.k = a, e.j = f, a;
    }(r, t) : y("ES5").I(r, t);
    return (t ? t.A : b()).p.push(e), e;
}
function F(u) {
    return r(u) || n(22, u), function n(r) {
        if (!t(r)) return r;
        var u, a = r[H], c = i(r);
        if (a) {
            if (!a.g && (a.t < 4 || !y("ES5").J(a))) return a.u;
            a.R = !0, u = N(r, c), a.R = !1;
        } else u = N(r, c);
        return e(u, function(r, t) {
            a && o(a.u, r) === t || f(u, r, n(t));
        }), 3 === c ? new Set(u) : u;
    }(u);
}
function N(n, r) {
    switch(r){
        case 2:
            return new Map(n);
        case 3:
            return Array.from(n);
    }
    return p(n);
}
function D() {
    function n(n, r) {
        var t = f[n];
        return t ? t.enumerable = r : f[n] = t = {
            configurable: !0,
            enumerable: r,
            get: function() {
                return Y.get(this[H], n);
            },
            set: function(r) {
                Y.set(this[H], n, r);
            }
        }, t;
    }
    function t(n) {
        for(var r = n.length - 1; r >= 0; r--){
            var t = n[r][H];
            if (!t.g) switch(t.t){
                case 5:
                    o(t) && E(t);
                    break;
                case 4:
                    i(t) && E(t);
            }
        }
    }
    function i(n) {
        for(var r = n.u, t = n.k, e = T(t), i = e.length - 1; i >= 0; i--){
            var o = e[i];
            if (o !== H) {
                var f = r[o];
                if (void 0 === f && !u(r, o)) return !0;
                var c = t[o], v = c && c[H];
                if (v ? v.u !== f : !a(c, f)) return !0;
            }
        }
        var s = !!r[H];
        return e.length !== T(r).length + (s ? 0 : 1);
    }
    function o(n) {
        var r = n.k;
        if (r.length !== n.u.length) return !0;
        var t = Object.getOwnPropertyDescriptor(r, r.length - 1);
        if (t && !t.get) return !0;
        for(var e = 0; e < r.length; e++)if (!r.hasOwnProperty(e)) return !0;
        return !1;
    }
    var f = {};
    _("ES5", {
        I: function(r, t) {
            var e = Array.isArray(r), i = function(r, t) {
                if (r) {
                    for(var e = Array(t.length), i = 0; i < t.length; i++)Object.defineProperty(e, "" + i, n(i, !0));
                    return e;
                }
                var u = U(t);
                delete u[H];
                for(var o = T(u), f = 0; f < o.length; f++){
                    var a = o[f];
                    u[a] = n(a, r || !!u[a].enumerable);
                }
                return Object.create(Object.getPrototypeOf(t), u);
            }(e, r), u = {
                t: e ? 5 : 4,
                A: t ? t.A : b(),
                g: !1,
                R: !1,
                N: {},
                l: t,
                u: r,
                k: i,
                i: null,
                O: !1,
                C: !1
            };
            return Object.defineProperty(i, H, {
                value: u,
                writable: !0
            }), i;
        },
        P: function(n, i, f) {
            f ? r(i) && i[H].A === n && t(n.p) : (n.o && function n(r) {
                if (r && "object" == typeof r) {
                    var t = r[H];
                    if (t) {
                        var i = t.u, f = t.k, a = t.N, c = t.t;
                        if (4 === c) e(f, function(r) {
                            r !== H && (void 0 !== i[r] || u(i, r) ? a[r] || n(f[r]) : (a[r] = !0, E(t)));
                        }), e(i, function(n) {
                            void 0 !== f[n] || u(f, n) || (a[n] = !1, E(t));
                        });
                        else if (5 === c) {
                            if (o(t) && (E(t), a.length = !0), f.length < i.length) for(var v = f.length; v < i.length; v++)a[v] = !1;
                            else for(var s = i.length; s < f.length; s++)a[s] = !0;
                            for(var p = Math.min(f.length, i.length), l = 0; l < p; l++)f.hasOwnProperty(l) || (a[l] = !0), void 0 === a[l] && n(f[l]);
                        }
                    }
                }
            }(n.p[0]), t(n.p));
        },
        J: function(n) {
            return 4 === n.t ? i(n) : o(n);
        }
    });
}
function K() {
    function f(n) {
        if (!t(n)) return n;
        if (Array.isArray(n)) return n.map(f);
        if (c(n)) return new Map(Array.from(n.entries()).map(function(n) {
            return [
                n[0],
                f(n[1])
            ];
        }));
        if (v(n)) return new Set(Array.from(n).map(f));
        var r = Object.create(Object.getPrototypeOf(n));
        for(var e in n)r[e] = f(n[e]);
        return u(n, G) && (r[G] = n[G]), r;
    }
    function a(n) {
        return r(n) ? f(n) : n;
    }
    var s = "add";
    _("Patches", {
        W: function(r, t) {
            return t.forEach(function(t) {
                for(var e = t.path, u = t.op, a = r, c = 0; c < e.length - 1; c++){
                    var v = i(a), p = e[c];
                    "string" != typeof p && "number" != typeof p && (p = "" + p), 0 !== v && 1 !== v || "__proto__" !== p && "constructor" !== p || n(24), "function" == typeof a && "prototype" === p && n(24), "object" != typeof (a = o(a, p)) && n(15, e.join("/"));
                }
                var l = i(a), d = f(t.value), h = e[e.length - 1];
                switch(u){
                    case "replace":
                        switch(l){
                            case 2:
                                return a.set(h, d);
                            case 3:
                                n(16);
                            default:
                                return a[h] = d;
                        }
                    case s:
                        switch(l){
                            case 1:
                                return "-" === h ? a.push(d) : a.splice(h, 0, d);
                            case 2:
                                return a.set(h, d);
                            case 3:
                                return a.add(d);
                            default:
                                return a[h] = d;
                        }
                    case "remove":
                        switch(l){
                            case 1:
                                return a.splice(h, 1);
                            case 2:
                                return a.delete(h);
                            case 3:
                                return a.delete(t.value);
                            default:
                                return delete a[h];
                        }
                    default:
                        n(17, u);
                }
            }), r;
        },
        F: function(n, r, t, i) {
            switch(n.t){
                case 0:
                case 4:
                case 2:
                    return function(n, r, t, i) {
                        var f = n.u, c = n.i;
                        e(n.N, function(n, e) {
                            var v = o(f, n), p = o(c, n), l = e ? u(f, n) ? "replace" : s : "remove";
                            if (v !== p || "replace" !== l) {
                                var d = r.concat(n);
                                t.push("remove" === l ? {
                                    op: l,
                                    path: d
                                } : {
                                    op: l,
                                    path: d,
                                    value: p
                                }), i.push(l === s ? {
                                    op: "remove",
                                    path: d
                                } : "remove" === l ? {
                                    op: s,
                                    path: d,
                                    value: a(v)
                                } : {
                                    op: "replace",
                                    path: d,
                                    value: a(v)
                                });
                            }
                        });
                    }(n, r, t, i);
                case 5:
                case 1:
                    return function(n, r, t, e) {
                        var i = n.u, u = n.N, o = n.i;
                        if (o.length < i.length) {
                            var f = [
                                o,
                                i
                            ];
                            i = f[0], o = f[1];
                            var c = [
                                e,
                                t
                            ];
                            t = c[0], e = c[1];
                        }
                        for(var v = 0; v < i.length; v++)if (u[v] && o[v] !== i[v]) {
                            var p = r.concat([
                                v
                            ]);
                            t.push({
                                op: "replace",
                                path: p,
                                value: a(o[v])
                            }), e.push({
                                op: "replace",
                                path: p,
                                value: a(i[v])
                            });
                        }
                        for(var l = i.length; l < o.length; l++){
                            var d = r.concat([
                                l
                            ]);
                            t.push({
                                op: s,
                                path: d,
                                value: a(o[l])
                            });
                        }
                        i.length < o.length && e.push({
                            op: "replace",
                            path: r.concat([
                                "length"
                            ]),
                            value: i.length
                        });
                    }(n, r, t, i);
                case 3:
                    return function(n, r, t, e) {
                        var i = n.u, u = n.i, o = 0;
                        i.forEach(function(n) {
                            if (!u.has(n)) {
                                var i = r.concat([
                                    o
                                ]);
                                t.push({
                                    op: "remove",
                                    path: i,
                                    value: n
                                }), e.unshift({
                                    op: s,
                                    path: i,
                                    value: n
                                });
                            }
                            o++;
                        }), o = 0, u.forEach(function(n) {
                            if (!i.has(n)) {
                                var u = r.concat([
                                    o
                                ]);
                                t.push({
                                    op: s,
                                    path: u,
                                    value: n
                                }), e.unshift({
                                    op: "remove",
                                    path: u,
                                    value: n
                                });
                            }
                            o++;
                        });
                    }(n, r, t, i);
            }
        },
        M: function(n, r, t, e) {
            t.push({
                op: "replace",
                path: [],
                value: r === B ? void 0 : r
            }), e.push({
                op: "replace",
                path: [],
                value: n
            });
        }
    });
}
function $() {
    function r(n, r) {
        function t() {
            this.constructor = n;
        }
        f(n, r), n.prototype = (t.prototype = r.prototype, new t);
    }
    function i(n) {
        n.i || (n.N = new Map, n.i = new Map(n.u));
    }
    function u(n) {
        n.i || (n.i = new Set, n.u.forEach(function(r) {
            if (t(r)) {
                var e = k(n.A.h, r, n);
                n.p.set(r, e), n.i.add(e);
            } else n.i.add(r);
        }));
    }
    function o(r) {
        r.O && n(3, JSON.stringify(s(r)));
    }
    var f = function(n, r) {
        return (f = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(n, r) {
            n.__proto__ = r;
        } || function(n, r) {
            for(var t in r)r.hasOwnProperty(t) && (n[t] = r[t]);
        })(n, r);
    }, a = function() {
        function n(n, r) {
            return this[H] = {
                t: 2,
                l: r,
                A: r ? r.A : b(),
                g: !1,
                R: !1,
                i: void 0,
                N: void 0,
                u: n,
                k: this,
                C: !1,
                O: !1
            }, this;
        }
        r(n, Map);
        var u = n.prototype;
        return Object.defineProperty(u, "size", {
            get: function() {
                return s(this[H]).size;
            }
        }), u.has = function(n) {
            return s(this[H]).has(n);
        }, u.set = function(n, r) {
            var t = this[H];
            return o(t), s(t).has(n) && s(t).get(n) === r || (i(t), E(t), t.N.set(n, !0), t.i.set(n, r), t.N.set(n, !0)), this;
        }, u.delete = function(n) {
            if (!this.has(n)) return !1;
            var r = this[H];
            return o(r), i(r), E(r), r.u.has(n) ? r.N.set(n, !1) : r.N.delete(n), r.i.delete(n), !0;
        }, u.clear = function() {
            var n = this[H];
            o(n), s(n).size && (i(n), E(n), n.N = new Map, e(n.u, function(r) {
                n.N.set(r, !1);
            }), n.i.clear());
        }, u.forEach = function(n, r) {
            var t = this;
            s(this[H]).forEach(function(e, i) {
                n.call(r, t.get(i), i, t);
            });
        }, u.get = function(n) {
            var r = this[H];
            o(r);
            var e = s(r).get(n);
            if (r.R || !t(e)) return e;
            if (e !== r.u.get(n)) return e;
            var u = k(r.A.h, e, r);
            return i(r), r.i.set(n, u), u;
        }, u.keys = function() {
            return s(this[H]).keys();
        }, u.values = function() {
            var n, r = this, t = this.keys();
            return (n = {})[L] = function() {
                return r.values();
            }, n.next = function() {
                var n = t.next();
                return n.done ? n : {
                    done: !1,
                    value: r.get(n.value)
                };
            }, n;
        }, u.entries = function() {
            var n, r = this, t = this.keys();
            return (n = {})[L] = function() {
                return r.entries();
            }, n.next = function() {
                var n = t.next();
                if (n.done) return n;
                var e = r.get(n.value);
                return {
                    done: !1,
                    value: [
                        n.value,
                        e
                    ]
                };
            }, n;
        }, u[L] = function() {
            return this.entries();
        }, n;
    }(), c = function() {
        function n(n, r) {
            return this[H] = {
                t: 3,
                l: r,
                A: r ? r.A : b(),
                g: !1,
                R: !1,
                i: void 0,
                u: n,
                k: this,
                p: new Map,
                O: !1,
                C: !1
            }, this;
        }
        r(n, Set);
        var t = n.prototype;
        return Object.defineProperty(t, "size", {
            get: function() {
                return s(this[H]).size;
            }
        }), t.has = function(n) {
            var r = this[H];
            return o(r), r.i ? !!r.i.has(n) || !(!r.p.has(n) || !r.i.has(r.p.get(n))) : r.u.has(n);
        }, t.add = function(n) {
            var r = this[H];
            return o(r), this.has(n) || (u(r), E(r), r.i.add(n)), this;
        }, t.delete = function(n) {
            if (!this.has(n)) return !1;
            var r = this[H];
            return o(r), u(r), E(r), r.i.delete(n) || !!r.p.has(n) && r.i.delete(r.p.get(n));
        }, t.clear = function() {
            var n = this[H];
            o(n), s(n).size && (u(n), E(n), n.i.clear());
        }, t.values = function() {
            var n = this[H];
            return o(n), u(n), n.i.values();
        }, t.entries = function() {
            var n = this[H];
            return o(n), u(n), n.i.entries();
        }, t.keys = function() {
            return this.values();
        }, t[L] = function() {
            return this.values();
        }, t.forEach = function(n, r) {
            for(var t = this.values(), e = t.next(); !e.done;)n.call(r, e.value, e.value, this), e = t.next();
        }, n;
    }();
    _("MapSet", {
        K: function(n, r) {
            return new a(n, r);
        },
        $: function(n, r) {
            return new c(n, r);
        }
    });
}
var C;
Object.defineProperty(exports, "__esModule", ({
    value: !0
}));
var I, J = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x"), W = "undefined" != typeof Map, X = "undefined" != typeof Set, q = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect, B = J ? Symbol.for("immer-nothing") : ((C = {})["immer-nothing"] = !0, C), G = J ? Symbol.for("immer-draftable") : "__$immer_draftable", H = J ? Symbol.for("immer-state") : "__$immer_state", L = "undefined" != typeof Symbol && Symbol.iterator || "@@iterator", Q = "" + Object.prototype.constructor, T = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n) {
    return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n));
} : Object.getOwnPropertyNames, U = Object.getOwnPropertyDescriptors || function(n) {
    var r = {};
    return T(n).forEach(function(t) {
        r[t] = Object.getOwnPropertyDescriptor(n, t);
    }), r;
}, V = {}, Y = {
    get: function(n, r) {
        if (r === H) return n;
        var e = s(n);
        if (!u(e, r)) return function(n, r, t) {
            var e, i = z(r, t);
            return i ? "value" in i ? i.value : null === (e = i.get) || void 0 === e ? void 0 : e.call(n.k) : void 0;
        }(n, e, r);
        var i = e[r];
        return n.R || !t(i) ? i : i === A(n.u, r) ? (R(n), n.i[r] = k(n.A.h, i, n)) : i;
    },
    has: function(n, r) {
        return r in s(n);
    },
    ownKeys: function(n) {
        return Reflect.ownKeys(s(n));
    },
    set: function(n, r, t) {
        var e = z(s(n), r);
        if (null == e ? void 0 : e.set) return e.set.call(n.k, t), !0;
        if (!n.g) {
            var i = A(s(n), r), o = null == i ? void 0 : i[H];
            if (o && o.u === t) return n.i[r] = t, n.N[r] = !1, !0;
            if (a(t, i) && (void 0 !== t || u(n.u, r))) return !0;
            R(n), E(n);
        }
        return n.i[r] === t && (void 0 !== t || r in n.i) || Number.isNaN(t) && Number.isNaN(n.i[r]) || (n.i[r] = t, n.N[r] = !0), !0;
    },
    deleteProperty: function(n, r) {
        return void 0 !== A(n.u, r) || r in n.u ? (n.N[r] = !1, R(n), E(n)) : delete n.N[r], n.i && delete n.i[r], !0;
    },
    getOwnPropertyDescriptor: function(n, r) {
        var t = s(n), e = Reflect.getOwnPropertyDescriptor(t, r);
        return e ? {
            writable: !0,
            configurable: 1 !== n.t || "length" !== r,
            enumerable: e.enumerable,
            value: t[r]
        } : e;
    },
    defineProperty: function() {
        n(11);
    },
    getPrototypeOf: function(n) {
        return Object.getPrototypeOf(n.u);
    },
    setPrototypeOf: function() {
        n(12);
    }
}, Z = {};
e(Y, function(n, r) {
    Z[n] = function() {
        return arguments[0] = arguments[0][0], r.apply(this, arguments);
    };
}), Z.deleteProperty = function(n, r) {
    return Z.set.call(this, n, r, void 0);
}, Z.set = function(n, r, t) {
    return Y.set.call(this, n[0], r, t, n[0]);
};
var nn = function() {
    function e(r) {
        var e = this;
        this.S = q, this.D = !0, this.produce = function(r, i, u) {
            if ("function" == typeof r && "function" != typeof i) {
                var o = i;
                i = r;
                var f = e;
                return function(n) {
                    var r = this;
                    void 0 === n && (n = o);
                    for(var t = arguments.length, e = Array(t > 1 ? t - 1 : 0), u = 1; u < t; u++)e[u - 1] = arguments[u];
                    return f.produce(n, function(n) {
                        var t;
                        return (t = i).call.apply(t, [
                            r,
                            n
                        ].concat(e));
                    });
                };
            }
            var a;
            if ("function" != typeof i && n(6), void 0 !== u && "function" != typeof u && n(7), t(r)) {
                var c = x(e), v = k(e, r, void 0), s = !0;
                try {
                    a = i(v), s = !1;
                } finally{
                    s ? j(c) : O(c);
                }
                return "undefined" != typeof Promise && a instanceof Promise ? a.then(function(n) {
                    return m(c, u), S(n, c);
                }, function(n) {
                    throw j(c), n;
                }) : (m(c, u), S(a, c));
            }
            if (!r || "object" != typeof r) {
                if (void 0 === (a = i(r)) && (a = r), a === B && (a = void 0), e.D && l(a, !0), u) {
                    var p = [], d = [];
                    y("Patches").M(r, a, p, d), u(p, d);
                }
                return a;
            }
            n(21, r);
        }, this.produceWithPatches = function(n, r) {
            if ("function" == typeof n) return function(r) {
                for(var t = arguments.length, i = Array(t > 1 ? t - 1 : 0), u = 1; u < t; u++)i[u - 1] = arguments[u];
                return e.produceWithPatches(r, function(r) {
                    return n.apply(void 0, [
                        r
                    ].concat(i));
                });
            };
            var t, i, u = e.produce(n, r, function(n, r) {
                t = n, i = r;
            });
            return "undefined" != typeof Promise && u instanceof Promise ? u.then(function(n) {
                return [
                    n,
                    t,
                    i
                ];
            }) : [
                u,
                t,
                i
            ];
        }, "boolean" == typeof (null == r ? void 0 : r.useProxies) && this.setUseProxies(r.useProxies), "boolean" == typeof (null == r ? void 0 : r.autoFreeze) && this.setAutoFreeze(r.autoFreeze);
    }
    var i = e.prototype;
    return i.createDraft = function(e) {
        t(e) || n(8), r(e) && (e = F(e));
        var i = x(this), u = k(this, e, void 0);
        return u[H].C = !0, O(i), u;
    }, i.finishDraft = function(n, r) {
        var t = (n && n[H]).A;
        return m(t, r), S(void 0, t);
    }, i.setAutoFreeze = function(n) {
        this.D = n;
    }, i.setUseProxies = function(r) {
        r && !q && n(20), this.S = r;
    }, i.applyPatches = function(n, t) {
        var e;
        for(e = t.length - 1; e >= 0; e--){
            var i = t[e];
            if (0 === i.path.length && "replace" === i.op) {
                n = i.value;
                break;
            }
        }
        e > -1 && (t = t.slice(e + 1));
        var u = y("Patches").W;
        return r(n) ? u(n, t) : this.produce(n, function(n) {
            return u(n, t);
        });
    }, e;
}(), rn = new nn, tn = rn.produce, en = rn.produceWithPatches.bind(rn), un = rn.setAutoFreeze.bind(rn), on = rn.setUseProxies.bind(rn), fn = rn.applyPatches.bind(rn), an = rn.createDraft.bind(rn), cn = rn.finishDraft.bind(rn);
exports.Immer = nn, exports.applyPatches = fn, exports.castDraft = function(n) {
    return n;
}, exports.castImmutable = function(n) {
    return n;
}, exports.createDraft = an, exports.current = F, exports["default"] = tn, exports.enableAllPlugins = function() {
    D(), $(), K();
}, exports.enableES5 = D, exports.enableMapSet = $, exports.enablePatches = K, exports.finishDraft = cn, exports.freeze = l, exports.immerable = G, exports.isDraft = r, exports.isDraftable = t, exports.nothing = B, exports.original = function(t) {
    return r(t) || n(23, t), t[H].u;
}, exports.produce = tn, exports.produceWithPatches = en, exports.setAutoFreeze = un, exports.setUseProxies = on; //# sourceMappingURL=immer.cjs.production.min.js.map


/***/ }),

/***/ 80822:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

if (true) {
    module.exports = __webpack_require__(42973);
} else {}


/***/ }),

/***/ 81329:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */ function isObject(o) {
    return Object.prototype.toString.call(o) === "[object Object]";
}
function isPlainObject(o) {
    var ctor, prot;
    if (isObject(o) === false) return false;
    // If has modified constructor
    ctor = o.constructor;
    if (ctor === undefined) return true;
    // If has modified prototype
    prot = ctor.prototype;
    if (isObject(prot) === false) return false;
    // If constructor does not have an Object-specific method
    if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
    }
    // Most likely a plain Object
    return true;
}
exports.isPlainObject = isPlainObject;


/***/ }),

/***/ 46136:
/***/ ((module) => {

"use strict";
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as references for various `Number` constants. */ 
var INFINITY = 1 / 0;
/** `Object#toString` result references. */ var symbolTag = "[object Symbol]";
/** Used to match Latin Unicode letters (excluding mathematical operators). */ var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
/** Used to compose unicode character classes. */ var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23", rsComboSymbolsRange = "\\u20d0-\\u20f0";
/** Used to compose unicode capture groups. */ var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */ var reComboMark = RegExp(rsCombo, "g");
/** Used to map Latin Unicode letters to basic Latin letters. */ var deburredLetters = {
    // Latin-1 Supplement block.
    "\xc0": "A",
    "\xc1": "A",
    "\xc2": "A",
    "\xc3": "A",
    "\xc4": "A",
    "\xc5": "A",
    "\xe0": "a",
    "\xe1": "a",
    "\xe2": "a",
    "\xe3": "a",
    "\xe4": "a",
    "\xe5": "a",
    "\xc7": "C",
    "\xe7": "c",
    "\xd0": "D",
    "\xf0": "d",
    "\xc8": "E",
    "\xc9": "E",
    "\xca": "E",
    "\xcb": "E",
    "\xe8": "e",
    "\xe9": "e",
    "\xea": "e",
    "\xeb": "e",
    "\xcc": "I",
    "\xcd": "I",
    "\xce": "I",
    "\xcf": "I",
    "\xec": "i",
    "\xed": "i",
    "\xee": "i",
    "\xef": "i",
    "\xd1": "N",
    "\xf1": "n",
    "\xd2": "O",
    "\xd3": "O",
    "\xd4": "O",
    "\xd5": "O",
    "\xd6": "O",
    "\xd8": "O",
    "\xf2": "o",
    "\xf3": "o",
    "\xf4": "o",
    "\xf5": "o",
    "\xf6": "o",
    "\xf8": "o",
    "\xd9": "U",
    "\xda": "U",
    "\xdb": "U",
    "\xdc": "U",
    "\xf9": "u",
    "\xfa": "u",
    "\xfb": "u",
    "\xfc": "u",
    "\xdd": "Y",
    "\xfd": "y",
    "\xff": "y",
    "\xc6": "Ae",
    "\xe6": "ae",
    "\xde": "Th",
    "\xfe": "th",
    "\xdf": "ss",
    // Latin Extended-A block.
    "": "A",
    "": "A",
    "": "A",
    "": "a",
    "": "a",
    "": "a",
    "": "C",
    "": "C",
    "": "C",
    "": "C",
    "": "c",
    "": "c",
    "": "c",
    "": "c",
    "": "D",
    "": "D",
    "": "d",
    "": "d",
    "": "E",
    "": "E",
    "": "E",
    "": "E",
    "": "E",
    "": "e",
    "": "e",
    "": "e",
    "": "e",
    "": "e",
    "": "G",
    "": "G",
    "": "G",
    "": "G",
    "": "g",
    "": "g",
    "": "g",
    "": "g",
    "": "H",
    "": "H",
    "": "h",
    "": "h",
    "": "I",
    "": "I",
    "": "I",
    "": "I",
    "": "I",
    "": "i",
    "": "i",
    "": "i",
    "": "i",
    "": "i",
    "": "J",
    "": "j",
    "": "K",
    "": "k",
    "": "k",
    "": "L",
    "": "L",
    "": "L",
    "": "L",
    "": "L",
    "": "l",
    "": "l",
    "": "l",
    "": "l",
    "": "l",
    "": "N",
    "": "N",
    "": "N",
    "": "N",
    "": "n",
    "": "n",
    "": "n",
    "": "n",
    "": "O",
    "": "O",
    "": "O",
    "": "o",
    "": "o",
    "": "o",
    "": "R",
    "": "R",
    "": "R",
    "": "r",
    "": "r",
    "": "r",
    "": "S",
    "": "S",
    "": "S",
    "": "S",
    "": "s",
    "": "s",
    "": "s",
    "": "s",
    "": "T",
    "": "T",
    "": "T",
    "": "t",
    "": "t",
    "": "t",
    "": "U",
    "": "U",
    "": "U",
    "": "U",
    "": "U",
    "": "U",
    "": "u",
    "": "u",
    "": "u",
    "": "u",
    "": "u",
    "": "u",
    "": "W",
    "": "w",
    "": "Y",
    "": "y",
    "": "Y",
    "": "Z",
    "": "Z",
    "": "Z",
    "": "z",
    "": "z",
    "": "z",
    "": "IJ",
    "": "ij",
    "": "Oe",
    "": "oe",
    "": "'n",
    "": "ss"
};
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == "object" && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function("return this")();
/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */ function basePropertyOf(object) {
    return function(key) {
        return object == null ? undefined : object[key];
    };
}
/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */ var deburrLetter = basePropertyOf(deburredLetters);
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Built-in value references. */ var Symbol = root.Symbol;
/** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */ function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == "string") {
        return value;
    }
    if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == "object";
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */ function toString(value) {
    return value == null ? "" : baseToString(value);
}
/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('dj vu');
 * // => 'deja vu'
 */ function deburr(string) {
    string = toString(string);
    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
}
module.exports = deburr;


/***/ }),

/***/ 7859:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({
    value: true
});
var isPlainObject = __webpack_require__(81329);
var immer = __webpack_require__(80822);
function unwrapExports(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function createCommonjsModule(fn, module) {
    return module = {
        exports: {}
    }, fn(module, module.exports), module.exports;
}
var arrayLikeToArray = createCommonjsModule(function(module) {
    function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for(var i = 0, arr2 = new Array(len); i < len; i++){
            arr2[i] = arr[i];
        }
        return arr2;
    }
    module.exports = _arrayLikeToArray;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
});
unwrapExports(arrayLikeToArray);
var arrayWithoutHoles = createCommonjsModule(function(module) {
    function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return arrayLikeToArray(arr);
    }
    module.exports = _arrayWithoutHoles;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
});
unwrapExports(arrayWithoutHoles);
var iterableToArray = createCommonjsModule(function(module) {
    function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }
    module.exports = _iterableToArray;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
});
unwrapExports(iterableToArray);
var unsupportedIterableToArray = createCommonjsModule(function(module) {
    function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
    }
    module.exports = _unsupportedIterableToArray;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
});
unwrapExports(unsupportedIterableToArray);
var nonIterableSpread = createCommonjsModule(function(module) {
    function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module.exports = _nonIterableSpread;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
});
unwrapExports(nonIterableSpread);
var toConsumableArray = createCommonjsModule(function(module) {
    function _toConsumableArray(arr) {
        return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
    }
    module.exports = _toConsumableArray;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
});
var _toConsumableArray = unwrapExports(toConsumableArray);
var defineProperty = createCommonjsModule(function(module) {
    function _defineProperty(obj, key, value) {
        if (key in obj) {
            Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
        } else {
            obj[key] = value;
        }
        return obj;
    }
    module.exports = _defineProperty;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
});
var _defineProperty = unwrapExports(defineProperty);
var arrayWithHoles = createCommonjsModule(function(module) {
    function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
    }
    module.exports = _arrayWithHoles;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
});
unwrapExports(arrayWithHoles);
var iterableToArrayLimit = createCommonjsModule(function(module) {
    function _iterableToArrayLimit(arr, i) {
        var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
        if (_i == null) return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _s, _e;
        try {
            for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
                _arr.push(_s.value);
                if (i && _arr.length === i) break;
            }
        } catch (err) {
            _d = true;
            _e = err;
        } finally{
            try {
                if (!_n && _i["return"] != null) _i["return"]();
            } finally{
                if (_d) throw _e;
            }
        }
        return _arr;
    }
    module.exports = _iterableToArrayLimit;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
});
unwrapExports(iterableToArrayLimit);
var nonIterableRest = createCommonjsModule(function(module) {
    function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module.exports = _nonIterableRest;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
});
unwrapExports(nonIterableRest);
var slicedToArray = createCommonjsModule(function(module) {
    function _slicedToArray(arr, i) {
        return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
    }
    module.exports = _slicedToArray;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
});
var _slicedToArray = unwrapExports(slicedToArray);
var DIRTY_PATHS = new WeakMap();
var DIRTY_PATH_KEYS = new WeakMap();
var FLUSHING = new WeakMap();
var NORMALIZING = new WeakMap();
var PATH_REFS = new WeakMap();
var POINT_REFS = new WeakMap();
var RANGE_REFS = new WeakMap();
function ownKeys$9(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread$9(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys$9(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys$9(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}
function _createForOfIteratorHelper$7(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = it.call(o);
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it["return"] != null) it["return"]();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray$7(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$7(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen);
}
function _arrayLikeToArray$7(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++){
        arr2[i] = arr[i];
    }
    return arr2;
}
/**
 * Create a new Slate `Editor` object.
 */ var createEditor = function createEditor() {
    var editor = {
        children: [],
        operations: [],
        selection: null,
        marks: null,
        isInline: function isInline() {
            return false;
        },
        isVoid: function isVoid() {
            return false;
        },
        markableVoid: function markableVoid() {
            return false;
        },
        onChange: function onChange() {},
        apply: function apply(op) {
            var _iterator = _createForOfIteratorHelper$7(Editor.pathRefs(editor)), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ref = _step.value;
                    PathRef.transform(ref, op);
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            var _iterator2 = _createForOfIteratorHelper$7(Editor.pointRefs(editor)), _step2;
            try {
                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                    var _ref = _step2.value;
                    PointRef.transform(_ref, op);
                }
            } catch (err) {
                _iterator2.e(err);
            } finally{
                _iterator2.f();
            }
            var _iterator3 = _createForOfIteratorHelper$7(Editor.rangeRefs(editor)), _step3;
            try {
                for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                    var _ref2 = _step3.value;
                    RangeRef.transform(_ref2, op);
                }
            } catch (err) {
                _iterator3.e(err);
            } finally{
                _iterator3.f();
            }
            var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];
            var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || new Set();
            var dirtyPaths;
            var dirtyPathKeys;
            var add = function add(path) {
                if (path) {
                    var key = path.join(",");
                    if (!dirtyPathKeys.has(key)) {
                        dirtyPathKeys.add(key);
                        dirtyPaths.push(path);
                    }
                }
            };
            if (Path.operationCanTransformPath(op)) {
                dirtyPaths = [];
                dirtyPathKeys = new Set();
                var _iterator4 = _createForOfIteratorHelper$7(oldDirtyPaths), _step4;
                try {
                    for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                        var path = _step4.value;
                        var newPath = Path.transform(path, op);
                        add(newPath);
                    }
                } catch (err) {
                    _iterator4.e(err);
                } finally{
                    _iterator4.f();
                }
            } else {
                dirtyPaths = oldDirtyPaths;
                dirtyPathKeys = oldDirtyPathKeys;
            }
            var newDirtyPaths = editor.getDirtyPaths(op);
            var _iterator5 = _createForOfIteratorHelper$7(newDirtyPaths), _step5;
            try {
                for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){
                    var _path = _step5.value;
                    add(_path);
                }
            } catch (err) {
                _iterator5.e(err);
            } finally{
                _iterator5.f();
            }
            DIRTY_PATHS.set(editor, dirtyPaths);
            DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);
            Transforms.transform(editor, op);
            editor.operations.push(op);
            Editor.normalize(editor, {
                operation: op
            }); // Clear any formats applied to the cursor if the selection changes.
            if (op.type === "set_selection") {
                editor.marks = null;
            }
            if (!FLUSHING.get(editor)) {
                FLUSHING.set(editor, true);
                Promise.resolve().then(function() {
                    FLUSHING.set(editor, false);
                    editor.onChange({
                        operation: op
                    });
                    editor.operations = [];
                });
            }
        },
        addMark: function addMark(key, value) {
            var selection = editor.selection;
            editor.markableVoid;
            if (selection) {
                var match = function match(node, path) {
                    if (!Text.isText(node)) {
                        return false; // marks can only be applied to text
                    }
                    var _Editor$parent = Editor.parent(editor, path), _Editor$parent2 = _slicedToArray(_Editor$parent, 2), parentNode = _Editor$parent2[0];
                    _Editor$parent2[1];
                    return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);
                };
                var expandedSelection = Range.isExpanded(selection);
                var markAcceptingVoidSelected = false;
                if (!expandedSelection) {
                    var _Editor$node = Editor.node(editor, selection), _Editor$node2 = _slicedToArray(_Editor$node, 2), selectedNode = _Editor$node2[0], selectedPath = _Editor$node2[1];
                    if (selectedNode && match(selectedNode, selectedPath)) {
                        var _Editor$parent3 = Editor.parent(editor, selectedPath), _Editor$parent4 = _slicedToArray(_Editor$parent3, 1), parentNode = _Editor$parent4[0];
                        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);
                    }
                }
                if (expandedSelection || markAcceptingVoidSelected) {
                    Transforms.setNodes(editor, _defineProperty({}, key, value), {
                        match: match,
                        split: true,
                        voids: true
                    });
                } else {
                    var marks = _objectSpread$9(_objectSpread$9({}, Editor.marks(editor) || {}), {}, _defineProperty({}, key, value));
                    editor.marks = marks;
                    if (!FLUSHING.get(editor)) {
                        editor.onChange();
                    }
                }
            }
        },
        deleteBackward: function deleteBackward(unit) {
            var selection = editor.selection;
            if (selection && Range.isCollapsed(selection)) {
                Transforms["delete"](editor, {
                    unit: unit,
                    reverse: true
                });
            }
        },
        deleteForward: function deleteForward(unit) {
            var selection = editor.selection;
            if (selection && Range.isCollapsed(selection)) {
                Transforms["delete"](editor, {
                    unit: unit
                });
            }
        },
        deleteFragment: function deleteFragment(direction) {
            var selection = editor.selection;
            if (selection && Range.isExpanded(selection)) {
                Transforms["delete"](editor, {
                    reverse: direction === "backward"
                });
            }
        },
        getFragment: function getFragment() {
            var selection = editor.selection;
            if (selection) {
                return Node.fragment(editor, selection);
            }
            return [];
        },
        insertBreak: function insertBreak() {
            Transforms.splitNodes(editor, {
                always: true
            });
        },
        insertSoftBreak: function insertSoftBreak() {
            Transforms.splitNodes(editor, {
                always: true
            });
        },
        insertFragment: function insertFragment(fragment) {
            Transforms.insertFragment(editor, fragment);
        },
        insertNode: function insertNode(node) {
            Transforms.insertNodes(editor, node);
        },
        insertText: function insertText(text) {
            var selection = editor.selection, marks = editor.marks;
            if (selection) {
                if (marks) {
                    var node = _objectSpread$9({
                        text: text
                    }, marks);
                    Transforms.insertNodes(editor, node);
                } else {
                    Transforms.insertText(editor, text);
                }
                editor.marks = null;
            }
        },
        normalizeNode: function normalizeNode(entry) {
            var _entry = _slicedToArray(entry, 2), node = _entry[0], path = _entry[1]; // There are no core normalizations for text nodes.
            if (Text.isText(node)) {
                return;
            } // Ensure that block and inline nodes have at least one text child.
            if (Element.isElement(node) && node.children.length === 0) {
                var child = {
                    text: ""
                };
                Transforms.insertNodes(editor, child, {
                    at: path.concat(0),
                    voids: true
                });
                return;
            } // Determine whether the node should have block or inline children.
            var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0])); // Since we'll be applying operations while iterating, keep track of an
            // index that accounts for any added/removed nodes.
            var n = 0;
            for(var i = 0; i < node.children.length; i++, n++){
                var currentNode = Node.get(editor, path);
                if (Text.isText(currentNode)) continue;
                var _child = node.children[i];
                var prev = currentNode.children[n - 1];
                var isLast = i === node.children.length - 1;
                var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child); // Only allow block nodes in the top-level children and parent blocks
                // that only contain block nodes. Similarly, only allow inline nodes in
                // other inline nodes, or parent blocks that only contain inlines and
                // text.
                if (isInlineOrText !== shouldHaveInlines) {
                    Transforms.removeNodes(editor, {
                        at: path.concat(n),
                        voids: true
                    });
                    n--;
                } else if (Element.isElement(_child)) {
                    // Ensure that inline nodes are surrounded by text nodes.
                    if (editor.isInline(_child)) {
                        if (prev == null || !Text.isText(prev)) {
                            var newChild = {
                                text: ""
                            };
                            Transforms.insertNodes(editor, newChild, {
                                at: path.concat(n),
                                voids: true
                            });
                            n++;
                        } else if (isLast) {
                            var _newChild = {
                                text: ""
                            };
                            Transforms.insertNodes(editor, _newChild, {
                                at: path.concat(n + 1),
                                voids: true
                            });
                            n++;
                        }
                    }
                } else {
                    // Merge adjacent text nodes that are empty or match.
                    if (prev != null && Text.isText(prev)) {
                        if (Text.equals(_child, prev, {
                            loose: true
                        })) {
                            Transforms.mergeNodes(editor, {
                                at: path.concat(n),
                                voids: true
                            });
                            n--;
                        } else if (prev.text === "") {
                            Transforms.removeNodes(editor, {
                                at: path.concat(n - 1),
                                voids: true
                            });
                            n--;
                        } else if (_child.text === "") {
                            Transforms.removeNodes(editor, {
                                at: path.concat(n),
                                voids: true
                            });
                            n--;
                        }
                    }
                }
            }
        },
        removeMark: function removeMark(key) {
            var selection = editor.selection;
            if (selection) {
                var match = function match(node, path) {
                    if (!Text.isText(node)) {
                        return false; // marks can only be applied to text
                    }
                    var _Editor$parent5 = Editor.parent(editor, path), _Editor$parent6 = _slicedToArray(_Editor$parent5, 2), parentNode = _Editor$parent6[0];
                    _Editor$parent6[1];
                    return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);
                };
                var expandedSelection = Range.isExpanded(selection);
                var markAcceptingVoidSelected = false;
                if (!expandedSelection) {
                    var _Editor$node3 = Editor.node(editor, selection), _Editor$node4 = _slicedToArray(_Editor$node3, 2), selectedNode = _Editor$node4[0], selectedPath = _Editor$node4[1];
                    if (selectedNode && match(selectedNode, selectedPath)) {
                        var _Editor$parent7 = Editor.parent(editor, selectedPath), _Editor$parent8 = _slicedToArray(_Editor$parent7, 1), parentNode = _Editor$parent8[0];
                        markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);
                    }
                }
                if (expandedSelection || markAcceptingVoidSelected) {
                    Transforms.unsetNodes(editor, key, {
                        match: match,
                        split: true,
                        voids: true
                    });
                } else {
                    var marks = _objectSpread$9({}, Editor.marks(editor) || {});
                    delete marks[key];
                    editor.marks = marks;
                    if (!FLUSHING.get(editor)) {
                        editor.onChange();
                    }
                }
            }
        },
        /**
     * Get the "dirty" paths generated from an operation.
     */ getDirtyPaths: function getDirtyPaths(op) {
            switch(op.type){
                case "insert_text":
                case "remove_text":
                case "set_node":
                    {
                        var path = op.path;
                        return Path.levels(path);
                    }
                case "insert_node":
                    {
                        var node = op.node, _path2 = op.path;
                        var levels = Path.levels(_path2);
                        var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), function(_ref3) {
                            var _ref4 = _slicedToArray(_ref3, 2), p = _ref4[1];
                            return _path2.concat(p);
                        });
                        return [].concat(_toConsumableArray(levels), _toConsumableArray(descendants));
                    }
                case "merge_node":
                    {
                        var _path3 = op.path;
                        var ancestors = Path.ancestors(_path3);
                        var previousPath = Path.previous(_path3);
                        return [].concat(_toConsumableArray(ancestors), [
                            previousPath
                        ]);
                    }
                case "move_node":
                    {
                        var _path4 = op.path, newPath = op.newPath;
                        if (Path.equals(_path4, newPath)) {
                            return [];
                        }
                        var oldAncestors = [];
                        var newAncestors = [];
                        var _iterator6 = _createForOfIteratorHelper$7(Path.ancestors(_path4)), _step6;
                        try {
                            for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){
                                var ancestor = _step6.value;
                                var p = Path.transform(ancestor, op);
                                oldAncestors.push(p);
                            }
                        } catch (err) {
                            _iterator6.e(err);
                        } finally{
                            _iterator6.f();
                        }
                        var _iterator7 = _createForOfIteratorHelper$7(Path.ancestors(newPath)), _step7;
                        try {
                            for(_iterator7.s(); !(_step7 = _iterator7.n()).done;){
                                var _ancestor = _step7.value;
                                var _p = Path.transform(_ancestor, op);
                                newAncestors.push(_p);
                            }
                        } catch (err) {
                            _iterator7.e(err);
                        } finally{
                            _iterator7.f();
                        }
                        var newParent = newAncestors[newAncestors.length - 1];
                        var newIndex = newPath[newPath.length - 1];
                        var resultPath = newParent.concat(newIndex);
                        return [].concat(oldAncestors, newAncestors, [
                            resultPath
                        ]);
                    }
                case "remove_node":
                    {
                        var _path5 = op.path;
                        var _ancestors = Path.ancestors(_path5);
                        return _toConsumableArray(_ancestors);
                    }
                case "split_node":
                    {
                        var _path6 = op.path;
                        var _levels = Path.levels(_path6);
                        var nextPath = Path.next(_path6);
                        return [].concat(_toConsumableArray(_levels), [
                            nextPath
                        ]);
                    }
                default:
                    {
                        return [];
                    }
            }
        },
        shouldNormalize: function shouldNormalize(_ref5) {
            var iteration = _ref5.iteration, initialDirtyPathsLength = _ref5.initialDirtyPathsLength;
            var maxIterations = initialDirtyPathsLength * 42; // HACK: better way?
            if (iteration > maxIterations) {
                throw new Error("Could not completely normalize the editor after ".concat(maxIterations, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
            }
            return true;
        }
    };
    return editor;
};
var objectWithoutPropertiesLoose = createCommonjsModule(function(module) {
    function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null) return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i;
        for(i = 0; i < sourceKeys.length; i++){
            key = sourceKeys[i];
            if (excluded.indexOf(key) >= 0) continue;
            target[key] = source[key];
        }
        return target;
    }
    module.exports = _objectWithoutPropertiesLoose;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
});
unwrapExports(objectWithoutPropertiesLoose);
var objectWithoutProperties = createCommonjsModule(function(module) {
    function _objectWithoutProperties(source, excluded) {
        if (source == null) return {};
        var target = objectWithoutPropertiesLoose(source, excluded);
        var key, i;
        if (Object.getOwnPropertySymbols) {
            var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
            for(i = 0; i < sourceSymbolKeys.length; i++){
                key = sourceSymbolKeys[i];
                if (excluded.indexOf(key) >= 0) continue;
                if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
                target[key] = source[key];
            }
        }
        return target;
    }
    module.exports = _objectWithoutProperties;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
});
var _objectWithoutProperties = unwrapExports(objectWithoutProperties);
function _createForOfIteratorHelper$6(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = it.call(o);
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it["return"] != null) it["return"]();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray$6(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$6(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen);
}
function _arrayLikeToArray$6(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++){
        arr2[i] = arr[i];
    }
    return arr2;
}
// Character (grapheme cluster) boundaries are determined according to
// the default grapheme cluster boundary specification, extended grapheme clusters variant[1].
//
// References:
//
// [1] https://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table
// [2] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt
// [3] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.html
// [4] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt
/**
 * Get the distance to the end of the first character in a string of text.
 */ var getCharacterDistance = function getCharacterDistance(str) {
    var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var isLTR = !isRTL;
    var codepoints = isRTL ? codepointsIteratorRTL(str) : str;
    var left = CodepointType.None;
    var right = CodepointType.None;
    var distance = 0; // Evaluation of these conditions are deferred.
    var gb11 = null; // Is GB11 applicable?
    var gb12Or13 = null; // Is GB12 or GB13 applicable?
    var _iterator = _createForOfIteratorHelper$6(codepoints), _step;
    try {
        for(_iterator.s(); !(_step = _iterator.n()).done;){
            var _char = _step.value;
            var code = _char.codePointAt(0);
            if (!code) break;
            var type = getCodepointType(_char, code);
            var _ref = isLTR ? [
                right,
                type
            ] : [
                type,
                left
            ];
            var _ref2 = _slicedToArray(_ref, 2);
            left = _ref2[0];
            right = _ref2[1];
            if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {
                if (isLTR) {
                    gb11 = endsWithEmojiZWJ(str.substring(0, distance));
                } else {
                    gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));
                }
                if (!gb11) break;
            }
            if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {
                if (gb12Or13 !== null) {
                    gb12Or13 = !gb12Or13;
                } else {
                    if (isLTR) {
                        gb12Or13 = true;
                    } else {
                        gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));
                    }
                }
                if (!gb12Or13) break;
            }
            if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {
                break;
            }
            distance += _char.length;
        }
    } catch (err) {
        _iterator.e(err);
    } finally{
        _iterator.f();
    }
    return distance || 1;
};
var SPACE = /\s/;
var PUNCTUATION = /[\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
var CHAMELEON = /['\u2018\u2019]/;
/**
 * Get the distance to the end of the first word in a string of text.
 */ var getWordDistance = function getWordDistance(text) {
    var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var dist = 0;
    var started = false;
    while(text.length > 0){
        var charDist = getCharacterDistance(text, isRTL);
        var _splitByCharacterDist = splitByCharacterDistance(text, charDist, isRTL), _splitByCharacterDist2 = _slicedToArray(_splitByCharacterDist, 2), _char2 = _splitByCharacterDist2[0], remaining = _splitByCharacterDist2[1];
        if (isWordCharacter(_char2, remaining, isRTL)) {
            started = true;
            dist += charDist;
        } else if (!started) {
            dist += charDist;
        } else {
            break;
        }
        text = remaining;
    }
    return dist;
};
/**
 * Split a string in two parts at a given distance starting from the end when
 * `isRTL` is set to `true`.
 */ var splitByCharacterDistance = function splitByCharacterDistance(str, dist, isRTL) {
    if (isRTL) {
        var at = str.length - dist;
        return [
            str.slice(at, str.length),
            str.slice(0, at)
        ];
    }
    return [
        str.slice(0, dist),
        str.slice(dist)
    ];
};
/**
 * Check if a character is a word character. The `remaining` argument is used
 * because sometimes you must read subsequent characters to truly determine it.
 */ var isWordCharacter = function isWordCharacter(_char3, remaining) {
    var isRTL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (SPACE.test(_char3)) {
        return false;
    } // Chameleons count as word characters as long as they're in a word, so
    // recurse to see if the next one is a word character or not.
    if (CHAMELEON.test(_char3)) {
        var charDist = getCharacterDistance(remaining, isRTL);
        var _splitByCharacterDist3 = splitByCharacterDistance(remaining, charDist, isRTL), _splitByCharacterDist4 = _slicedToArray(_splitByCharacterDist3, 2), nextChar = _splitByCharacterDist4[0], nextRemaining = _splitByCharacterDist4[1];
        if (isWordCharacter(nextChar, nextRemaining, isRTL)) {
            return true;
        }
    }
    if (PUNCTUATION.test(_char3)) {
        return false;
    }
    return true;
};
/**
 * Iterate on codepoints from right to left.
 */ var codepointsIteratorRTL = function* codepointsIteratorRTL(str) {
    var end = str.length - 1;
    for(var i = 0; i < str.length; i++){
        var char1 = str.charAt(end - i);
        if (isLowSurrogate(char1.charCodeAt(0))) {
            var char2 = str.charAt(end - i - 1);
            if (isHighSurrogate(char2.charCodeAt(0))) {
                yield char2 + char1;
                i++;
                continue;
            }
        }
        yield char1;
    }
};
/**
 * Is `charCode` a high surrogate.
 *
 * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates
 */ var isHighSurrogate = function isHighSurrogate(charCode) {
    return charCode >= 0xd800 && charCode <= 0xdbff;
};
/**
 * Is `charCode` a low surrogate.
 *
 * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates
 */ var isLowSurrogate = function isLowSurrogate(charCode) {
    return charCode >= 0xdc00 && charCode <= 0xdfff;
};
var CodepointType;
(function(CodepointType) {
    CodepointType[CodepointType["None"] = 0] = "None";
    CodepointType[CodepointType["Extend"] = 1] = "Extend";
    CodepointType[CodepointType["ZWJ"] = 2] = "ZWJ";
    CodepointType[CodepointType["RI"] = 4] = "RI";
    CodepointType[CodepointType["Prepend"] = 8] = "Prepend";
    CodepointType[CodepointType["SpacingMark"] = 16] = "SpacingMark";
    CodepointType[CodepointType["L"] = 32] = "L";
    CodepointType[CodepointType["V"] = 64] = "V";
    CodepointType[CodepointType["T"] = 128] = "T";
    CodepointType[CodepointType["LV"] = 256] = "LV";
    CodepointType[CodepointType["LVT"] = 512] = "LVT";
    CodepointType[CodepointType["ExtPict"] = 1024] = "ExtPict";
    CodepointType[CodepointType["Any"] = 2048] = "Any";
})(CodepointType || (CodepointType = {}));
var reExtend = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1AC0\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/;
var rePrepend = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/;
var reSpacingMark = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/;
var reL = /^[\u1100-\u115F\uA960-\uA97C]$/;
var reV = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/;
var reT = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/;
var reLV = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/;
var reLVT = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/;
var reExtPict = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/;
var getCodepointType = function getCodepointType(_char4, code) {
    var type = CodepointType.Any;
    if (_char4.search(reExtend) !== -1) {
        type |= CodepointType.Extend;
    }
    if (code === 0x200d) {
        type |= CodepointType.ZWJ;
    }
    if (code >= 0x1f1e6 && code <= 0x1f1ff) {
        type |= CodepointType.RI;
    }
    if (_char4.search(rePrepend) !== -1) {
        type |= CodepointType.Prepend;
    }
    if (_char4.search(reSpacingMark) !== -1) {
        type |= CodepointType.SpacingMark;
    }
    if (_char4.search(reL) !== -1) {
        type |= CodepointType.L;
    }
    if (_char4.search(reV) !== -1) {
        type |= CodepointType.V;
    }
    if (_char4.search(reT) !== -1) {
        type |= CodepointType.T;
    }
    if (_char4.search(reLV) !== -1) {
        type |= CodepointType.LV;
    }
    if (_char4.search(reLVT) !== -1) {
        type |= CodepointType.LVT;
    }
    if (_char4.search(reExtPict) !== -1) {
        type |= CodepointType.ExtPict;
    }
    return type;
};
function intersects(x, y) {
    return (x & y) !== 0;
}
var NonBoundaryPairs = [
    [
        CodepointType.L,
        CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT
    ],
    [
        CodepointType.LV | CodepointType.V,
        CodepointType.V | CodepointType.T
    ],
    [
        CodepointType.LVT | CodepointType.T,
        CodepointType.T
    ],
    [
        CodepointType.Any,
        CodepointType.Extend | CodepointType.ZWJ
    ],
    [
        CodepointType.Any,
        CodepointType.SpacingMark
    ],
    [
        CodepointType.Prepend,
        CodepointType.Any
    ],
    [
        CodepointType.ZWJ,
        CodepointType.ExtPict
    ],
    [
        CodepointType.RI,
        CodepointType.RI
    ]
];
function isBoundaryPair(left, right) {
    return NonBoundaryPairs.findIndex(function(r) {
        return intersects(left, r[0]) && intersects(right, r[1]);
    }) === -1;
}
var endingEmojiZWJ = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1AC0\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/;
var endsWithEmojiZWJ = function endsWithEmojiZWJ(str) {
    return str.search(endingEmojiZWJ) !== -1;
};
var endingRIs = /(?:\uD83C[\uDDE6-\uDDFF])+$/g;
var endsWithOddNumberOfRIs = function endsWithOddNumberOfRIs(str) {
    var match = str.match(endingRIs);
    if (match === null) {
        return false;
    } else {
        // A RI is represented by a surrogate pair.
        var numRIs = match[0].length / 2;
        return numRIs % 2 === 1;
    }
};
/**
 * Shared the function with isElementType utility
 */ var isElement = function isElement(value) {
    return isPlainObject.isPlainObject(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);
}; // eslint-disable-next-line no-redeclare
var Element = {
    /**
   * Check if a value implements the 'Ancestor' interface.
   */ isAncestor: function isAncestor(value) {
        return isPlainObject.isPlainObject(value) && Node.isNodeList(value.children);
    },
    /**
   * Check if a value implements the `Element` interface.
   */ isElement: isElement,
    /**
   * Check if a value is an array of `Element` objects.
   */ isElementList: function isElementList(value) {
        return Array.isArray(value) && value.every(function(val) {
            return Element.isElement(val);
        });
    },
    /**
   * Check if a set of props is a partial of Element.
   */ isElementProps: function isElementProps(props) {
        return props.children !== undefined;
    },
    /**
   * Check if a value implements the `Element` interface and has elementKey with selected value.
   * Default it check to `type` key value
   */ isElementType: function isElementType(value, elementVal) {
        var elementKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "type";
        return isElement(value) && value[elementKey] === elementVal;
    },
    /**
   * Check if an element matches set of properties.
   *
   * Note: this checks custom properties, and it does not ensure that any
   * children are equivalent.
   */ matches: function matches(element, props) {
        for(var key in props){
            if (key === "children") {
                continue;
            }
            if (element[key] !== props[key]) {
                return false;
            }
        }
        return true;
    }
};
var _excluded$4 = [
    "text"
], _excluded2$3 = [
    "text"
];
function ownKeys$8(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread$8(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys$8(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys$8(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}
function _createForOfIteratorHelper$5(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = it.call(o);
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it["return"] != null) it["return"]();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray$5(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$5(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen);
}
function _arrayLikeToArray$5(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++){
        arr2[i] = arr[i];
    }
    return arr2;
}
var IS_EDITOR_CACHE = new WeakMap(); // eslint-disable-next-line no-redeclare
var Editor = {
    /**
   * Get the ancestor above a location in the document.
   */ above: function above(editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _options$voids = options.voids, voids = _options$voids === void 0 ? false : _options$voids, _options$mode = options.mode, mode = _options$mode === void 0 ? "lowest" : _options$mode, _options$at = options.at, at = _options$at === void 0 ? editor.selection : _options$at, match = options.match;
        if (!at) {
            return;
        }
        var path = Editor.path(editor, at);
        var reverse = mode === "lowest";
        var _iterator = _createForOfIteratorHelper$5(Editor.levels(editor, {
            at: path,
            voids: voids,
            match: match,
            reverse: reverse
        })), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var _step$value = _slicedToArray(_step.value, 2), n = _step$value[0], p = _step$value[1];
                if (Text.isText(n)) continue;
                if (Range.isRange(at)) {
                    if (Path.isAncestor(p, at.anchor.path) && Path.isAncestor(p, at.focus.path)) {
                        return [
                            n,
                            p
                        ];
                    }
                } else {
                    if (!Path.equals(path, p)) {
                        return [
                            n,
                            p
                        ];
                    }
                }
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
    },
    /**
   * Add a custom property to the leaf text nodes in the current selection.
   *
   * If the selection is currently collapsed, the marks will be added to the
   * `editor.marks` property instead, and applied when text is inserted next.
   */ addMark: function addMark(editor, key, value) {
        editor.addMark(key, value);
    },
    /**
   * Get the point after a location.
   */ after: function after(editor, at) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var anchor = Editor.point(editor, at, {
            edge: "end"
        });
        var focus = Editor.end(editor, []);
        var range = {
            anchor: anchor,
            focus: focus
        };
        var _options$distance = options.distance, distance = _options$distance === void 0 ? 1 : _options$distance;
        var d = 0;
        var target;
        var _iterator2 = _createForOfIteratorHelper$5(Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {
            at: range
        }))), _step2;
        try {
            for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                var p = _step2.value;
                if (d > distance) {
                    break;
                }
                if (d !== 0) {
                    target = p;
                }
                d++;
            }
        } catch (err) {
            _iterator2.e(err);
        } finally{
            _iterator2.f();
        }
        return target;
    },
    /**
   * Get the point before a location.
   */ before: function before(editor, at) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var anchor = Editor.start(editor, []);
        var focus = Editor.point(editor, at, {
            edge: "start"
        });
        var range = {
            anchor: anchor,
            focus: focus
        };
        var _options$distance2 = options.distance, distance = _options$distance2 === void 0 ? 1 : _options$distance2;
        var d = 0;
        var target;
        var _iterator3 = _createForOfIteratorHelper$5(Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {
            at: range,
            reverse: true
        }))), _step3;
        try {
            for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                var p = _step3.value;
                if (d > distance) {
                    break;
                }
                if (d !== 0) {
                    target = p;
                }
                d++;
            }
        } catch (err) {
            _iterator3.e(err);
        } finally{
            _iterator3.f();
        }
        return target;
    },
    /**
   * Delete content in the editor backward from the current selection.
   */ deleteBackward: function deleteBackward(editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _options$unit = options.unit, unit = _options$unit === void 0 ? "character" : _options$unit;
        editor.deleteBackward(unit);
    },
    /**
   * Delete content in the editor forward from the current selection.
   */ deleteForward: function deleteForward(editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _options$unit2 = options.unit, unit = _options$unit2 === void 0 ? "character" : _options$unit2;
        editor.deleteForward(unit);
    },
    /**
   * Delete the content in the current selection.
   */ deleteFragment: function deleteFragment(editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _options$direction = options.direction, direction = _options$direction === void 0 ? "forward" : _options$direction;
        editor.deleteFragment(direction);
    },
    /**
   * Get the start and end points of a location.
   */ edges: function edges(editor, at) {
        return [
            Editor.start(editor, at),
            Editor.end(editor, at)
        ];
    },
    /**
   * Get the end point of a location.
   */ end: function end(editor, at) {
        return Editor.point(editor, at, {
            edge: "end"
        });
    },
    /**
   * Get the first node at a location.
   */ first: function first(editor, at) {
        var path = Editor.path(editor, at, {
            edge: "start"
        });
        return Editor.node(editor, path);
    },
    /**
   * Get the fragment at a location.
   */ fragment: function fragment(editor, at) {
        var range = Editor.range(editor, at);
        var fragment = Node.fragment(editor, range);
        return fragment;
    },
    /**
   * Check if a node has block children.
   */ hasBlocks: function hasBlocks(editor, element) {
        return element.children.some(function(n) {
            return Element.isElement(n) && Editor.isBlock(editor, n);
        });
    },
    /**
   * Check if a node has inline and text children.
   */ hasInlines: function hasInlines(editor, element) {
        return element.children.some(function(n) {
            return Text.isText(n) || Editor.isInline(editor, n);
        });
    },
    /**
   * Check if a node has text children.
   */ hasTexts: function hasTexts(editor, element) {
        return element.children.every(function(n) {
            return Text.isText(n);
        });
    },
    /**
   * Insert a block break at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */ insertBreak: function insertBreak(editor) {
        editor.insertBreak();
    },
    /**
   * Insert a soft break at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */ insertSoftBreak: function insertSoftBreak(editor) {
        editor.insertSoftBreak();
    },
    /**
   * Insert a fragment at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */ insertFragment: function insertFragment(editor, fragment) {
        editor.insertFragment(fragment);
    },
    /**
   * Insert a node at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */ insertNode: function insertNode(editor, node) {
        editor.insertNode(node);
    },
    /**
   * Insert text at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */ insertText: function insertText(editor, text) {
        editor.insertText(text);
    },
    /**
   * Check if a value is a block `Element` object.
   */ isBlock: function isBlock(editor, value) {
        return !editor.isInline(value);
    },
    /**
   * Check if a value is an `Editor` object.
   */ isEditor: function isEditor(value) {
        var cachedIsEditor = IS_EDITOR_CACHE.get(value);
        if (cachedIsEditor !== undefined) {
            return cachedIsEditor;
        }
        if (!isPlainObject.isPlainObject(value)) {
            return false;
        }
        var isEditor = typeof value.addMark === "function" && typeof value.apply === "function" && typeof value.deleteBackward === "function" && typeof value.deleteForward === "function" && typeof value.deleteFragment === "function" && typeof value.insertBreak === "function" && typeof value.insertSoftBreak === "function" && typeof value.insertFragment === "function" && typeof value.insertNode === "function" && typeof value.insertText === "function" && typeof value.isInline === "function" && typeof value.isVoid === "function" && typeof value.normalizeNode === "function" && typeof value.onChange === "function" && typeof value.removeMark === "function" && typeof value.getDirtyPaths === "function" && (value.marks === null || isPlainObject.isPlainObject(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);
        IS_EDITOR_CACHE.set(value, isEditor);
        return isEditor;
    },
    /**
   * Check if a point is the end point of a location.
   */ isEnd: function isEnd(editor, point, at) {
        var end = Editor.end(editor, at);
        return Point.equals(point, end);
    },
    /**
   * Check if a point is an edge of a location.
   */ isEdge: function isEdge(editor, point, at) {
        return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);
    },
    /**
   * Check if an element is empty, accounting for void nodes.
   */ isEmpty: function isEmpty(editor, element) {
        var children = element.children;
        var _children = _slicedToArray(children, 1), first = _children[0];
        return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === "" && !editor.isVoid(element);
    },
    /**
   * Check if a value is an inline `Element` object.
   */ isInline: function isInline(editor, value) {
        return editor.isInline(value);
    },
    /**
   * Check if the editor is currently normalizing after each operation.
   */ isNormalizing: function isNormalizing(editor) {
        var isNormalizing = NORMALIZING.get(editor);
        return isNormalizing === undefined ? true : isNormalizing;
    },
    /**
   * Check if a point is the start point of a location.
   */ isStart: function isStart(editor, point, at) {
        // PERF: If the offset isn't `0` we know it's not the start.
        if (point.offset !== 0) {
            return false;
        }
        var start = Editor.start(editor, at);
        return Point.equals(point, start);
    },
    /**
   * Check if a value is a void `Element` object.
   */ isVoid: function isVoid(editor, value) {
        return editor.isVoid(value);
    },
    /**
   * Get the last node at a location.
   */ last: function last(editor, at) {
        var path = Editor.path(editor, at, {
            edge: "end"
        });
        return Editor.node(editor, path);
    },
    /**
   * Get the leaf text node at a location.
   */ leaf: function leaf(editor, at) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var path = Editor.path(editor, at, options);
        var node = Node.leaf(editor, path);
        return [
            node,
            path
        ];
    },
    /**
   * Iterate through all of the levels at a location.
   */ levels: function* levels(editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _options$at2 = options.at, at = _options$at2 === void 0 ? editor.selection : _options$at2, _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse, _options$voids2 = options.voids, voids = _options$voids2 === void 0 ? false : _options$voids2;
        var match = options.match;
        if (match == null) {
            match = function match() {
                return true;
            };
        }
        if (!at) {
            return;
        }
        var levels = [];
        var path = Editor.path(editor, at);
        var _iterator4 = _createForOfIteratorHelper$5(Node.levels(editor, path)), _step4;
        try {
            for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                var _step4$value = _slicedToArray(_step4.value, 2), n = _step4$value[0], p = _step4$value[1];
                if (!match(n, p)) {
                    continue;
                }
                levels.push([
                    n,
                    p
                ]);
                if (!voids && Element.isElement(n) && Editor.isVoid(editor, n)) {
                    break;
                }
            }
        } catch (err) {
            _iterator4.e(err);
        } finally{
            _iterator4.f();
        }
        if (reverse) {
            levels.reverse();
        }
        yield* levels;
    },
    /**
   * Get the marks that would be added to text at the current selection.
   */ marks: function marks(editor) {
        var marks = editor.marks, selection = editor.selection;
        if (!selection) {
            return null;
        }
        if (marks) {
            return marks;
        }
        if (Range.isExpanded(selection)) {
            var _Editor$nodes = Editor.nodes(editor, {
                match: Text.isText
            }), _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1), match = _Editor$nodes2[0];
            if (match) {
                var _match = _slicedToArray(match, 1), _node = _match[0];
                _node.text;
                var _rest = _objectWithoutProperties(_node, _excluded$4);
                return _rest;
            } else {
                return {};
            }
        }
        var anchor = selection.anchor;
        var path = anchor.path;
        var _Editor$leaf = Editor.leaf(editor, path), _Editor$leaf2 = _slicedToArray(_Editor$leaf, 1), node = _Editor$leaf2[0];
        if (anchor.offset === 0) {
            var prev = Editor.previous(editor, {
                at: path,
                match: Text.isText
            });
            var markedVoid = Editor.above(editor, {
                match: function match(n) {
                    return Element.isElement(n) && Editor.isVoid(editor, n) && editor.markableVoid(n);
                }
            });
            if (!markedVoid) {
                var block = Editor.above(editor, {
                    match: function match(n) {
                        return Element.isElement(n) && Editor.isBlock(editor, n);
                    }
                });
                if (prev && block) {
                    var _prev = _slicedToArray(prev, 2), prevNode = _prev[0], prevPath = _prev[1];
                    var _block = _slicedToArray(block, 2), blockPath = _block[1];
                    if (Path.isAncestor(blockPath, prevPath)) {
                        node = prevNode;
                    }
                }
            }
        }
        var _node2 = node;
        _node2.text;
        var rest = _objectWithoutProperties(_node2, _excluded2$3);
        return rest;
    },
    /**
   * Get the matching node in the branch of the document after a location.
   */ next: function next(editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _options$mode2 = options.mode, mode = _options$mode2 === void 0 ? "lowest" : _options$mode2, _options$voids3 = options.voids, voids = _options$voids3 === void 0 ? false : _options$voids3;
        var match = options.match, _options$at3 = options.at, at = _options$at3 === void 0 ? editor.selection : _options$at3;
        if (!at) {
            return;
        }
        var pointAfterLocation = Editor.after(editor, at, {
            voids: voids
        });
        if (!pointAfterLocation) return;
        var _Editor$last = Editor.last(editor, []), _Editor$last2 = _slicedToArray(_Editor$last, 2), to = _Editor$last2[1];
        var span = [
            pointAfterLocation.path,
            to
        ];
        if (Path.isPath(at) && at.length === 0) {
            throw new Error("Cannot get the next node from the root node!");
        }
        if (match == null) {
            if (Path.isPath(at)) {
                var _Editor$parent = Editor.parent(editor, at), _Editor$parent2 = _slicedToArray(_Editor$parent, 1), parent = _Editor$parent2[0];
                match = function match(n) {
                    return parent.children.includes(n);
                };
            } else {
                match = function match() {
                    return true;
                };
            }
        }
        var _Editor$nodes3 = Editor.nodes(editor, {
            at: span,
            match: match,
            mode: mode,
            voids: voids
        }), _Editor$nodes4 = _slicedToArray(_Editor$nodes3, 1), next = _Editor$nodes4[0];
        return next;
    },
    /**
   * Get the node at a location.
   */ node: function node(editor, at) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var path = Editor.path(editor, at, options);
        var node = Node.get(editor, path);
        return [
            node,
            path
        ];
    },
    /**
   * Iterate through all of the nodes in the Editor.
   */ nodes: function* nodes(editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _options$at4 = options.at, at = _options$at4 === void 0 ? editor.selection : _options$at4, _options$mode3 = options.mode, mode = _options$mode3 === void 0 ? "all" : _options$mode3, _options$universal = options.universal, universal = _options$universal === void 0 ? false : _options$universal, _options$reverse2 = options.reverse, reverse = _options$reverse2 === void 0 ? false : _options$reverse2, _options$voids4 = options.voids, voids = _options$voids4 === void 0 ? false : _options$voids4;
        var match = options.match;
        if (!match) {
            match = function match() {
                return true;
            };
        }
        if (!at) {
            return;
        }
        var from;
        var to;
        if (Span.isSpan(at)) {
            from = at[0];
            to = at[1];
        } else {
            var first = Editor.path(editor, at, {
                edge: "start"
            });
            var last = Editor.path(editor, at, {
                edge: "end"
            });
            from = reverse ? last : first;
            to = reverse ? first : last;
        }
        var nodeEntries = Node.nodes(editor, {
            reverse: reverse,
            from: from,
            to: to,
            pass: function pass(_ref) {
                var _ref2 = _slicedToArray(_ref, 1), n = _ref2[0];
                return voids ? false : Element.isElement(n) && Editor.isVoid(editor, n);
            }
        });
        var matches = [];
        var hit;
        var _iterator5 = _createForOfIteratorHelper$5(nodeEntries), _step5;
        try {
            for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){
                var _step5$value = _slicedToArray(_step5.value, 2), node = _step5$value[0], path = _step5$value[1];
                var isLower = hit && Path.compare(path, hit[1]) === 0; // In highest mode any node lower than the last hit is not a match.
                if (mode === "highest" && isLower) {
                    continue;
                }
                if (!match(node, path)) {
                    // If we've arrived at a leaf text node that is not lower than the last
                    // hit, then we've found a branch that doesn't include a match, which
                    // means the match is not universal.
                    if (universal && !isLower && Text.isText(node)) {
                        return;
                    } else {
                        continue;
                    }
                } // If there's a match and it's lower than the last, update the hit.
                if (mode === "lowest" && isLower) {
                    hit = [
                        node,
                        path
                    ];
                    continue;
                } // In lowest mode we emit the last hit, once it's guaranteed lowest.
                var emit = mode === "lowest" ? hit : [
                    node,
                    path
                ];
                if (emit) {
                    if (universal) {
                        matches.push(emit);
                    } else {
                        yield emit;
                    }
                }
                hit = [
                    node,
                    path
                ];
            } // Since lowest is always emitting one behind, catch up at the end.
        } catch (err) {
            _iterator5.e(err);
        } finally{
            _iterator5.f();
        }
        if (mode === "lowest" && hit) {
            if (universal) {
                matches.push(hit);
            } else {
                yield hit;
            }
        } // Universal defers to ensure that the match occurs in every branch, so we
        // yield all of the matches after iterating.
        if (universal) {
            yield* matches;
        }
    },
    /**
   * Normalize any dirty objects in the editor.
   */ normalize: function normalize(editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _options$force = options.force, force = _options$force === void 0 ? false : _options$force, operation = options.operation;
        var getDirtyPaths = function getDirtyPaths(editor) {
            return DIRTY_PATHS.get(editor) || [];
        };
        var getDirtyPathKeys = function getDirtyPathKeys(editor) {
            return DIRTY_PATH_KEYS.get(editor) || new Set();
        };
        var popDirtyPath = function popDirtyPath(editor) {
            var path = getDirtyPaths(editor).pop();
            var key = path.join(",");
            getDirtyPathKeys(editor)["delete"](key);
            return path;
        };
        if (!Editor.isNormalizing(editor)) {
            return;
        }
        if (force) {
            var allPaths = Array.from(Node.nodes(editor), function(_ref3) {
                var _ref4 = _slicedToArray(_ref3, 2), p = _ref4[1];
                return p;
            });
            var allPathKeys = new Set(allPaths.map(function(p) {
                return p.join(",");
            }));
            DIRTY_PATHS.set(editor, allPaths);
            DIRTY_PATH_KEYS.set(editor, allPathKeys);
        }
        if (getDirtyPaths(editor).length === 0) {
            return;
        }
        Editor.withoutNormalizing(editor, function() {
            /*
        Fix dirty elements with no children.
        editor.normalizeNode() does fix this, but some normalization fixes also require it to work.
        Running an initial pass avoids the catch-22 race condition.
      */ var _iterator6 = _createForOfIteratorHelper$5(getDirtyPaths(editor)), _step6;
            try {
                for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){
                    var _dirtyPath = _step6.value;
                    if (Node.has(editor, _dirtyPath)) {
                        var _entry = Editor.node(editor, _dirtyPath);
                        var _entry2 = _slicedToArray(_entry, 2), node = _entry2[0], _ = _entry2[1];
                        /*
              The default normalizer inserts an empty text node in this scenario, but it can be customised.
              So there is some risk here.
                         As long as the normalizer only inserts child nodes for this case it is safe to do in any order;
              by definition adding children to an empty node can't cause other paths to change.
            */ if (Element.isElement(node) && node.children.length === 0) {
                            editor.normalizeNode(_entry, {
                                operation: operation
                            });
                        }
                    }
                }
            } catch (err) {
                _iterator6.e(err);
            } finally{
                _iterator6.f();
            }
            var dirtyPaths = getDirtyPaths(editor);
            var initialDirtyPathsLength = dirtyPaths.length;
            var iteration = 0;
            while(dirtyPaths.length !== 0){
                if (!editor.shouldNormalize({
                    dirtyPaths: dirtyPaths,
                    iteration: iteration,
                    initialDirtyPathsLength: initialDirtyPathsLength,
                    operation: operation
                })) {
                    return;
                }
                var dirtyPath = popDirtyPath(editor); // If the node doesn't exist in the tree, it does not need to be normalized.
                if (Node.has(editor, dirtyPath)) {
                    var entry = Editor.node(editor, dirtyPath);
                    editor.normalizeNode(entry, {
                        operation: operation
                    });
                }
                iteration++;
                dirtyPaths = getDirtyPaths(editor);
            }
        });
    },
    /**
   * Get the parent node of a location.
   */ parent: function parent(editor, at) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var path = Editor.path(editor, at, options);
        var parentPath = Path.parent(path);
        var entry = Editor.node(editor, parentPath);
        return entry;
    },
    /**
   * Get the path of a location.
   */ path: function path(editor, at) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var depth = options.depth, edge = options.edge;
        if (Path.isPath(at)) {
            if (edge === "start") {
                var _Node$first = Node.first(editor, at), _Node$first2 = _slicedToArray(_Node$first, 2), firstPath = _Node$first2[1];
                at = firstPath;
            } else if (edge === "end") {
                var _Node$last = Node.last(editor, at), _Node$last2 = _slicedToArray(_Node$last, 2), lastPath = _Node$last2[1];
                at = lastPath;
            }
        }
        if (Range.isRange(at)) {
            if (edge === "start") {
                at = Range.start(at);
            } else if (edge === "end") {
                at = Range.end(at);
            } else {
                at = Path.common(at.anchor.path, at.focus.path);
            }
        }
        if (Point.isPoint(at)) {
            at = at.path;
        }
        if (depth != null) {
            at = at.slice(0, depth);
        }
        return at;
    },
    hasPath: function hasPath(editor, path) {
        return Node.has(editor, path);
    },
    /**
   * Create a mutable ref for a `Path` object, which will stay in sync as new
   * operations are applied to the editor.
   */ pathRef: function pathRef(editor, path) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var _options$affinity = options.affinity, affinity = _options$affinity === void 0 ? "forward" : _options$affinity;
        var ref = {
            current: path,
            affinity: affinity,
            unref: function unref() {
                var current = ref.current;
                var pathRefs = Editor.pathRefs(editor);
                pathRefs["delete"](ref);
                ref.current = null;
                return current;
            }
        };
        var refs = Editor.pathRefs(editor);
        refs.add(ref);
        return ref;
    },
    /**
   * Get the set of currently tracked path refs of the editor.
   */ pathRefs: function pathRefs(editor) {
        var refs = PATH_REFS.get(editor);
        if (!refs) {
            refs = new Set();
            PATH_REFS.set(editor, refs);
        }
        return refs;
    },
    /**
   * Get the start or end point of a location.
   */ point: function point(editor, at) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var _options$edge = options.edge, edge = _options$edge === void 0 ? "start" : _options$edge;
        if (Path.isPath(at)) {
            var path;
            if (edge === "end") {
                var _Node$last3 = Node.last(editor, at), _Node$last4 = _slicedToArray(_Node$last3, 2), lastPath = _Node$last4[1];
                path = lastPath;
            } else {
                var _Node$first3 = Node.first(editor, at), _Node$first4 = _slicedToArray(_Node$first3, 2), firstPath = _Node$first4[1];
                path = firstPath;
            }
            var node = Node.get(editor, path);
            if (!Text.isText(node)) {
                throw new Error("Cannot get the ".concat(edge, " point in the node at path [").concat(at, "] because it has no ").concat(edge, " text node."));
            }
            return {
                path: path,
                offset: edge === "end" ? node.text.length : 0
            };
        }
        if (Range.isRange(at)) {
            var _Range$edges = Range.edges(at), _Range$edges2 = _slicedToArray(_Range$edges, 2), start = _Range$edges2[0], end = _Range$edges2[1];
            return edge === "start" ? start : end;
        }
        return at;
    },
    /**
   * Create a mutable ref for a `Point` object, which will stay in sync as new
   * operations are applied to the editor.
   */ pointRef: function pointRef(editor, point) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var _options$affinity2 = options.affinity, affinity = _options$affinity2 === void 0 ? "forward" : _options$affinity2;
        var ref = {
            current: point,
            affinity: affinity,
            unref: function unref() {
                var current = ref.current;
                var pointRefs = Editor.pointRefs(editor);
                pointRefs["delete"](ref);
                ref.current = null;
                return current;
            }
        };
        var refs = Editor.pointRefs(editor);
        refs.add(ref);
        return ref;
    },
    /**
   * Get the set of currently tracked point refs of the editor.
   */ pointRefs: function pointRefs(editor) {
        var refs = POINT_REFS.get(editor);
        if (!refs) {
            refs = new Set();
            POINT_REFS.set(editor, refs);
        }
        return refs;
    },
    /**
   * Return all the positions in `at` range where a `Point` can be placed.
   *
   * By default, moves forward by individual offsets at a time, but
   * the `unit` option can be used to to move by character, word, line, or block.
   *
   * The `reverse` option can be used to change iteration direction.
   *
   * Note: By default void nodes are treated as a single point and iteration
   * will not happen inside their content unless you pass in true for the
   * `voids` option, then iteration will occur.
   */ positions: function* positions(editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _options$at5 = options.at, at = _options$at5 === void 0 ? editor.selection : _options$at5, _options$unit3 = options.unit, unit = _options$unit3 === void 0 ? "offset" : _options$unit3, _options$reverse3 = options.reverse, reverse = _options$reverse3 === void 0 ? false : _options$reverse3, _options$voids5 = options.voids, voids = _options$voids5 === void 0 ? false : _options$voids5;
        if (!at) {
            return;
        }
        /**
     * Algorithm notes:
     *
     * Each step `distance` is dynamic depending on the underlying text
     * and the `unit` specified.  Each step, e.g., a line or word, may
     * span multiple text nodes, so we iterate through the text both on
     * two levels in step-sync:
     *
     * `leafText` stores the text on a text leaf level, and is advanced
     * through using the counters `leafTextOffset` and `leafTextRemaining`.
     *
     * `blockText` stores the text on a block level, and is shortened
     * by `distance` every time it is advanced.
     *
     * We only maintain a window of one blockText and one leafText because
     * a block node always appears before all of its leaf nodes.
     */ var range = Editor.range(editor, at);
        var _Range$edges3 = Range.edges(range), _Range$edges4 = _slicedToArray(_Range$edges3, 2), start = _Range$edges4[0], end = _Range$edges4[1];
        var first = reverse ? end : start;
        var isNewBlock = false;
        var blockText = "";
        var distance = 0; // Distance for leafText to catch up to blockText.
        var leafTextRemaining = 0;
        var leafTextOffset = 0; // Iterate through all nodes in range, grabbing entire textual content
        // of block nodes in blockText, and text nodes in leafText.
        // Exploits the fact that nodes are sequenced in such a way that we first
        // encounter the block node, then all of its text nodes, so when iterating
        // through the blockText and leafText we just need to remember a window of
        // one block node and leaf node, respectively.
        var _iterator7 = _createForOfIteratorHelper$5(Editor.nodes(editor, {
            at: at,
            reverse: reverse,
            voids: voids
        })), _step7;
        try {
            for(_iterator7.s(); !(_step7 = _iterator7.n()).done;){
                var _step7$value = _slicedToArray(_step7.value, 2), node = _step7$value[0], path = _step7$value[1];
                /*
         * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks
         */ if (Element.isElement(node)) {
                    // Void nodes are a special case, so by default we will always
                    // yield their first point. If the `voids` option is set to true,
                    // then we will iterate over their content.
                    if (!voids && editor.isVoid(node)) {
                        yield Editor.start(editor, path);
                        continue;
                    } // Inline element nodes are ignored as they don't themselves
                    // contribute to `blockText` or `leafText` - their parent and
                    // children do.
                    if (editor.isInline(node)) continue; // Block element node - set `blockText` to its text content.
                    if (Editor.hasInlines(editor, node)) {
                        // We always exhaust block nodes before encountering a new one:
                        //   console.assert(blockText === '',
                        //     `blockText='${blockText}' - `+
                        //     `not exhausted before new block node`, path)
                        // Ensure range considered is capped to `range`, in the
                        // start/end edge cases where block extends beyond range.
                        // Equivalent to this, but presumably more performant:
                        //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))
                        //   blockRange = Range.intersection(range, blockRange) // intersect
                        //   blockText = Editor.string(editor, blockRange, { voids })
                        var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);
                        var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);
                        blockText = Editor.string(editor, {
                            anchor: s,
                            focus: e
                        }, {
                            voids: voids
                        });
                        isNewBlock = true;
                    }
                }
                /*
         * TEXT LEAF NODE - Iterate through text content, yielding
         * positions every `distance` offset according to `unit`.
         */ if (Text.isText(node)) {
                    var isFirst = Path.equals(path, first.path); // Proof that we always exhaust text nodes before encountering a new one:
                    //   console.assert(leafTextRemaining <= 0,
                    //     `leafTextRemaining=${leafTextRemaining} - `+
                    //     `not exhausted before new leaf text node`, path)
                    // Reset `leafText` counters for new text node.
                    if (isFirst) {
                        leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;
                        leafTextOffset = first.offset; // Works for reverse too.
                    } else {
                        leafTextRemaining = node.text.length;
                        leafTextOffset = reverse ? leafTextRemaining : 0;
                    } // Yield position at the start of node (potentially).
                    if (isFirst || isNewBlock || unit === "offset") {
                        yield {
                            path: path,
                            offset: leafTextOffset
                        };
                        isNewBlock = false;
                    } // Yield positions every (dynamically calculated) `distance` offset.
                    while(true){
                        // If `leafText` has caught up with `blockText` (distance=0),
                        // and if blockText is exhausted, break to get another block node,
                        // otherwise advance blockText forward by the new `distance`.
                        if (distance === 0) {
                            if (blockText === "") break;
                            distance = calcDistance(blockText, unit, reverse); // Split the string at the previously found distance and use the
                            // remaining string for the next iteration.
                            blockText = splitByCharacterDistance(blockText, distance, reverse)[1];
                        } // Advance `leafText` by the current `distance`.
                        leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;
                        leafTextRemaining = leafTextRemaining - distance; // If `leafText` is exhausted, break to get a new leaf node
                        // and set distance to the overflow amount, so we'll (maybe)
                        // catch up to blockText in the next leaf text node.
                        if (leafTextRemaining < 0) {
                            distance = -leafTextRemaining;
                            break;
                        } // Successfully walked `distance` offsets through `leafText`
                        // to catch up with `blockText`, so we can reset `distance`
                        // and yield this position in this node.
                        distance = 0;
                        yield {
                            path: path,
                            offset: leafTextOffset
                        };
                    }
                }
            } // Proof that upon completion, we've exahusted both leaf and block text:
        //   console.assert(leafTextRemaining <= 0, "leafText wasn't exhausted")
        //   console.assert(blockText === '', "blockText wasn't exhausted")
        // Helper:
        // Return the distance in offsets for a step of size `unit` on given string.
        } catch (err) {
            _iterator7.e(err);
        } finally{
            _iterator7.f();
        }
        function calcDistance(text, unit, reverse) {
            if (unit === "character") {
                return getCharacterDistance(text, reverse);
            } else if (unit === "word") {
                return getWordDistance(text, reverse);
            } else if (unit === "line" || unit === "block") {
                return text.length;
            }
            return 1;
        }
    },
    /**
   * Get the matching node in the branch of the document before a location.
   */ previous: function previous(editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _options$mode4 = options.mode, mode = _options$mode4 === void 0 ? "lowest" : _options$mode4, _options$voids6 = options.voids, voids = _options$voids6 === void 0 ? false : _options$voids6;
        var match = options.match, _options$at6 = options.at, at = _options$at6 === void 0 ? editor.selection : _options$at6;
        if (!at) {
            return;
        }
        var pointBeforeLocation = Editor.before(editor, at, {
            voids: voids
        });
        if (!pointBeforeLocation) {
            return;
        }
        var _Editor$first = Editor.first(editor, []), _Editor$first2 = _slicedToArray(_Editor$first, 2), to = _Editor$first2[1]; // The search location is from the start of the document to the path of
        // the point before the location passed in
        var span = [
            pointBeforeLocation.path,
            to
        ];
        if (Path.isPath(at) && at.length === 0) {
            throw new Error("Cannot get the previous node from the root node!");
        }
        if (match == null) {
            if (Path.isPath(at)) {
                var _Editor$parent3 = Editor.parent(editor, at), _Editor$parent4 = _slicedToArray(_Editor$parent3, 1), parent = _Editor$parent4[0];
                match = function match(n) {
                    return parent.children.includes(n);
                };
            } else {
                match = function match() {
                    return true;
                };
            }
        }
        var _Editor$nodes5 = Editor.nodes(editor, {
            reverse: true,
            at: span,
            match: match,
            mode: mode,
            voids: voids
        }), _Editor$nodes6 = _slicedToArray(_Editor$nodes5, 1), previous = _Editor$nodes6[0];
        return previous;
    },
    /**
   * Get a range of a location.
   */ range: function range(editor, at, to) {
        if (Range.isRange(at) && !to) {
            return at;
        }
        var start = Editor.start(editor, at);
        var end = Editor.end(editor, to || at);
        return {
            anchor: start,
            focus: end
        };
    },
    /**
   * Create a mutable ref for a `Range` object, which will stay in sync as new
   * operations are applied to the editor.
   */ rangeRef: function rangeRef(editor, range) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var _options$affinity3 = options.affinity, affinity = _options$affinity3 === void 0 ? "forward" : _options$affinity3;
        var ref = {
            current: range,
            affinity: affinity,
            unref: function unref() {
                var current = ref.current;
                var rangeRefs = Editor.rangeRefs(editor);
                rangeRefs["delete"](ref);
                ref.current = null;
                return current;
            }
        };
        var refs = Editor.rangeRefs(editor);
        refs.add(ref);
        return ref;
    },
    /**
   * Get the set of currently tracked range refs of the editor.
   */ rangeRefs: function rangeRefs(editor) {
        var refs = RANGE_REFS.get(editor);
        if (!refs) {
            refs = new Set();
            RANGE_REFS.set(editor, refs);
        }
        return refs;
    },
    /**
   * Remove a custom property from all of the leaf text nodes in the current
   * selection.
   *
   * If the selection is currently collapsed, the removal will be stored on
   * `editor.marks` and applied to the text inserted next.
   */ removeMark: function removeMark(editor, key) {
        editor.removeMark(key);
    },
    /**
   * Manually set if the editor should currently be normalizing.
   *
   * Note: Using this incorrectly can leave the editor in an invalid state.
   *
   */ setNormalizing: function setNormalizing(editor, isNormalizing) {
        NORMALIZING.set(editor, isNormalizing);
    },
    /**
   * Get the start point of a location.
   */ start: function start(editor, at) {
        return Editor.point(editor, at, {
            edge: "start"
        });
    },
    /**
   * Get the text string content of a location.
   *
   * Note: by default the text of void nodes is considered to be an empty
   * string, regardless of content, unless you pass in true for the voids option
   */ string: function string(editor, at) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var _options$voids7 = options.voids, voids = _options$voids7 === void 0 ? false : _options$voids7;
        var range = Editor.range(editor, at);
        var _Range$edges5 = Range.edges(range), _Range$edges6 = _slicedToArray(_Range$edges5, 2), start = _Range$edges6[0], end = _Range$edges6[1];
        var text = "";
        var _iterator8 = _createForOfIteratorHelper$5(Editor.nodes(editor, {
            at: range,
            match: Text.isText,
            voids: voids
        })), _step8;
        try {
            for(_iterator8.s(); !(_step8 = _iterator8.n()).done;){
                var _step8$value = _slicedToArray(_step8.value, 2), node = _step8$value[0], path = _step8$value[1];
                var t = node.text;
                if (Path.equals(path, end.path)) {
                    t = t.slice(0, end.offset);
                }
                if (Path.equals(path, start.path)) {
                    t = t.slice(start.offset);
                }
                text += t;
            }
        } catch (err) {
            _iterator8.e(err);
        } finally{
            _iterator8.f();
        }
        return text;
    },
    /**
   * Convert a range into a non-hanging one.
   */ unhangRange: function unhangRange(editor, range) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var _options$voids8 = options.voids, voids = _options$voids8 === void 0 ? false : _options$voids8;
        var _Range$edges7 = Range.edges(range), _Range$edges8 = _slicedToArray(_Range$edges7, 2), start = _Range$edges8[0], end = _Range$edges8[1]; // PERF: exit early if we can guarantee that the range isn't hanging.
        if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range) || Path.hasPrevious(end.path)) {
            return range;
        }
        var endBlock = Editor.above(editor, {
            at: end,
            match: function match(n) {
                return Element.isElement(n) && Editor.isBlock(editor, n);
            },
            voids: voids
        });
        var blockPath = endBlock ? endBlock[1] : [];
        var first = Editor.start(editor, start);
        var before = {
            anchor: first,
            focus: end
        };
        var skip = true;
        var _iterator9 = _createForOfIteratorHelper$5(Editor.nodes(editor, {
            at: before,
            match: Text.isText,
            reverse: true,
            voids: voids
        })), _step9;
        try {
            for(_iterator9.s(); !(_step9 = _iterator9.n()).done;){
                var _step9$value = _slicedToArray(_step9.value, 2), node = _step9$value[0], path = _step9$value[1];
                if (skip) {
                    skip = false;
                    continue;
                }
                if (node.text !== "" || Path.isBefore(path, blockPath)) {
                    end = {
                        path: path,
                        offset: node.text.length
                    };
                    break;
                }
            }
        } catch (err) {
            _iterator9.e(err);
        } finally{
            _iterator9.f();
        }
        return {
            anchor: start,
            focus: end
        };
    },
    /**
   * Match a void node in the current branch of the editor.
   */ "void": function _void(editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return Editor.above(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {
            match: function match(n) {
                return Element.isElement(n) && Editor.isVoid(editor, n);
            }
        }));
    },
    /**
   * Call a function, deferring normalization until after it completes.
   */ withoutNormalizing: function withoutNormalizing(editor, fn) {
        var value = Editor.isNormalizing(editor);
        Editor.setNormalizing(editor, false);
        try {
            fn();
        } finally{
            Editor.setNormalizing(editor, value);
        }
        Editor.normalize(editor);
    }
};
var Location = {
    /**
   * Check if a value implements the `Location` interface.
   */ isLocation: function isLocation(value) {
        return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);
    }
}; // eslint-disable-next-line no-redeclare
var Span = {
    /**
   * Check if a value implements the `Span` interface.
   */ isSpan: function isSpan(value) {
        return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);
    }
};
var _excluded$3 = [
    "children"
], _excluded2$2 = [
    "text"
];
function _createForOfIteratorHelper$4(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = it.call(o);
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it["return"] != null) it["return"]();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray$4(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$4(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);
}
function _arrayLikeToArray$4(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++){
        arr2[i] = arr[i];
    }
    return arr2;
}
var IS_NODE_LIST_CACHE = new WeakMap(); // eslint-disable-next-line no-redeclare
var Node = {
    /**
   * Get the node at a specific path, asserting that it's an ancestor node.
   */ ancestor: function ancestor(root, path) {
        var node = Node.get(root, path);
        if (Text.isText(node)) {
            throw new Error("Cannot get the ancestor node at path [".concat(path, "] because it refers to a text node instead: ").concat(Scrubber.stringify(node)));
        }
        return node;
    },
    /**
   * Return a generator of all the ancestor nodes above a specific path.
   *
   * By default the order is top-down, from highest to lowest ancestor in
   * the tree, but you can pass the `reverse: true` option to go bottom-up.
   */ ancestors: function* ancestors(root, path) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var _iterator = _createForOfIteratorHelper$4(Path.ancestors(path, options)), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var p = _step.value;
                var n = Node.ancestor(root, p);
                var entry = [
                    n,
                    p
                ];
                yield entry;
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
    },
    /**
   * Get the child of a node at a specific index.
   */ child: function child(root, index) {
        if (Text.isText(root)) {
            throw new Error("Cannot get the child of a text node: ".concat(Scrubber.stringify(root)));
        }
        var c = root.children[index];
        if (c == null) {
            throw new Error("Cannot get child at index `".concat(index, "` in node: ").concat(Scrubber.stringify(root)));
        }
        return c;
    },
    /**
   * Iterate over the children of a node at a specific path.
   */ children: function* children(root, path) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse;
        var ancestor = Node.ancestor(root, path);
        var children = ancestor.children;
        var index = reverse ? children.length - 1 : 0;
        while(reverse ? index >= 0 : index < children.length){
            var child = Node.child(ancestor, index);
            var childPath = path.concat(index);
            yield [
                child,
                childPath
            ];
            index = reverse ? index - 1 : index + 1;
        }
    },
    /**
   * Get an entry for the common ancesetor node of two paths.
   */ common: function common(root, path, another) {
        var p = Path.common(path, another);
        var n = Node.get(root, p);
        return [
            n,
            p
        ];
    },
    /**
   * Get the node at a specific path, asserting that it's a descendant node.
   */ descendant: function descendant(root, path) {
        var node = Node.get(root, path);
        if (Editor.isEditor(node)) {
            throw new Error("Cannot get the descendant node at path [".concat(path, "] because it refers to the root editor node instead: ").concat(Scrubber.stringify(node)));
        }
        return node;
    },
    /**
   * Return a generator of all the descendant node entries inside a root node.
   */ descendants: function* descendants(root) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _iterator2 = _createForOfIteratorHelper$4(Node.nodes(root, options)), _step2;
        try {
            for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                var _step2$value = _slicedToArray(_step2.value, 2), node = _step2$value[0], path = _step2$value[1];
                if (path.length !== 0) {
                    // NOTE: we have to coerce here because checking the path's length does
                    // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.
                    yield [
                        node,
                        path
                    ];
                }
            }
        } catch (err) {
            _iterator2.e(err);
        } finally{
            _iterator2.f();
        }
    },
    /**
   * Return a generator of all the element nodes inside a root node. Each iteration
   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the
   * root node is an element it will be included in the iteration as well.
   */ elements: function* elements(root) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _iterator3 = _createForOfIteratorHelper$4(Node.nodes(root, options)), _step3;
        try {
            for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                var _step3$value = _slicedToArray(_step3.value, 2), node = _step3$value[0], path = _step3$value[1];
                if (Element.isElement(node)) {
                    yield [
                        node,
                        path
                    ];
                }
            }
        } catch (err) {
            _iterator3.e(err);
        } finally{
            _iterator3.f();
        }
    },
    /**
   * Extract props from a Node.
   */ extractProps: function extractProps(node) {
        if (Element.isAncestor(node)) {
            node.children;
            var properties = _objectWithoutProperties(node, _excluded$3);
            return properties;
        } else {
            node.text;
            var _properties = _objectWithoutProperties(node, _excluded2$2);
            return _properties;
        }
    },
    /**
   * Get the first node entry in a root node from a path.
   */ first: function first(root, path) {
        var p = path.slice();
        var n = Node.get(root, p);
        while(n){
            if (Text.isText(n) || n.children.length === 0) {
                break;
            } else {
                n = n.children[0];
                p.push(0);
            }
        }
        return [
            n,
            p
        ];
    },
    /**
   * Get the sliced fragment represented by a range inside a root node.
   */ fragment: function fragment(root, range) {
        if (Text.isText(root)) {
            throw new Error("Cannot get a fragment starting from a root text node: ".concat(Scrubber.stringify(root)));
        }
        var newRoot = immer.produce({
            children: root.children
        }, function(r) {
            var _Range$edges = Range.edges(range), _Range$edges2 = _slicedToArray(_Range$edges, 2), start = _Range$edges2[0], end = _Range$edges2[1];
            var nodeEntries = Node.nodes(r, {
                reverse: true,
                pass: function pass(_ref) {
                    var _ref2 = _slicedToArray(_ref, 2), path = _ref2[1];
                    return !Range.includes(range, path);
                }
            });
            var _iterator4 = _createForOfIteratorHelper$4(nodeEntries), _step4;
            try {
                for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                    var _step4$value = _slicedToArray(_step4.value, 2), path = _step4$value[1];
                    if (!Range.includes(range, path)) {
                        var parent = Node.parent(r, path);
                        var index = path[path.length - 1];
                        parent.children.splice(index, 1);
                    }
                    if (Path.equals(path, end.path)) {
                        var leaf = Node.leaf(r, path);
                        leaf.text = leaf.text.slice(0, end.offset);
                    }
                    if (Path.equals(path, start.path)) {
                        var _leaf = Node.leaf(r, path);
                        _leaf.text = _leaf.text.slice(start.offset);
                    }
                }
            } catch (err) {
                _iterator4.e(err);
            } finally{
                _iterator4.f();
            }
            if (Editor.isEditor(r)) {
                r.selection = null;
            }
        });
        return newRoot.children;
    },
    /**
   * Get the descendant node referred to by a specific path. If the path is an
   * empty array, it refers to the root node itself.
   */ get: function get(root, path) {
        var node = root;
        for(var i = 0; i < path.length; i++){
            var p = path[i];
            if (Text.isText(node) || !node.children[p]) {
                throw new Error("Cannot find a descendant at path [".concat(path, "] in node: ").concat(Scrubber.stringify(root)));
            }
            node = node.children[p];
        }
        return node;
    },
    /**
   * Check if a descendant node exists at a specific path.
   */ has: function has(root, path) {
        var node = root;
        for(var i = 0; i < path.length; i++){
            var p = path[i];
            if (Text.isText(node) || !node.children[p]) {
                return false;
            }
            node = node.children[p];
        }
        return true;
    },
    /**
   * Check if a value implements the `Node` interface.
   */ isNode: function isNode(value) {
        return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);
    },
    /**
   * Check if a value is a list of `Node` objects.
   */ isNodeList: function isNodeList(value) {
        if (!Array.isArray(value)) {
            return false;
        }
        var cachedResult = IS_NODE_LIST_CACHE.get(value);
        if (cachedResult !== undefined) {
            return cachedResult;
        }
        var isNodeList = value.every(function(val) {
            return Node.isNode(val);
        });
        IS_NODE_LIST_CACHE.set(value, isNodeList);
        return isNodeList;
    },
    /**
   * Get the last node entry in a root node from a path.
   */ last: function last(root, path) {
        var p = path.slice();
        var n = Node.get(root, p);
        while(n){
            if (Text.isText(n) || n.children.length === 0) {
                break;
            } else {
                var i = n.children.length - 1;
                n = n.children[i];
                p.push(i);
            }
        }
        return [
            n,
            p
        ];
    },
    /**
   * Get the node at a specific path, ensuring it's a leaf text node.
   */ leaf: function leaf(root, path) {
        var node = Node.get(root, path);
        if (!Text.isText(node)) {
            throw new Error("Cannot get the leaf node at path [".concat(path, "] because it refers to a non-leaf node: ").concat(Scrubber.stringify(node)));
        }
        return node;
    },
    /**
   * Return a generator of the in a branch of the tree, from a specific path.
   *
   * By default the order is top-down, from highest to lowest node in the tree,
   * but you can pass the `reverse: true` option to go bottom-up.
   */ levels: function* levels(root, path) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var _iterator5 = _createForOfIteratorHelper$4(Path.levels(path, options)), _step5;
        try {
            for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){
                var p = _step5.value;
                var n = Node.get(root, p);
                yield [
                    n,
                    p
                ];
            }
        } catch (err) {
            _iterator5.e(err);
        } finally{
            _iterator5.f();
        }
    },
    /**
   * Check if a node matches a set of props.
   */ matches: function matches(node, props) {
        return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);
    },
    /**
   * Return a generator of all the node entries of a root node. Each entry is
   * returned as a `[Node, Path]` tuple, with the path referring to the node's
   * position inside the root node.
   */ nodes: function* nodes(root) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var pass = options.pass, _options$reverse2 = options.reverse, reverse = _options$reverse2 === void 0 ? false : _options$reverse2;
        var _options$from = options.from, from = _options$from === void 0 ? [] : _options$from, to = options.to;
        var visited = new Set();
        var p = [];
        var n = root;
        while(true){
            if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {
                break;
            }
            if (!visited.has(n)) {
                yield [
                    n,
                    p
                ];
            } // If we're allowed to go downward and we haven't descended yet, do.
            if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([
                n,
                p
            ]) === false)) {
                visited.add(n);
                var nextIndex = reverse ? n.children.length - 1 : 0;
                if (Path.isAncestor(p, from)) {
                    nextIndex = from[p.length];
                }
                p = p.concat(nextIndex);
                n = Node.get(root, p);
                continue;
            } // If we're at the root and we can't go down, we're done.
            if (p.length === 0) {
                break;
            } // If we're going forward...
            if (!reverse) {
                var newPath = Path.next(p);
                if (Node.has(root, newPath)) {
                    p = newPath;
                    n = Node.get(root, p);
                    continue;
                }
            } // If we're going backward...
            if (reverse && p[p.length - 1] !== 0) {
                var _newPath = Path.previous(p);
                p = _newPath;
                n = Node.get(root, p);
                continue;
            } // Otherwise we're going upward...
            p = Path.parent(p);
            n = Node.get(root, p);
            visited.add(n);
        }
    },
    /**
   * Get the parent of a node at a specific path.
   */ parent: function parent(root, path) {
        var parentPath = Path.parent(path);
        var p = Node.get(root, parentPath);
        if (Text.isText(p)) {
            throw new Error("Cannot get the parent of path [".concat(path, "] because it does not exist in the root."));
        }
        return p;
    },
    /**
   * Get the concatenated text string of a node's content.
   *
   * Note that this will not include spaces or line breaks between block nodes.
   * It is not a user-facing string, but a string for performing offset-related
   * computations for a node.
   */ string: function string(node) {
        if (Text.isText(node)) {
            return node.text;
        } else {
            return node.children.map(Node.string).join("");
        }
    },
    /**
   * Return a generator of all leaf text nodes in a root node.
   */ texts: function* texts(root) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _iterator6 = _createForOfIteratorHelper$4(Node.nodes(root, options)), _step6;
        try {
            for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){
                var _step6$value = _slicedToArray(_step6.value, 2), node = _step6$value[0], path = _step6$value[1];
                if (Text.isText(node)) {
                    yield [
                        node,
                        path
                    ];
                }
            }
        } catch (err) {
            _iterator6.e(err);
        } finally{
            _iterator6.f();
        }
    }
};
function ownKeys$7(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread$7(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys$7(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys$7(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}
var Operation = {
    /**
   * Check if a value is a `NodeOperation` object.
   */ isNodeOperation: function isNodeOperation(value) {
        return Operation.isOperation(value) && value.type.endsWith("_node");
    },
    /**
   * Check if a value is an `Operation` object.
   */ isOperation: function isOperation(value) {
        if (!isPlainObject.isPlainObject(value)) {
            return false;
        }
        switch(value.type){
            case "insert_node":
                return Path.isPath(value.path) && Node.isNode(value.node);
            case "insert_text":
                return typeof value.offset === "number" && typeof value.text === "string" && Path.isPath(value.path);
            case "merge_node":
                return typeof value.position === "number" && Path.isPath(value.path) && isPlainObject.isPlainObject(value.properties);
            case "move_node":
                return Path.isPath(value.path) && Path.isPath(value.newPath);
            case "remove_node":
                return Path.isPath(value.path) && Node.isNode(value.node);
            case "remove_text":
                return typeof value.offset === "number" && typeof value.text === "string" && Path.isPath(value.path);
            case "set_node":
                return Path.isPath(value.path) && isPlainObject.isPlainObject(value.properties) && isPlainObject.isPlainObject(value.newProperties);
            case "set_selection":
                return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isPlainObject.isPlainObject(value.properties) && isPlainObject.isPlainObject(value.newProperties);
            case "split_node":
                return Path.isPath(value.path) && typeof value.position === "number" && isPlainObject.isPlainObject(value.properties);
            default:
                return false;
        }
    },
    /**
   * Check if a value is a list of `Operation` objects.
   */ isOperationList: function isOperationList(value) {
        return Array.isArray(value) && value.every(function(val) {
            return Operation.isOperation(val);
        });
    },
    /**
   * Check if a value is a `SelectionOperation` object.
   */ isSelectionOperation: function isSelectionOperation(value) {
        return Operation.isOperation(value) && value.type.endsWith("_selection");
    },
    /**
   * Check if a value is a `TextOperation` object.
   */ isTextOperation: function isTextOperation(value) {
        return Operation.isOperation(value) && value.type.endsWith("_text");
    },
    /**
   * Invert an operation, returning a new operation that will exactly undo the
   * original when applied.
   */ inverse: function inverse(op) {
        switch(op.type){
            case "insert_node":
                {
                    return _objectSpread$7(_objectSpread$7({}, op), {}, {
                        type: "remove_node"
                    });
                }
            case "insert_text":
                {
                    return _objectSpread$7(_objectSpread$7({}, op), {}, {
                        type: "remove_text"
                    });
                }
            case "merge_node":
                {
                    return _objectSpread$7(_objectSpread$7({}, op), {}, {
                        type: "split_node",
                        path: Path.previous(op.path)
                    });
                }
            case "move_node":
                {
                    var newPath = op.newPath, path = op.path; // PERF: in this case the move operation is a no-op anyways.
                    if (Path.equals(newPath, path)) {
                        return op;
                    } // If the move happens completely within a single parent the path and
                    // newPath are stable with respect to each other.
                    if (Path.isSibling(path, newPath)) {
                        return _objectSpread$7(_objectSpread$7({}, op), {}, {
                            path: newPath,
                            newPath: path
                        });
                    } // If the move does not happen within a single parent it is possible
                    // for the move to impact the true path to the location where the node
                    // was removed from and where it was inserted. We have to adjust for this
                    // and find the original path. We can accomplish this (only in non-sibling)
                    // moves by looking at the impact of the move operation on the node
                    // after the original move path.
                    var inversePath = Path.transform(path, op);
                    var inverseNewPath = Path.transform(Path.next(path), op);
                    return _objectSpread$7(_objectSpread$7({}, op), {}, {
                        path: inversePath,
                        newPath: inverseNewPath
                    });
                }
            case "remove_node":
                {
                    return _objectSpread$7(_objectSpread$7({}, op), {}, {
                        type: "insert_node"
                    });
                }
            case "remove_text":
                {
                    return _objectSpread$7(_objectSpread$7({}, op), {}, {
                        type: "insert_text"
                    });
                }
            case "set_node":
                {
                    var properties = op.properties, newProperties = op.newProperties;
                    return _objectSpread$7(_objectSpread$7({}, op), {}, {
                        properties: newProperties,
                        newProperties: properties
                    });
                }
            case "set_selection":
                {
                    var _properties = op.properties, _newProperties = op.newProperties;
                    if (_properties == null) {
                        return _objectSpread$7(_objectSpread$7({}, op), {}, {
                            properties: _newProperties,
                            newProperties: null
                        });
                    } else if (_newProperties == null) {
                        return _objectSpread$7(_objectSpread$7({}, op), {}, {
                            properties: null,
                            newProperties: _properties
                        });
                    } else {
                        return _objectSpread$7(_objectSpread$7({}, op), {}, {
                            properties: _newProperties,
                            newProperties: _properties
                        });
                    }
                }
            case "split_node":
                {
                    return _objectSpread$7(_objectSpread$7({}, op), {}, {
                        type: "merge_node",
                        path: Path.next(op.path)
                    });
                }
        }
    }
};
// eslint-disable-next-line no-redeclare
var Path = {
    /**
   * Get a list of ancestor paths for a given path.
   *
   * The paths are sorted from shallowest to deepest ancestor. However, if the
   * `reverse: true` option is passed, they are reversed.
   */ ancestors: function ancestors(path) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse;
        var paths = Path.levels(path, options);
        if (reverse) {
            paths = paths.slice(1);
        } else {
            paths = paths.slice(0, -1);
        }
        return paths;
    },
    /**
   * Get the common ancestor path of two paths.
   */ common: function common(path, another) {
        var common = [];
        for(var i = 0; i < path.length && i < another.length; i++){
            var av = path[i];
            var bv = another[i];
            if (av !== bv) {
                break;
            }
            common.push(av);
        }
        return common;
    },
    /**
   * Compare a path to another, returning an integer indicating whether the path
   * was before, at, or after the other.
   *
   * Note: Two paths of unequal length can still receive a `0` result if one is
   * directly above or below the other. If you want exact matching, use
   * [[Path.equals]] instead.
   */ compare: function compare(path, another) {
        var min = Math.min(path.length, another.length);
        for(var i = 0; i < min; i++){
            if (path[i] < another[i]) return -1;
            if (path[i] > another[i]) return 1;
        }
        return 0;
    },
    /**
   * Check if a path ends after one of the indexes in another.
   */ endsAfter: function endsAfter(path, another) {
        var i = path.length - 1;
        var as = path.slice(0, i);
        var bs = another.slice(0, i);
        var av = path[i];
        var bv = another[i];
        return Path.equals(as, bs) && av > bv;
    },
    /**
   * Check if a path ends at one of the indexes in another.
   */ endsAt: function endsAt(path, another) {
        var i = path.length;
        var as = path.slice(0, i);
        var bs = another.slice(0, i);
        return Path.equals(as, bs);
    },
    /**
   * Check if a path ends before one of the indexes in another.
   */ endsBefore: function endsBefore(path, another) {
        var i = path.length - 1;
        var as = path.slice(0, i);
        var bs = another.slice(0, i);
        var av = path[i];
        var bv = another[i];
        return Path.equals(as, bs) && av < bv;
    },
    /**
   * Check if a path is exactly equal to another.
   */ equals: function equals(path, another) {
        return path.length === another.length && path.every(function(n, i) {
            return n === another[i];
        });
    },
    /**
   * Check if the path of previous sibling node exists
   */ hasPrevious: function hasPrevious(path) {
        return path[path.length - 1] > 0;
    },
    /**
   * Check if a path is after another.
   */ isAfter: function isAfter(path, another) {
        return Path.compare(path, another) === 1;
    },
    /**
   * Check if a path is an ancestor of another.
   */ isAncestor: function isAncestor(path, another) {
        return path.length < another.length && Path.compare(path, another) === 0;
    },
    /**
   * Check if a path is before another.
   */ isBefore: function isBefore(path, another) {
        return Path.compare(path, another) === -1;
    },
    /**
   * Check if a path is a child of another.
   */ isChild: function isChild(path, another) {
        return path.length === another.length + 1 && Path.compare(path, another) === 0;
    },
    /**
   * Check if a path is equal to or an ancestor of another.
   */ isCommon: function isCommon(path, another) {
        return path.length <= another.length && Path.compare(path, another) === 0;
    },
    /**
   * Check if a path is a descendant of another.
   */ isDescendant: function isDescendant(path, another) {
        return path.length > another.length && Path.compare(path, another) === 0;
    },
    /**
   * Check if a path is the parent of another.
   */ isParent: function isParent(path, another) {
        return path.length + 1 === another.length && Path.compare(path, another) === 0;
    },
    /**
   * Check is a value implements the `Path` interface.
   */ isPath: function isPath(value) {
        return Array.isArray(value) && (value.length === 0 || typeof value[0] === "number");
    },
    /**
   * Check if a path is a sibling of another.
   */ isSibling: function isSibling(path, another) {
        if (path.length !== another.length) {
            return false;
        }
        var as = path.slice(0, -1);
        var bs = another.slice(0, -1);
        var al = path[path.length - 1];
        var bl = another[another.length - 1];
        return al !== bl && Path.equals(as, bs);
    },
    /**
   * Get a list of paths at every level down to a path. Note: this is the same
   * as `Path.ancestors`, but including the path itself.
   *
   * The paths are sorted from shallowest to deepest. However, if the `reverse:
   * true` option is passed, they are reversed.
   */ levels: function levels(path) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _options$reverse2 = options.reverse, reverse = _options$reverse2 === void 0 ? false : _options$reverse2;
        var list = [];
        for(var i = 0; i <= path.length; i++){
            list.push(path.slice(0, i));
        }
        if (reverse) {
            list.reverse();
        }
        return list;
    },
    /**
   * Given a path, get the path to the next sibling node.
   */ next: function next(path) {
        if (path.length === 0) {
            throw new Error("Cannot get the next path of a root path [".concat(path, "], because it has no next index."));
        }
        var last = path[path.length - 1];
        return path.slice(0, -1).concat(last + 1);
    },
    /**
   * Returns whether this operation can affect paths or not. Used as an
   * optimization when updating dirty paths during normalization
   *
   * NOTE: This *must* be kept in sync with the implementation of 'transform'
   * below
   */ operationCanTransformPath: function operationCanTransformPath(operation) {
        switch(operation.type){
            case "insert_node":
            case "remove_node":
            case "merge_node":
            case "split_node":
            case "move_node":
                return true;
            default:
                return false;
        }
    },
    /**
   * Given a path, return a new path referring to the parent node above it.
   */ parent: function parent(path) {
        if (path.length === 0) {
            throw new Error("Cannot get the parent path of the root path [".concat(path, "]."));
        }
        return path.slice(0, -1);
    },
    /**
   * Given a path, get the path to the previous sibling node.
   */ previous: function previous(path) {
        if (path.length === 0) {
            throw new Error("Cannot get the previous path of a root path [".concat(path, "], because it has no previous index."));
        }
        var last = path[path.length - 1];
        if (last <= 0) {
            throw new Error("Cannot get the previous path of a first child path [".concat(path, "] because it would result in a negative index."));
        }
        return path.slice(0, -1).concat(last - 1);
    },
    /**
   * Get a path relative to an ancestor.
   */ relative: function relative(path, ancestor) {
        if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {
            throw new Error("Cannot get the relative path of [".concat(path, "] inside ancestor [").concat(ancestor, "], because it is not above or equal to the path."));
        }
        return path.slice(ancestor.length);
    },
    /**
   * Transform a path by an operation.
   */ transform: function transform(path, operation) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        if (!path) return null; // PERF: use destructing instead of immer
        var p = _toConsumableArray(path);
        var _options$affinity = options.affinity, affinity = _options$affinity === void 0 ? "forward" : _options$affinity; // PERF: Exit early if the operation is guaranteed not to have an effect.
        if (path.length === 0) {
            return p;
        }
        switch(operation.type){
            case "insert_node":
                {
                    var op = operation.path;
                    if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {
                        p[op.length - 1] += 1;
                    }
                    break;
                }
            case "remove_node":
                {
                    var _op = operation.path;
                    if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {
                        return null;
                    } else if (Path.endsBefore(_op, p)) {
                        p[_op.length - 1] -= 1;
                    }
                    break;
                }
            case "merge_node":
                {
                    var _op2 = operation.path, position = operation.position;
                    if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {
                        p[_op2.length - 1] -= 1;
                    } else if (Path.isAncestor(_op2, p)) {
                        p[_op2.length - 1] -= 1;
                        p[_op2.length] += position;
                    }
                    break;
                }
            case "split_node":
                {
                    var _op3 = operation.path, _position = operation.position;
                    if (Path.equals(_op3, p)) {
                        if (affinity === "forward") {
                            p[p.length - 1] += 1;
                        } else if (affinity === "backward") ;
                        else {
                            return null;
                        }
                    } else if (Path.endsBefore(_op3, p)) {
                        p[_op3.length - 1] += 1;
                    } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {
                        p[_op3.length - 1] += 1;
                        p[_op3.length] -= _position;
                    }
                    break;
                }
            case "move_node":
                {
                    var _op4 = operation.path, onp = operation.newPath; // If the old and new path are the same, it's a no-op.
                    if (Path.equals(_op4, onp)) {
                        return p;
                    }
                    if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {
                        var copy = onp.slice();
                        if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {
                            copy[_op4.length - 1] -= 1;
                        }
                        return copy.concat(p.slice(_op4.length));
                    } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {
                        if (Path.endsBefore(_op4, p)) {
                            p[_op4.length - 1] -= 1;
                        } else {
                            p[_op4.length - 1] += 1;
                        }
                    } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {
                        if (Path.endsBefore(_op4, p)) {
                            p[_op4.length - 1] -= 1;
                        }
                        p[onp.length - 1] += 1;
                    } else if (Path.endsBefore(_op4, p)) {
                        if (Path.equals(onp, p)) {
                            p[onp.length - 1] += 1;
                        }
                        p[_op4.length - 1] -= 1;
                    }
                    break;
                }
        }
        return p;
    }
};
var PathRef = {
    /**
   * Transform the path ref's current value by an operation.
   */ transform: function transform(ref, op) {
        var current = ref.current, affinity = ref.affinity;
        if (current == null) {
            return;
        }
        var path = Path.transform(current, op, {
            affinity: affinity
        });
        ref.current = path;
        if (path == null) {
            ref.unref();
        }
    }
};
function ownKeys$6(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread$6(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys$6(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys$6(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}
var Point = {
    /**
   * Compare a point to another, returning an integer indicating whether the
   * point was before, at, or after the other.
   */ compare: function compare(point, another) {
        var result = Path.compare(point.path, another.path);
        if (result === 0) {
            if (point.offset < another.offset) return -1;
            if (point.offset > another.offset) return 1;
            return 0;
        }
        return result;
    },
    /**
   * Check if a point is after another.
   */ isAfter: function isAfter(point, another) {
        return Point.compare(point, another) === 1;
    },
    /**
   * Check if a point is before another.
   */ isBefore: function isBefore(point, another) {
        return Point.compare(point, another) === -1;
    },
    /**
   * Check if a point is exactly equal to another.
   */ equals: function equals(point, another) {
        // PERF: ensure the offsets are equal first since they are cheaper to check.
        return point.offset === another.offset && Path.equals(point.path, another.path);
    },
    /**
   * Check if a value implements the `Point` interface.
   */ isPoint: function isPoint(value) {
        return isPlainObject.isPlainObject(value) && typeof value.offset === "number" && Path.isPath(value.path);
    },
    /**
   * Transform a point by an operation.
   */ transform: function transform(point, op) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return immer.produce(point, function(p) {
            if (p === null) {
                return null;
            }
            var _options$affinity = options.affinity, affinity = _options$affinity === void 0 ? "forward" : _options$affinity;
            var path = p.path, offset = p.offset;
            switch(op.type){
                case "insert_node":
                case "move_node":
                    {
                        p.path = Path.transform(path, op, options);
                        break;
                    }
                case "insert_text":
                    {
                        if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === "forward")) {
                            p.offset += op.text.length;
                        }
                        break;
                    }
                case "merge_node":
                    {
                        if (Path.equals(op.path, path)) {
                            p.offset += op.position;
                        }
                        p.path = Path.transform(path, op, options);
                        break;
                    }
                case "remove_text":
                    {
                        if (Path.equals(op.path, path) && op.offset <= offset) {
                            p.offset -= Math.min(offset - op.offset, op.text.length);
                        }
                        break;
                    }
                case "remove_node":
                    {
                        if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {
                            return null;
                        }
                        p.path = Path.transform(path, op, options);
                        break;
                    }
                case "split_node":
                    {
                        if (Path.equals(op.path, path)) {
                            if (op.position === offset && affinity == null) {
                                return null;
                            } else if (op.position < offset || op.position === offset && affinity === "forward") {
                                p.offset -= op.position;
                                p.path = Path.transform(path, op, _objectSpread$6(_objectSpread$6({}, options), {}, {
                                    affinity: "forward"
                                }));
                            }
                        } else {
                            p.path = Path.transform(path, op, options);
                        }
                        break;
                    }
            }
        });
    }
};
var PointRef = {
    /**
   * Transform the point ref's current value by an operation.
   */ transform: function transform(ref, op) {
        var current = ref.current, affinity = ref.affinity;
        if (current == null) {
            return;
        }
        var point = Point.transform(current, op, {
            affinity: affinity
        });
        ref.current = point;
        if (point == null) {
            ref.unref();
        }
    }
};
var _excluded$2 = [
    "anchor",
    "focus"
];
function ownKeys$5(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread$5(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys$5(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys$5(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}
var Range = {
    /**
   * Get the start and end points of a range, in the order in which they appear
   * in the document.
   */ edges: function edges(range) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse;
        var anchor = range.anchor, focus = range.focus;
        return Range.isBackward(range) === reverse ? [
            anchor,
            focus
        ] : [
            focus,
            anchor
        ];
    },
    /**
   * Get the end point of a range.
   */ end: function end(range) {
        var _Range$edges = Range.edges(range), _Range$edges2 = _slicedToArray(_Range$edges, 2), end = _Range$edges2[1];
        return end;
    },
    /**
   * Check if a range is exactly equal to another.
   */ equals: function equals(range, another) {
        return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);
    },
    /**
   * Check if a range includes a path, a point or part of another range.
   */ includes: function includes(range, target) {
        if (Range.isRange(target)) {
            if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {
                return true;
            }
            var _Range$edges3 = Range.edges(range), _Range$edges4 = _slicedToArray(_Range$edges3, 2), rs = _Range$edges4[0], re = _Range$edges4[1];
            var _Range$edges5 = Range.edges(target), _Range$edges6 = _slicedToArray(_Range$edges5, 2), ts = _Range$edges6[0], te = _Range$edges6[1];
            return Point.isBefore(rs, ts) && Point.isAfter(re, te);
        }
        var _Range$edges7 = Range.edges(range), _Range$edges8 = _slicedToArray(_Range$edges7, 2), start = _Range$edges8[0], end = _Range$edges8[1];
        var isAfterStart = false;
        var isBeforeEnd = false;
        if (Point.isPoint(target)) {
            isAfterStart = Point.compare(target, start) >= 0;
            isBeforeEnd = Point.compare(target, end) <= 0;
        } else {
            isAfterStart = Path.compare(target, start.path) >= 0;
            isBeforeEnd = Path.compare(target, end.path) <= 0;
        }
        return isAfterStart && isBeforeEnd;
    },
    /**
   * Get the intersection of a range with another.
   */ intersection: function intersection(range, another) {
        range.anchor;
        range.focus;
        var rest = _objectWithoutProperties(range, _excluded$2);
        var _Range$edges9 = Range.edges(range), _Range$edges10 = _slicedToArray(_Range$edges9, 2), s1 = _Range$edges10[0], e1 = _Range$edges10[1];
        var _Range$edges11 = Range.edges(another), _Range$edges12 = _slicedToArray(_Range$edges11, 2), s2 = _Range$edges12[0], e2 = _Range$edges12[1];
        var start = Point.isBefore(s1, s2) ? s2 : s1;
        var end = Point.isBefore(e1, e2) ? e1 : e2;
        if (Point.isBefore(end, start)) {
            return null;
        } else {
            return _objectSpread$5({
                anchor: start,
                focus: end
            }, rest);
        }
    },
    /**
   * Check if a range is backward, meaning that its anchor point appears in the
   * document _after_ its focus point.
   */ isBackward: function isBackward(range) {
        var anchor = range.anchor, focus = range.focus;
        return Point.isAfter(anchor, focus);
    },
    /**
   * Check if a range is collapsed, meaning that both its anchor and focus
   * points refer to the exact same position in the document.
   */ isCollapsed: function isCollapsed(range) {
        var anchor = range.anchor, focus = range.focus;
        return Point.equals(anchor, focus);
    },
    /**
   * Check if a range is expanded.
   *
   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.
   */ isExpanded: function isExpanded(range) {
        return !Range.isCollapsed(range);
    },
    /**
   * Check if a range is forward.
   *
   * This is the opposite of [[Range.isBackward]] and is provided for legibility.
   */ isForward: function isForward(range) {
        return !Range.isBackward(range);
    },
    /**
   * Check if a value implements the [[Range]] interface.
   */ isRange: function isRange(value) {
        return isPlainObject.isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);
    },
    /**
   * Iterate through all of the point entries in a range.
   */ points: function* points(range) {
        yield [
            range.anchor,
            "anchor"
        ];
        yield [
            range.focus,
            "focus"
        ];
    },
    /**
   * Get the start point of a range.
   */ start: function start(range) {
        var _Range$edges13 = Range.edges(range), _Range$edges14 = _slicedToArray(_Range$edges13, 1), start = _Range$edges14[0];
        return start;
    },
    /**
   * Transform a range by an operation.
   */ transform: function transform(range, op) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        return immer.produce(range, function(r) {
            if (r === null) {
                return null;
            }
            var _options$affinity = options.affinity, affinity = _options$affinity === void 0 ? "inward" : _options$affinity;
            var affinityAnchor;
            var affinityFocus;
            if (affinity === "inward") {
                // If the range is collapsed, make sure to use the same affinity to
                // avoid the two points passing each other and expanding in the opposite
                // direction
                var isCollapsed = Range.isCollapsed(r);
                if (Range.isForward(r)) {
                    affinityAnchor = "forward";
                    affinityFocus = isCollapsed ? affinityAnchor : "backward";
                } else {
                    affinityAnchor = "backward";
                    affinityFocus = isCollapsed ? affinityAnchor : "forward";
                }
            } else if (affinity === "outward") {
                if (Range.isForward(r)) {
                    affinityAnchor = "backward";
                    affinityFocus = "forward";
                } else {
                    affinityAnchor = "forward";
                    affinityFocus = "backward";
                }
            } else {
                affinityAnchor = affinity;
                affinityFocus = affinity;
            }
            var anchor = Point.transform(r.anchor, op, {
                affinity: affinityAnchor
            });
            var focus = Point.transform(r.focus, op, {
                affinity: affinityFocus
            });
            if (!anchor || !focus) {
                return null;
            }
            r.anchor = anchor;
            r.focus = focus;
        });
    }
};
var RangeRef = {
    /**
   * Transform the range ref's current value by an operation.
   */ transform: function transform(ref, op) {
        var current = ref.current, affinity = ref.affinity;
        if (current == null) {
            return;
        }
        var path = Range.transform(current, op, {
            affinity: affinity
        });
        ref.current = path;
        if (path == null) {
            ref.unref();
        }
    }
};
var _scrubber = undefined;
/**
 * This interface implements a stringify() function, which is used by Slate
 * internally when generating exceptions containing end user data. Developers
 * using Slate may call Scrubber.setScrubber() to alter the behavior of this
 * stringify() function.
 *
 * For example, to prevent the cleartext logging of 'text' fields within Nodes:
 *
 *    import { Scrubber } from 'slate';
 *    Scrubber.setScrubber((key, val) => {
 *      if (key === 'text') return '...scrubbed...'
 *      return val
 *    });
 *
 */ // eslint-disable-next-line no-redeclare
var Scrubber = {
    setScrubber: function setScrubber(scrubber) {
        _scrubber = scrubber;
    },
    stringify: function stringify(value) {
        return JSON.stringify(value, _scrubber);
    }
};
/*
  Custom deep equal comparison for Slate nodes.

  We don't need general purpose deep equality;
  Slate only supports plain values, Arrays, and nested objects.
  Complex values nested inside Arrays are not supported.

  Slate objects are designed to be serialised, so
  missing keys are deliberately normalised to undefined.
 */ var isDeepEqual = function isDeepEqual(node, another) {
    for(var key in node){
        var a = node[key];
        var b = another[key];
        if (isPlainObject.isPlainObject(a) && isPlainObject.isPlainObject(b)) {
            if (!isDeepEqual(a, b)) return false;
        } else if (Array.isArray(a) && Array.isArray(b)) {
            if (a.length !== b.length) return false;
            for(var i = 0; i < a.length; i++){
                if (a[i] !== b[i]) return false;
            }
        } else if (a !== b) {
            return false;
        }
    }
    /*
    Deep object equality is only necessary in one direction; in the reverse direction
    we are only looking for keys that are missing.
    As above, undefined keys are normalised to missing.
  */ for(var _key in another){
        if (node[_key] === undefined && another[_key] !== undefined) {
            return false;
        }
    }
    return true;
};
var _excluded$1 = [
    "text"
], _excluded2$1 = [
    "anchor",
    "focus"
];
function _createForOfIteratorHelper$3(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = it.call(o);
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it["return"] != null) it["return"]();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray$3(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$3(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);
}
function _arrayLikeToArray$3(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++){
        arr2[i] = arr[i];
    }
    return arr2;
}
function ownKeys$4(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread$4(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys$4(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys$4(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}
var Text = {
    /**
   * Check if two text nodes are equal.
   *
   * When loose is set, the text is not compared. This is
   * used to check whether sibling text nodes can be merged.
   */ equals: function equals(text, another) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var _options$loose = options.loose, loose = _options$loose === void 0 ? false : _options$loose;
        function omitText(obj) {
            obj.text;
            var rest = _objectWithoutProperties(obj, _excluded$1);
            return rest;
        }
        return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);
    },
    /**
   * Check if a value implements the `Text` interface.
   */ isText: function isText(value) {
        return isPlainObject.isPlainObject(value) && typeof value.text === "string";
    },
    /**
   * Check if a value is a list of `Text` objects.
   */ isTextList: function isTextList(value) {
        return Array.isArray(value) && value.every(function(val) {
            return Text.isText(val);
        });
    },
    /**
   * Check if some props are a partial of Text.
   */ isTextProps: function isTextProps(props) {
        return props.text !== undefined;
    },
    /**
   * Check if an text matches set of properties.
   *
   * Note: this is for matching custom properties, and it does not ensure that
   * the `text` property are two nodes equal.
   */ matches: function matches(text, props) {
        for(var key in props){
            if (key === "text") {
                continue;
            }
            if (!text.hasOwnProperty(key) || text[key] !== props[key]) {
                return false;
            }
        }
        return true;
    },
    /**
   * Get the leaves for a text node given decorations.
   */ decorations: function decorations(node, _decorations) {
        var leaves = [
            _objectSpread$4({}, node)
        ];
        var _iterator = _createForOfIteratorHelper$3(_decorations), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var dec = _step.value;
                var anchor = dec.anchor, focus = dec.focus, rest = _objectWithoutProperties(dec, _excluded2$1);
                var _Range$edges = Range.edges(dec), _Range$edges2 = _slicedToArray(_Range$edges, 2), start = _Range$edges2[0], end = _Range$edges2[1];
                var next = [];
                var leafEnd = 0;
                var decorationStart = start.offset;
                var decorationEnd = end.offset;
                var _iterator2 = _createForOfIteratorHelper$3(leaves), _step2;
                try {
                    for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                        var leaf = _step2.value;
                        var length = leaf.text.length;
                        var leafStart = leafEnd;
                        leafEnd += length; // If the range encompasses the entire leaf, add the range.
                        if (decorationStart <= leafStart && leafEnd <= decorationEnd) {
                            Object.assign(leaf, rest);
                            next.push(leaf);
                            continue;
                        } // If the range expanded and match the leaf, or starts after, or ends before it, continue.
                        if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {
                            next.push(leaf);
                            continue;
                        } // Otherwise we need to split the leaf, at the start, end, or both,
                        // and add the range to the middle intersecting section. Do the end
                        // split first since we don't need to update the offset that way.
                        var middle = leaf;
                        var before = void 0;
                        var after = void 0;
                        if (decorationEnd < leafEnd) {
                            var off = decorationEnd - leafStart;
                            after = _objectSpread$4(_objectSpread$4({}, middle), {}, {
                                text: middle.text.slice(off)
                            });
                            middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {
                                text: middle.text.slice(0, off)
                            });
                        }
                        if (decorationStart > leafStart) {
                            var _off = decorationStart - leafStart;
                            before = _objectSpread$4(_objectSpread$4({}, middle), {}, {
                                text: middle.text.slice(0, _off)
                            });
                            middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {
                                text: middle.text.slice(_off)
                            });
                        }
                        Object.assign(middle, rest);
                        if (before) {
                            next.push(before);
                        }
                        next.push(middle);
                        if (after) {
                            next.push(after);
                        }
                    }
                } catch (err) {
                    _iterator2.e(err);
                } finally{
                    _iterator2.f();
                }
                leaves = next;
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
        return leaves;
    }
};
function ownKeys$3(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread$3(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys$3(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys$3(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}
function _createForOfIteratorHelper$2(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = it.call(o);
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it["return"] != null) it["return"]();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray$2(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);
}
function _arrayLikeToArray$2(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++){
        arr2[i] = arr[i];
    }
    return arr2;
}
var applyToDraft = function applyToDraft(editor, selection, op) {
    switch(op.type){
        case "insert_node":
            {
                var path = op.path, node = op.node;
                var parent = Node.parent(editor, path);
                var index = path[path.length - 1];
                if (index > parent.children.length) {
                    throw new Error('Cannot apply an "insert_node" operation at path ['.concat(path, "] because the destination is past the end of the node."));
                }
                parent.children.splice(index, 0, node);
                if (selection) {
                    var _iterator = _createForOfIteratorHelper$2(Range.points(selection)), _step;
                    try {
                        for(_iterator.s(); !(_step = _iterator.n()).done;){
                            var _step$value = _slicedToArray(_step.value, 2), point = _step$value[0], key = _step$value[1];
                            selection[key] = Point.transform(point, op);
                        }
                    } catch (err) {
                        _iterator.e(err);
                    } finally{
                        _iterator.f();
                    }
                }
                break;
            }
        case "insert_text":
            {
                var _path = op.path, offset = op.offset, text = op.text;
                if (text.length === 0) break;
                var _node = Node.leaf(editor, _path);
                var before = _node.text.slice(0, offset);
                var after = _node.text.slice(offset);
                _node.text = before + text + after;
                if (selection) {
                    var _iterator2 = _createForOfIteratorHelper$2(Range.points(selection)), _step2;
                    try {
                        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                            var _step2$value = _slicedToArray(_step2.value, 2), _point = _step2$value[0], _key = _step2$value[1];
                            selection[_key] = Point.transform(_point, op);
                        }
                    } catch (err) {
                        _iterator2.e(err);
                    } finally{
                        _iterator2.f();
                    }
                }
                break;
            }
        case "merge_node":
            {
                var _path2 = op.path;
                var _node2 = Node.get(editor, _path2);
                var prevPath = Path.previous(_path2);
                var prev = Node.get(editor, prevPath);
                var _parent = Node.parent(editor, _path2);
                var _index = _path2[_path2.length - 1];
                if (Text.isText(_node2) && Text.isText(prev)) {
                    prev.text += _node2.text;
                } else if (!Text.isText(_node2) && !Text.isText(prev)) {
                    var _prev$children;
                    (_prev$children = prev.children).push.apply(_prev$children, _toConsumableArray(_node2.children));
                } else {
                    throw new Error('Cannot apply a "merge_node" operation at path ['.concat(_path2, "] to nodes of different interfaces: ").concat(Scrubber.stringify(_node2), " ").concat(Scrubber.stringify(prev)));
                }
                _parent.children.splice(_index, 1);
                if (selection) {
                    var _iterator3 = _createForOfIteratorHelper$2(Range.points(selection)), _step3;
                    try {
                        for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                            var _step3$value = _slicedToArray(_step3.value, 2), _point2 = _step3$value[0], _key2 = _step3$value[1];
                            selection[_key2] = Point.transform(_point2, op);
                        }
                    } catch (err) {
                        _iterator3.e(err);
                    } finally{
                        _iterator3.f();
                    }
                }
                break;
            }
        case "move_node":
            {
                var _path3 = op.path, newPath = op.newPath;
                if (Path.isAncestor(_path3, newPath)) {
                    throw new Error("Cannot move a path [".concat(_path3, "] to new path [").concat(newPath, "] because the destination is inside itself."));
                }
                var _node3 = Node.get(editor, _path3);
                var _parent2 = Node.parent(editor, _path3);
                var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to
                // the same snapshot in time, there's a mismatch. After either
                // removing the original position, the second step's path can be out
                // of date. So instead of using the `op.newPath` directly, we
                // transform `op.path` to ascertain what the `newPath` would be after
                // the operation was applied.
                _parent2.children.splice(_index2, 1);
                var truePath = Path.transform(_path3, op);
                var newParent = Node.get(editor, Path.parent(truePath));
                var newIndex = truePath[truePath.length - 1];
                newParent.children.splice(newIndex, 0, _node3);
                if (selection) {
                    var _iterator4 = _createForOfIteratorHelper$2(Range.points(selection)), _step4;
                    try {
                        for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                            var _step4$value = _slicedToArray(_step4.value, 2), _point3 = _step4$value[0], _key3 = _step4$value[1];
                            selection[_key3] = Point.transform(_point3, op);
                        }
                    } catch (err) {
                        _iterator4.e(err);
                    } finally{
                        _iterator4.f();
                    }
                }
                break;
            }
        case "remove_node":
            {
                var _path4 = op.path;
                var _index3 = _path4[_path4.length - 1];
                var _parent3 = Node.parent(editor, _path4);
                _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the
                // node that was removed we need to update the range or remove it.
                if (selection) {
                    var _iterator5 = _createForOfIteratorHelper$2(Range.points(selection)), _step5;
                    try {
                        for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){
                            var _step5$value = _slicedToArray(_step5.value, 2), _point4 = _step5$value[0], _key4 = _step5$value[1];
                            var result = Point.transform(_point4, op);
                            if (selection != null && result != null) {
                                selection[_key4] = result;
                            } else {
                                var _prev = void 0;
                                var next = void 0;
                                var _iterator6 = _createForOfIteratorHelper$2(Node.texts(editor)), _step6;
                                try {
                                    for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){
                                        var _step6$value = _slicedToArray(_step6.value, 2), n = _step6$value[0], p = _step6$value[1];
                                        if (Path.compare(p, _path4) === -1) {
                                            _prev = [
                                                n,
                                                p
                                            ];
                                        } else {
                                            next = [
                                                n,
                                                p
                                            ];
                                            break;
                                        }
                                    }
                                } catch (err) {
                                    _iterator6.e(err);
                                } finally{
                                    _iterator6.f();
                                }
                                var preferNext = false;
                                if (_prev && next) {
                                    if (Path.equals(next[1], _path4)) {
                                        preferNext = !Path.hasPrevious(next[1]);
                                    } else {
                                        preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;
                                    }
                                }
                                if (_prev && !preferNext) {
                                    _point4.path = _prev[1];
                                    _point4.offset = _prev[0].text.length;
                                } else if (next) {
                                    _point4.path = next[1];
                                    _point4.offset = 0;
                                } else {
                                    selection = null;
                                }
                            }
                        }
                    } catch (err) {
                        _iterator5.e(err);
                    } finally{
                        _iterator5.f();
                    }
                }
                break;
            }
        case "remove_text":
            {
                var _path5 = op.path, _offset = op.offset, _text = op.text;
                if (_text.length === 0) break;
                var _node4 = Node.leaf(editor, _path5);
                var _before = _node4.text.slice(0, _offset);
                var _after = _node4.text.slice(_offset + _text.length);
                _node4.text = _before + _after;
                if (selection) {
                    var _iterator7 = _createForOfIteratorHelper$2(Range.points(selection)), _step7;
                    try {
                        for(_iterator7.s(); !(_step7 = _iterator7.n()).done;){
                            var _step7$value = _slicedToArray(_step7.value, 2), _point5 = _step7$value[0], _key5 = _step7$value[1];
                            selection[_key5] = Point.transform(_point5, op);
                        }
                    } catch (err) {
                        _iterator7.e(err);
                    } finally{
                        _iterator7.f();
                    }
                }
                break;
            }
        case "set_node":
            {
                var _path6 = op.path, properties = op.properties, newProperties = op.newProperties;
                if (_path6.length === 0) {
                    throw new Error("Cannot set properties on the root node!");
                }
                var _node5 = Node.get(editor, _path6);
                for(var _key6 in newProperties){
                    if (_key6 === "children" || _key6 === "text") {
                        throw new Error('Cannot set the "'.concat(_key6, '" property of nodes!'));
                    }
                    var value = newProperties[_key6];
                    if (value == null) {
                        delete _node5[_key6];
                    } else {
                        _node5[_key6] = value;
                    }
                } // properties that were previously defined, but are now missing, must be deleted
                for(var _key7 in properties){
                    if (!newProperties.hasOwnProperty(_key7)) {
                        delete _node5[_key7];
                    }
                }
                break;
            }
        case "set_selection":
            {
                var _newProperties = op.newProperties;
                if (_newProperties == null) {
                    selection = _newProperties;
                } else {
                    if (selection == null) {
                        if (!Range.isRange(_newProperties)) {
                            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Scrubber.stringify(_newProperties), " when there is no current selection."));
                        }
                        selection = _objectSpread$3({}, _newProperties);
                    }
                    for(var _key8 in _newProperties){
                        var _value = _newProperties[_key8];
                        if (_value == null) {
                            if (_key8 === "anchor" || _key8 === "focus") {
                                throw new Error('Cannot remove the "'.concat(_key8, '" selection property'));
                            }
                            delete selection[_key8];
                        } else {
                            selection[_key8] = _value;
                        }
                    }
                }
                break;
            }
        case "split_node":
            {
                var _path7 = op.path, position = op.position, _properties = op.properties;
                if (_path7.length === 0) {
                    throw new Error('Cannot apply a "split_node" operation at path ['.concat(_path7, "] because the root node cannot be split."));
                }
                var _node6 = Node.get(editor, _path7);
                var _parent4 = Node.parent(editor, _path7);
                var _index4 = _path7[_path7.length - 1];
                var newNode;
                if (Text.isText(_node6)) {
                    var _before2 = _node6.text.slice(0, position);
                    var _after2 = _node6.text.slice(position);
                    _node6.text = _before2;
                    newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {
                        text: _after2
                    });
                } else {
                    var _before3 = _node6.children.slice(0, position);
                    var _after3 = _node6.children.slice(position);
                    _node6.children = _before3;
                    newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {
                        children: _after3
                    });
                }
                _parent4.children.splice(_index4 + 1, 0, newNode);
                if (selection) {
                    var _iterator8 = _createForOfIteratorHelper$2(Range.points(selection)), _step8;
                    try {
                        for(_iterator8.s(); !(_step8 = _iterator8.n()).done;){
                            var _step8$value = _slicedToArray(_step8.value, 2), _point6 = _step8$value[0], _key9 = _step8$value[1];
                            selection[_key9] = Point.transform(_point6, op);
                        }
                    } catch (err) {
                        _iterator8.e(err);
                    } finally{
                        _iterator8.f();
                    }
                }
                break;
            }
    }
    return selection;
}; // eslint-disable-next-line no-redeclare
var GeneralTransforms = {
    /**
   * Transform the editor by an operation.
   */ transform: function transform(editor, op) {
        editor.children = immer.createDraft(editor.children);
        var selection = editor.selection && immer.createDraft(editor.selection);
        try {
            selection = applyToDraft(editor, selection, op);
        } finally{
            editor.children = immer.finishDraft(editor.children);
            if (selection) {
                editor.selection = immer.isDraft(selection) ? immer.finishDraft(selection) : selection;
            } else {
                editor.selection = null;
            }
        }
    }
};
var _excluded = [
    "text"
], _excluded2 = [
    "children"
];
function ownKeys$2(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread$2(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys$2(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys$2(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}
function _createForOfIteratorHelper$1(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = it.call(o);
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it["return"] != null) it["return"]();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray$1(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++){
        arr2[i] = arr[i];
    }
    return arr2;
}
var NodeTransforms = {
    /**
   * Insert nodes at a specific location in the Editor.
   */ insertNodes: function insertNodes(editor, nodes) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        Editor.withoutNormalizing(editor, function() {
            var _options$hanging = options.hanging, hanging = _options$hanging === void 0 ? false : _options$hanging, _options$voids = options.voids, voids = _options$voids === void 0 ? false : _options$voids, _options$mode = options.mode, mode = _options$mode === void 0 ? "lowest" : _options$mode;
            var at = options.at, match = options.match, select = options.select;
            if (Node.isNode(nodes)) {
                nodes = [
                    nodes
                ];
            }
            if (nodes.length === 0) {
                return;
            }
            var _nodes = nodes, _nodes2 = _slicedToArray(_nodes, 1), node = _nodes2[0]; // By default, use the selection as the target location. But if there is
            // no selection, insert at the end of the document since that is such a
            // common use case when inserting from a non-selected state.
            if (!at) {
                if (editor.selection) {
                    at = editor.selection;
                } else if (editor.children.length > 0) {
                    at = Editor.end(editor, []);
                } else {
                    at = [
                        0
                    ];
                }
                select = true;
            }
            if (select == null) {
                select = false;
            }
            if (Range.isRange(at)) {
                if (!hanging) {
                    at = Editor.unhangRange(editor, at, {
                        voids: voids
                    });
                }
                if (Range.isCollapsed(at)) {
                    at = at.anchor;
                } else {
                    var _Range$edges = Range.edges(at), _Range$edges2 = _slicedToArray(_Range$edges, 2), end = _Range$edges2[1];
                    var pointRef = Editor.pointRef(editor, end);
                    Transforms["delete"](editor, {
                        at: at
                    });
                    at = pointRef.unref();
                }
            }
            if (Point.isPoint(at)) {
                if (match == null) {
                    if (Text.isText(node)) {
                        match = function match(n) {
                            return Text.isText(n);
                        };
                    } else if (editor.isInline(node)) {
                        match = function match(n) {
                            return Text.isText(n) || Editor.isInline(editor, n);
                        };
                    } else {
                        match = function match(n) {
                            return Element.isElement(n) && Editor.isBlock(editor, n);
                        };
                    }
                }
                var _Editor$nodes = Editor.nodes(editor, {
                    at: at.path,
                    match: match,
                    mode: mode,
                    voids: voids
                }), _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1), entry = _Editor$nodes2[0];
                if (entry) {
                    var _entry = _slicedToArray(entry, 2), _matchPath = _entry[1];
                    var pathRef = Editor.pathRef(editor, _matchPath);
                    var isAtEnd = Editor.isEnd(editor, at, _matchPath);
                    Transforms.splitNodes(editor, {
                        at: at,
                        match: match,
                        mode: mode,
                        voids: voids
                    });
                    var path = pathRef.unref();
                    at = isAtEnd ? Path.next(path) : path;
                } else {
                    return;
                }
            }
            var parentPath = Path.parent(at);
            var index = at[at.length - 1];
            if (!voids && Editor["void"](editor, {
                at: parentPath
            })) {
                return;
            }
            var _iterator = _createForOfIteratorHelper$1(nodes), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var _node = _step.value;
                    var _path = parentPath.concat(index);
                    index++;
                    editor.apply({
                        type: "insert_node",
                        path: _path,
                        node: _node
                    });
                    at = Path.next(at);
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            at = Path.previous(at);
            if (select) {
                var point = Editor.end(editor, at);
                if (point) {
                    Transforms.select(editor, point);
                }
            }
        });
    },
    /**
   * Lift nodes at a specific location upwards in the document tree, splitting
   * their parent in two if necessary.
   */ liftNodes: function liftNodes(editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        Editor.withoutNormalizing(editor, function() {
            var _options$at = options.at, at = _options$at === void 0 ? editor.selection : _options$at, _options$mode2 = options.mode, mode = _options$mode2 === void 0 ? "lowest" : _options$mode2, _options$voids2 = options.voids, voids = _options$voids2 === void 0 ? false : _options$voids2;
            var match = options.match;
            if (match == null) {
                match = Path.isPath(at) ? matchPath(editor, at) : function(n) {
                    return Element.isElement(n) && Editor.isBlock(editor, n);
                };
            }
            if (!at) {
                return;
            }
            var matches = Editor.nodes(editor, {
                at: at,
                match: match,
                mode: mode,
                voids: voids
            });
            var pathRefs = Array.from(matches, function(_ref) {
                var _ref2 = _slicedToArray(_ref, 2), p = _ref2[1];
                return Editor.pathRef(editor, p);
            });
            for(var _i = 0, _pathRefs = pathRefs; _i < _pathRefs.length; _i++){
                var pathRef = _pathRefs[_i];
                var path = pathRef.unref();
                if (path.length < 2) {
                    throw new Error("Cannot lift node at a path [".concat(path, "] because it has a depth of less than `2`."));
                }
                var parentNodeEntry = Editor.node(editor, Path.parent(path));
                var _parentNodeEntry = _slicedToArray(parentNodeEntry, 2), parent = _parentNodeEntry[0], parentPath = _parentNodeEntry[1];
                var index = path[path.length - 1];
                var length = parent.children.length;
                if (length === 1) {
                    var toPath = Path.next(parentPath);
                    Transforms.moveNodes(editor, {
                        at: path,
                        to: toPath,
                        voids: voids
                    });
                    Transforms.removeNodes(editor, {
                        at: parentPath,
                        voids: voids
                    });
                } else if (index === 0) {
                    Transforms.moveNodes(editor, {
                        at: path,
                        to: parentPath,
                        voids: voids
                    });
                } else if (index === length - 1) {
                    var _toPath = Path.next(parentPath);
                    Transforms.moveNodes(editor, {
                        at: path,
                        to: _toPath,
                        voids: voids
                    });
                } else {
                    var splitPath = Path.next(path);
                    var _toPath2 = Path.next(parentPath);
                    Transforms.splitNodes(editor, {
                        at: splitPath,
                        voids: voids
                    });
                    Transforms.moveNodes(editor, {
                        at: path,
                        to: _toPath2,
                        voids: voids
                    });
                }
            }
        });
    },
    /**
   * Merge a node at a location with the previous node of the same depth,
   * removing any empty containing nodes after the merge if necessary.
   */ mergeNodes: function mergeNodes(editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        Editor.withoutNormalizing(editor, function() {
            var match = options.match, _options$at2 = options.at, at = _options$at2 === void 0 ? editor.selection : _options$at2;
            var _options$hanging2 = options.hanging, hanging = _options$hanging2 === void 0 ? false : _options$hanging2, _options$voids3 = options.voids, voids = _options$voids3 === void 0 ? false : _options$voids3, _options$mode3 = options.mode, mode = _options$mode3 === void 0 ? "lowest" : _options$mode3;
            if (!at) {
                return;
            }
            if (match == null) {
                if (Path.isPath(at)) {
                    var _Editor$parent = Editor.parent(editor, at), _Editor$parent2 = _slicedToArray(_Editor$parent, 1), parent = _Editor$parent2[0];
                    match = function match(n) {
                        return parent.children.includes(n);
                    };
                } else {
                    match = function match(n) {
                        return Element.isElement(n) && Editor.isBlock(editor, n);
                    };
                }
            }
            if (!hanging && Range.isRange(at)) {
                at = Editor.unhangRange(editor, at, {
                    voids: voids
                });
            }
            if (Range.isRange(at)) {
                if (Range.isCollapsed(at)) {
                    at = at.anchor;
                } else {
                    var _Range$edges3 = Range.edges(at), _Range$edges4 = _slicedToArray(_Range$edges3, 2), end = _Range$edges4[1];
                    var pointRef = Editor.pointRef(editor, end);
                    Transforms["delete"](editor, {
                        at: at
                    });
                    at = pointRef.unref();
                    if (options.at == null) {
                        Transforms.select(editor, at);
                    }
                }
            }
            var _Editor$nodes3 = Editor.nodes(editor, {
                at: at,
                match: match,
                voids: voids,
                mode: mode
            }), _Editor$nodes4 = _slicedToArray(_Editor$nodes3, 1), current = _Editor$nodes4[0];
            var prev = Editor.previous(editor, {
                at: at,
                match: match,
                voids: voids,
                mode: mode
            });
            if (!current || !prev) {
                return;
            }
            var _current = _slicedToArray(current, 2), node = _current[0], path = _current[1];
            var _prev = _slicedToArray(prev, 2), prevNode = _prev[0], prevPath = _prev[1];
            if (path.length === 0 || prevPath.length === 0) {
                return;
            }
            var newPath = Path.next(prevPath);
            var commonPath = Path.common(path, prevPath);
            var isPreviousSibling = Path.isSibling(path, prevPath);
            var levels = Array.from(Editor.levels(editor, {
                at: path
            }), function(_ref3) {
                var _ref4 = _slicedToArray(_ref3, 1), n = _ref4[0];
                return n;
            }).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a
            // result, in which case we'll want to remove it after merging.
            var emptyAncestor = Editor.above(editor, {
                at: path,
                mode: "highest",
                match: function match(n) {
                    return levels.includes(n) && hasSingleChildNest(editor, n);
                }
            });
            var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);
            var properties;
            var position; // Ensure that the nodes are equivalent, and figure out what the position
            // and extra properties of the merge will be.
            if (Text.isText(node) && Text.isText(prevNode)) {
                node.text;
                var rest = _objectWithoutProperties(node, _excluded);
                position = prevNode.text.length;
                properties = rest;
            } else if (Element.isElement(node) && Element.isElement(prevNode)) {
                node.children;
                var _rest = _objectWithoutProperties(node, _excluded2);
                position = prevNode.children.length;
                properties = _rest;
            } else {
                throw new Error("Cannot merge the node at path [".concat(path, "] with the previous sibling because it is not the same kind: ").concat(Scrubber.stringify(node), " ").concat(Scrubber.stringify(prevNode)));
            } // If the node isn't already the next sibling of the previous node, move
            // it so that it is before merging.
            if (!isPreviousSibling) {
                Transforms.moveNodes(editor, {
                    at: path,
                    to: newPath,
                    voids: voids
                });
            } // If there was going to be an empty ancestor of the node that was merged,
            // we remove it from the tree.
            if (emptyRef) {
                Transforms.removeNodes(editor, {
                    at: emptyRef.current,
                    voids: voids
                });
            } // If the target node that we're merging with is empty, remove it instead
            // of merging the two. This is a common rich text editor behavior to
            // prevent losing formatting when deleting entire nodes when you have a
            // hanging selection.
            // if prevNode is first child in parent,don't remove it.
            if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === "" && prevPath[prevPath.length - 1] !== 0) {
                Transforms.removeNodes(editor, {
                    at: prevPath,
                    voids: voids
                });
            } else {
                editor.apply({
                    type: "merge_node",
                    path: newPath,
                    position: position,
                    properties: properties
                });
            }
            if (emptyRef) {
                emptyRef.unref();
            }
        });
    },
    /**
   * Move the nodes at a location to a new location.
   */ moveNodes: function moveNodes(editor, options) {
        Editor.withoutNormalizing(editor, function() {
            var to = options.to, _options$at3 = options.at, at = _options$at3 === void 0 ? editor.selection : _options$at3, _options$mode4 = options.mode, mode = _options$mode4 === void 0 ? "lowest" : _options$mode4, _options$voids4 = options.voids, voids = _options$voids4 === void 0 ? false : _options$voids4;
            var match = options.match;
            if (!at) {
                return;
            }
            if (match == null) {
                match = Path.isPath(at) ? matchPath(editor, at) : function(n) {
                    return Element.isElement(n) && Editor.isBlock(editor, n);
                };
            }
            var toRef = Editor.pathRef(editor, to);
            var targets = Editor.nodes(editor, {
                at: at,
                match: match,
                mode: mode,
                voids: voids
            });
            var pathRefs = Array.from(targets, function(_ref5) {
                var _ref6 = _slicedToArray(_ref5, 2), p = _ref6[1];
                return Editor.pathRef(editor, p);
            });
            for(var _i2 = 0, _pathRefs2 = pathRefs; _i2 < _pathRefs2.length; _i2++){
                var pathRef = _pathRefs2[_i2];
                var path = pathRef.unref();
                var newPath = toRef.current;
                if (path.length !== 0) {
                    editor.apply({
                        type: "move_node",
                        path: path,
                        newPath: newPath
                    });
                }
                if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {
                    // When performing a sibling move to a later index, the path at the destination is shifted
                    // to before the insertion point instead of after. To ensure our group of nodes are inserted
                    // in the correct order we increment toRef to account for that
                    toRef.current = Path.next(toRef.current);
                }
            }
            toRef.unref();
        });
    },
    /**
   * Remove the nodes at a specific location in the document.
   */ removeNodes: function removeNodes(editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        Editor.withoutNormalizing(editor, function() {
            var _options$hanging3 = options.hanging, hanging = _options$hanging3 === void 0 ? false : _options$hanging3, _options$voids5 = options.voids, voids = _options$voids5 === void 0 ? false : _options$voids5, _options$mode5 = options.mode, mode = _options$mode5 === void 0 ? "lowest" : _options$mode5;
            var _options$at4 = options.at, at = _options$at4 === void 0 ? editor.selection : _options$at4, match = options.match;
            if (!at) {
                return;
            }
            if (match == null) {
                match = Path.isPath(at) ? matchPath(editor, at) : function(n) {
                    return Element.isElement(n) && Editor.isBlock(editor, n);
                };
            }
            if (!hanging && Range.isRange(at)) {
                at = Editor.unhangRange(editor, at, {
                    voids: voids
                });
            }
            var depths = Editor.nodes(editor, {
                at: at,
                match: match,
                mode: mode,
                voids: voids
            });
            var pathRefs = Array.from(depths, function(_ref7) {
                var _ref8 = _slicedToArray(_ref7, 2), p = _ref8[1];
                return Editor.pathRef(editor, p);
            });
            for(var _i3 = 0, _pathRefs3 = pathRefs; _i3 < _pathRefs3.length; _i3++){
                var pathRef = _pathRefs3[_i3];
                var path = pathRef.unref();
                if (path) {
                    var _Editor$node = Editor.node(editor, path), _Editor$node2 = _slicedToArray(_Editor$node, 1), node = _Editor$node2[0];
                    editor.apply({
                        type: "remove_node",
                        path: path,
                        node: node
                    });
                }
            }
        });
    },
    /**
   * Set new properties on the nodes at a location.
   */ setNodes: function setNodes(editor, props) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        Editor.withoutNormalizing(editor, function() {
            var match = options.match, _options$at5 = options.at, at = _options$at5 === void 0 ? editor.selection : _options$at5, compare = options.compare, merge = options.merge;
            var _options$hanging4 = options.hanging, hanging = _options$hanging4 === void 0 ? false : _options$hanging4, _options$mode6 = options.mode, mode = _options$mode6 === void 0 ? "lowest" : _options$mode6, _options$split = options.split, split = _options$split === void 0 ? false : _options$split, _options$voids6 = options.voids, voids = _options$voids6 === void 0 ? false : _options$voids6;
            if (!at) {
                return;
            }
            if (match == null) {
                match = Path.isPath(at) ? matchPath(editor, at) : function(n) {
                    return Element.isElement(n) && Editor.isBlock(editor, n);
                };
            }
            if (!hanging && Range.isRange(at)) {
                at = Editor.unhangRange(editor, at, {
                    voids: voids
                });
            }
            if (split && Range.isRange(at)) {
                if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {
                    // If the range is collapsed in a non-empty node and 'split' is true, there's nothing to
                    // set that won't get normalized away
                    return;
                }
                var rangeRef = Editor.rangeRef(editor, at, {
                    affinity: "inward"
                });
                var _Range$edges5 = Range.edges(at), _Range$edges6 = _slicedToArray(_Range$edges5, 2), start = _Range$edges6[0], end = _Range$edges6[1];
                var splitMode = mode === "lowest" ? "lowest" : "highest";
                var endAtEndOfNode = Editor.isEnd(editor, end, end.path);
                Transforms.splitNodes(editor, {
                    at: end,
                    match: match,
                    mode: splitMode,
                    voids: voids,
                    always: !endAtEndOfNode
                });
                var startAtStartOfNode = Editor.isStart(editor, start, start.path);
                Transforms.splitNodes(editor, {
                    at: start,
                    match: match,
                    mode: splitMode,
                    voids: voids,
                    always: !startAtStartOfNode
                });
                at = rangeRef.unref();
                if (options.at == null) {
                    Transforms.select(editor, at);
                }
            }
            if (!compare) {
                compare = function compare(prop, nodeProp) {
                    return prop !== nodeProp;
                };
            }
            var _iterator2 = _createForOfIteratorHelper$1(Editor.nodes(editor, {
                at: at,
                match: match,
                mode: mode,
                voids: voids
            })), _step2;
            try {
                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                    var _step2$value = _slicedToArray(_step2.value, 2), node = _step2$value[0], path = _step2$value[1];
                    var properties = {};
                    var newProperties = {}; // You can't set properties on the editor node.
                    if (path.length === 0) {
                        continue;
                    }
                    var hasChanges = false;
                    for(var k in props){
                        if (k === "children" || k === "text") {
                            continue;
                        }
                        if (compare(props[k], node[k])) {
                            hasChanges = true; // Omit new properties from the old properties list
                            if (node.hasOwnProperty(k)) properties[k] = node[k]; // Omit properties that have been removed from the new properties list
                            if (merge) {
                                if (props[k] != null) newProperties[k] = merge(node[k], props[k]);
                            } else {
                                if (props[k] != null) newProperties[k] = props[k];
                            }
                        }
                    }
                    if (hasChanges) {
                        editor.apply({
                            type: "set_node",
                            path: path,
                            properties: properties,
                            newProperties: newProperties
                        });
                    }
                }
            } catch (err) {
                _iterator2.e(err);
            } finally{
                _iterator2.f();
            }
        });
    },
    /**
   * Split the nodes at a specific location.
   */ splitNodes: function splitNodes(editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        Editor.withoutNormalizing(editor, function() {
            var _options$mode7 = options.mode, mode = _options$mode7 === void 0 ? "lowest" : _options$mode7, _options$voids7 = options.voids, voids = _options$voids7 === void 0 ? false : _options$voids7;
            var match = options.match, _options$at6 = options.at, at = _options$at6 === void 0 ? editor.selection : _options$at6, _options$height = options.height, height = _options$height === void 0 ? 0 : _options$height, _options$always = options.always, always = _options$always === void 0 ? false : _options$always;
            if (match == null) {
                match = function match(n) {
                    return Element.isElement(n) && Editor.isBlock(editor, n);
                };
            }
            if (Range.isRange(at)) {
                at = deleteRange(editor, at);
            } // If the target is a path, the default height-skipping and position
            // counters need to account for us potentially splitting at a non-leaf.
            if (Path.isPath(at)) {
                var path = at;
                var point = Editor.point(editor, path);
                var _Editor$parent3 = Editor.parent(editor, path), _Editor$parent4 = _slicedToArray(_Editor$parent3, 1), parent = _Editor$parent4[0];
                match = function match(n) {
                    return n === parent;
                };
                height = point.path.length - path.length + 1;
                at = point;
                always = true;
            }
            if (!at) {
                return;
            }
            var beforeRef = Editor.pointRef(editor, at, {
                affinity: "backward"
            });
            var afterRef;
            try {
                var _Editor$nodes5 = Editor.nodes(editor, {
                    at: at,
                    match: match,
                    mode: mode,
                    voids: voids
                }), _Editor$nodes6 = _slicedToArray(_Editor$nodes5, 1), highest = _Editor$nodes6[0];
                if (!highest) {
                    return;
                }
                var voidMatch = Editor["void"](editor, {
                    at: at,
                    mode: "highest"
                });
                var nudge = 0;
                if (!voids && voidMatch) {
                    var _voidMatch = _slicedToArray(voidMatch, 2), voidNode = _voidMatch[0], voidPath = _voidMatch[1];
                    if (Element.isElement(voidNode) && editor.isInline(voidNode)) {
                        var after = Editor.after(editor, voidPath);
                        if (!after) {
                            var text = {
                                text: ""
                            };
                            var afterPath = Path.next(voidPath);
                            Transforms.insertNodes(editor, text, {
                                at: afterPath,
                                voids: voids
                            });
                            after = Editor.point(editor, afterPath);
                        }
                        at = after;
                        always = true;
                    }
                    var siblingHeight = at.path.length - voidPath.length;
                    height = siblingHeight + 1;
                    always = true;
                }
                afterRef = Editor.pointRef(editor, at);
                var depth = at.path.length - height;
                var _highest = _slicedToArray(highest, 2), highestPath = _highest[1];
                var lowestPath = at.path.slice(0, depth);
                var position = height === 0 ? at.offset : at.path[depth] + nudge;
                var _iterator3 = _createForOfIteratorHelper$1(Editor.levels(editor, {
                    at: lowestPath,
                    reverse: true,
                    voids: voids
                })), _step3;
                try {
                    for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                        var _step3$value = _slicedToArray(_step3.value, 2), node = _step3$value[0], _path2 = _step3$value[1];
                        var split = false;
                        if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Element.isElement(node) && Editor.isVoid(editor, node)) {
                            break;
                        }
                        var _point2 = beforeRef.current;
                        var isEnd = Editor.isEnd(editor, _point2, _path2);
                        if (always || !beforeRef || !Editor.isEdge(editor, _point2, _path2)) {
                            split = true;
                            var properties = Node.extractProps(node);
                            editor.apply({
                                type: "split_node",
                                path: _path2,
                                position: position,
                                properties: properties
                            });
                        }
                        position = _path2[_path2.length - 1] + (split || isEnd ? 1 : 0);
                    }
                } catch (err) {
                    _iterator3.e(err);
                } finally{
                    _iterator3.f();
                }
                if (options.at == null) {
                    var _point = afterRef.current || Editor.end(editor, []);
                    Transforms.select(editor, _point);
                }
            } finally{
                var _afterRef;
                beforeRef.unref();
                (_afterRef = afterRef) === null || _afterRef === void 0 ? void 0 : _afterRef.unref();
            }
        });
    },
    /**
   * Unset properties on the nodes at a location.
   */ unsetNodes: function unsetNodes(editor, props) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        if (!Array.isArray(props)) {
            props = [
                props
            ];
        }
        var obj = {};
        var _iterator4 = _createForOfIteratorHelper$1(props), _step4;
        try {
            for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                var key = _step4.value;
                obj[key] = null;
            }
        } catch (err) {
            _iterator4.e(err);
        } finally{
            _iterator4.f();
        }
        Transforms.setNodes(editor, obj, options);
    },
    /**
   * Unwrap the nodes at a location from a parent node, splitting the parent if
   * necessary to ensure that only the content in the range is unwrapped.
   */ unwrapNodes: function unwrapNodes(editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        Editor.withoutNormalizing(editor, function() {
            var _options$mode8 = options.mode, mode = _options$mode8 === void 0 ? "lowest" : _options$mode8, _options$split2 = options.split, split = _options$split2 === void 0 ? false : _options$split2, _options$voids8 = options.voids, voids = _options$voids8 === void 0 ? false : _options$voids8;
            var _options$at7 = options.at, at = _options$at7 === void 0 ? editor.selection : _options$at7, match = options.match;
            if (!at) {
                return;
            }
            if (match == null) {
                match = Path.isPath(at) ? matchPath(editor, at) : function(n) {
                    return Element.isElement(n) && Editor.isBlock(editor, n);
                };
            }
            if (Path.isPath(at)) {
                at = Editor.range(editor, at);
            }
            var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;
            var matches = Editor.nodes(editor, {
                at: at,
                match: match,
                mode: mode,
                voids: voids
            });
            var pathRefs = Array.from(matches, function(_ref9) {
                var _ref10 = _slicedToArray(_ref9, 2), p = _ref10[1];
                return Editor.pathRef(editor, p);
            } // unwrapNode will call liftNode which does not support splitting the node when nested.
            ).reverse();
            var _iterator5 = _createForOfIteratorHelper$1(pathRefs), _step5;
            try {
                var _loop = function _loop() {
                    var pathRef = _step5.value;
                    var path = pathRef.unref();
                    var _Editor$node3 = Editor.node(editor, path), _Editor$node4 = _slicedToArray(_Editor$node3, 1), node = _Editor$node4[0];
                    var range = Editor.range(editor, path);
                    if (split && rangeRef) {
                        range = Range.intersection(rangeRef.current, range);
                    }
                    Transforms.liftNodes(editor, {
                        at: range,
                        match: function match(n) {
                            return Element.isAncestor(node) && node.children.includes(n);
                        },
                        voids: voids
                    });
                };
                for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){
                    _loop();
                }
            } catch (err) {
                _iterator5.e(err);
            } finally{
                _iterator5.f();
            }
            if (rangeRef) {
                rangeRef.unref();
            }
        });
    },
    /**
   * Wrap the nodes at a location in a new container node, splitting the edges
   * of the range first to ensure that only the content in the range is wrapped.
   */ wrapNodes: function wrapNodes(editor, element) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        Editor.withoutNormalizing(editor, function() {
            var _options$mode9 = options.mode, mode = _options$mode9 === void 0 ? "lowest" : _options$mode9, _options$split3 = options.split, split = _options$split3 === void 0 ? false : _options$split3, _options$voids9 = options.voids, voids = _options$voids9 === void 0 ? false : _options$voids9;
            var match = options.match, _options$at8 = options.at, at = _options$at8 === void 0 ? editor.selection : _options$at8;
            if (!at) {
                return;
            }
            if (match == null) {
                if (Path.isPath(at)) {
                    match = matchPath(editor, at);
                } else if (editor.isInline(element)) {
                    match = function match(n) {
                        return Element.isElement(n) && Editor.isInline(editor, n) || Text.isText(n);
                    };
                } else {
                    match = function match(n) {
                        return Element.isElement(n) && Editor.isBlock(editor, n);
                    };
                }
            }
            if (split && Range.isRange(at)) {
                var _Range$edges7 = Range.edges(at), _Range$edges8 = _slicedToArray(_Range$edges7, 2), start = _Range$edges8[0], end = _Range$edges8[1];
                var rangeRef = Editor.rangeRef(editor, at, {
                    affinity: "inward"
                });
                Transforms.splitNodes(editor, {
                    at: end,
                    match: match,
                    voids: voids
                });
                Transforms.splitNodes(editor, {
                    at: start,
                    match: match,
                    voids: voids
                });
                at = rangeRef.unref();
                if (options.at == null) {
                    Transforms.select(editor, at);
                }
            }
            var roots = Array.from(Editor.nodes(editor, {
                at: at,
                match: editor.isInline(element) ? function(n) {
                    return Element.isElement(n) && Editor.isBlock(editor, n);
                } : function(n) {
                    return Editor.isEditor(n);
                },
                mode: "lowest",
                voids: voids
            }));
            for(var _i4 = 0, _roots = roots; _i4 < _roots.length; _i4++){
                var _roots$_i = _slicedToArray(_roots[_i4], 2), rootPath = _roots$_i[1];
                var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;
                if (!a) {
                    continue;
                }
                var matches = Array.from(Editor.nodes(editor, {
                    at: a,
                    match: match,
                    mode: mode,
                    voids: voids
                }));
                if (matches.length > 0) {
                    var _ret = function() {
                        var _matches = _slicedToArray(matches, 1), first = _matches[0];
                        var last = matches[matches.length - 1];
                        var _first = _slicedToArray(first, 2), firstPath = _first[1];
                        var _last = _slicedToArray(last, 2), lastPath = _last[1];
                        if (firstPath.length === 0 && lastPath.length === 0) {
                            // if there's no matching parent - usually means the node is an editor - don't do anything
                            return "continue";
                        }
                        var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);
                        var range = Editor.range(editor, firstPath, lastPath);
                        var commonNodeEntry = Editor.node(editor, commonPath);
                        var _commonNodeEntry = _slicedToArray(commonNodeEntry, 1), commonNode = _commonNodeEntry[0];
                        var depth = commonPath.length + 1;
                        var wrapperPath = Path.next(lastPath.slice(0, depth));
                        var wrapper = _objectSpread$2(_objectSpread$2({}, element), {}, {
                            children: []
                        });
                        Transforms.insertNodes(editor, wrapper, {
                            at: wrapperPath,
                            voids: voids
                        });
                        Transforms.moveNodes(editor, {
                            at: range,
                            match: function match(n) {
                                return Element.isAncestor(commonNode) && commonNode.children.includes(n);
                            },
                            to: wrapperPath.concat(0),
                            voids: voids
                        });
                    }();
                    if (_ret === "continue") continue;
                }
            }
        });
    }
};
var hasSingleChildNest = function hasSingleChildNest(editor, node) {
    if (Element.isElement(node)) {
        var element = node;
        if (Editor.isVoid(editor, node)) {
            return true;
        } else if (element.children.length === 1) {
            return hasSingleChildNest(editor, element.children[0]);
        } else {
            return false;
        }
    } else if (Editor.isEditor(node)) {
        return false;
    } else {
        return true;
    }
};
/**
 * Convert a range into a point by deleting it's content.
 */ var deleteRange = function deleteRange(editor, range) {
    if (Range.isCollapsed(range)) {
        return range.anchor;
    } else {
        var _Range$edges9 = Range.edges(range), _Range$edges10 = _slicedToArray(_Range$edges9, 2), end = _Range$edges10[1];
        var pointRef = Editor.pointRef(editor, end);
        Transforms["delete"](editor, {
            at: range
        });
        return pointRef.unref();
    }
};
var matchPath = function matchPath(editor, path) {
    var _Editor$node5 = Editor.node(editor, path), _Editor$node6 = _slicedToArray(_Editor$node5, 1), node = _Editor$node6[0];
    return function(n) {
        return n === node;
    };
};
function ownKeys$1(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread$1(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys$1(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys$1(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}
var SelectionTransforms = {
    /**
   * Collapse the selection.
   */ collapse: function collapse(editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var _options$edge = options.edge, edge = _options$edge === void 0 ? "anchor" : _options$edge;
        var selection = editor.selection;
        if (!selection) {
            return;
        } else if (edge === "anchor") {
            Transforms.select(editor, selection.anchor);
        } else if (edge === "focus") {
            Transforms.select(editor, selection.focus);
        } else if (edge === "start") {
            var _Range$edges = Range.edges(selection), _Range$edges2 = _slicedToArray(_Range$edges, 1), start = _Range$edges2[0];
            Transforms.select(editor, start);
        } else if (edge === "end") {
            var _Range$edges3 = Range.edges(selection), _Range$edges4 = _slicedToArray(_Range$edges3, 2), end = _Range$edges4[1];
            Transforms.select(editor, end);
        }
    },
    /**
   * Unset the selection.
   */ deselect: function deselect(editor) {
        var selection = editor.selection;
        if (selection) {
            editor.apply({
                type: "set_selection",
                properties: selection,
                newProperties: null
            });
        }
    },
    /**
   * Move the selection's point forward or backward.
   */ move: function move(editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var selection = editor.selection;
        var _options$distance = options.distance, distance = _options$distance === void 0 ? 1 : _options$distance, _options$unit = options.unit, unit = _options$unit === void 0 ? "character" : _options$unit, _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse;
        var _options$edge2 = options.edge, edge = _options$edge2 === void 0 ? null : _options$edge2;
        if (!selection) {
            return;
        }
        if (edge === "start") {
            edge = Range.isBackward(selection) ? "focus" : "anchor";
        }
        if (edge === "end") {
            edge = Range.isBackward(selection) ? "anchor" : "focus";
        }
        var anchor = selection.anchor, focus = selection.focus;
        var opts = {
            distance: distance,
            unit: unit
        };
        var props = {};
        if (edge == null || edge === "anchor") {
            var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);
            if (point) {
                props.anchor = point;
            }
        }
        if (edge == null || edge === "focus") {
            var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);
            if (_point) {
                props.focus = _point;
            }
        }
        Transforms.setSelection(editor, props);
    },
    /**
   * Set the selection to a new value.
   */ select: function select(editor, target) {
        var selection = editor.selection;
        target = Editor.range(editor, target);
        if (selection) {
            Transforms.setSelection(editor, target);
            return;
        }
        if (!Range.isRange(target)) {
            throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(Scrubber.stringify(target)));
        }
        editor.apply({
            type: "set_selection",
            properties: selection,
            newProperties: target
        });
    },
    /**
   * Set new properties on one of the selection's points.
   */ setPoint: function setPoint(editor, props) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var selection = editor.selection;
        var _options$edge3 = options.edge, edge = _options$edge3 === void 0 ? "both" : _options$edge3;
        if (!selection) {
            return;
        }
        if (edge === "start") {
            edge = Range.isBackward(selection) ? "focus" : "anchor";
        }
        if (edge === "end") {
            edge = Range.isBackward(selection) ? "anchor" : "focus";
        }
        var anchor = selection.anchor, focus = selection.focus;
        var point = edge === "anchor" ? anchor : focus;
        Transforms.setSelection(editor, _defineProperty({}, edge === "anchor" ? "anchor" : "focus", _objectSpread$1(_objectSpread$1({}, point), props)));
    },
    /**
   * Set new properties on the selection.
   */ setSelection: function setSelection(editor, props) {
        var selection = editor.selection;
        var oldProps = {};
        var newProps = {};
        if (!selection) {
            return;
        }
        for(var k in props){
            if (k === "anchor" && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === "focus" && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== "anchor" && k !== "focus" && props[k] !== selection[k]) {
                oldProps[k] = selection[k];
                newProps[k] = props[k];
            }
        }
        if (Object.keys(oldProps).length > 0) {
            editor.apply({
                type: "set_selection",
                properties: oldProps,
                newProperties: newProps
            });
        }
    }
};
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = it.call(o);
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it["return"] != null) it["return"]();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++){
        arr2[i] = arr[i];
    }
    return arr2;
}
var TextTransforms = {
    /**
   * Delete content in the editor.
   */ "delete": function _delete(editor) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        Editor.withoutNormalizing(editor, function() {
            var _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse, _options$unit = options.unit, unit = _options$unit === void 0 ? "character" : _options$unit, _options$distance = options.distance, distance = _options$distance === void 0 ? 1 : _options$distance, _options$voids = options.voids, voids = _options$voids === void 0 ? false : _options$voids;
            var _options$at = options.at, at = _options$at === void 0 ? editor.selection : _options$at, _options$hanging = options.hanging, hanging = _options$hanging === void 0 ? false : _options$hanging;
            if (!at) {
                return;
            }
            var isCollapsed = false;
            if (Range.isRange(at) && Range.isCollapsed(at)) {
                isCollapsed = true;
                at = at.anchor;
            }
            if (Point.isPoint(at)) {
                var furthestVoid = Editor["void"](editor, {
                    at: at,
                    mode: "highest"
                });
                if (!voids && furthestVoid) {
                    var _furthestVoid = _slicedToArray(furthestVoid, 2), voidPath = _furthestVoid[1];
                    at = voidPath;
                } else {
                    var opts = {
                        unit: unit,
                        distance: distance
                    };
                    var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);
                    at = {
                        anchor: at,
                        focus: target
                    };
                    hanging = true;
                }
            }
            if (Path.isPath(at)) {
                Transforms.removeNodes(editor, {
                    at: at,
                    voids: voids
                });
                return;
            }
            if (Range.isCollapsed(at)) {
                return;
            }
            if (!hanging) {
                var _Range$edges = Range.edges(at), _Range$edges2 = _slicedToArray(_Range$edges, 2), _end = _Range$edges2[1];
                var endOfDoc = Editor.end(editor, []);
                if (!Point.equals(_end, endOfDoc)) {
                    at = Editor.unhangRange(editor, at, {
                        voids: voids
                    });
                }
            }
            var _Range$edges3 = Range.edges(at), _Range$edges4 = _slicedToArray(_Range$edges3, 2), start = _Range$edges4[0], end = _Range$edges4[1];
            var startBlock = Editor.above(editor, {
                match: function match(n) {
                    return Element.isElement(n) && Editor.isBlock(editor, n);
                },
                at: start,
                voids: voids
            });
            var endBlock = Editor.above(editor, {
                match: function match(n) {
                    return Element.isElement(n) && Editor.isBlock(editor, n);
                },
                at: end,
                voids: voids
            });
            var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);
            var isSingleText = Path.equals(start.path, end.path);
            var startVoid = voids ? null : Editor["void"](editor, {
                at: start,
                mode: "highest"
            });
            var endVoid = voids ? null : Editor["void"](editor, {
                at: end,
                mode: "highest"
            }); // If the start or end points are inside an inline void, nudge them out.
            if (startVoid) {
                var before = Editor.before(editor, start);
                if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {
                    start = before;
                }
            }
            if (endVoid) {
                var after = Editor.after(editor, end);
                if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {
                    end = after;
                }
            } // Get the highest nodes that are completely inside the range, as well as
            // the start and end nodes.
            var matches = [];
            var lastPath;
            var _iterator = _createForOfIteratorHelper(Editor.nodes(editor, {
                at: at,
                voids: voids
            })), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var entry = _step.value;
                    var _entry = _slicedToArray(entry, 2), _node2 = _entry[0], _path2 = _entry[1];
                    if (lastPath && Path.compare(_path2, lastPath) === 0) {
                        continue;
                    }
                    if (!voids && Element.isElement(_node2) && Editor.isVoid(editor, _node2) || !Path.isCommon(_path2, start.path) && !Path.isCommon(_path2, end.path)) {
                        matches.push(entry);
                        lastPath = _path2;
                    }
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            var pathRefs = Array.from(matches, function(_ref) {
                var _ref2 = _slicedToArray(_ref, 2), p = _ref2[1];
                return Editor.pathRef(editor, p);
            });
            var startRef = Editor.pointRef(editor, start);
            var endRef = Editor.pointRef(editor, end);
            var removedText = "";
            if (!isSingleText && !startVoid) {
                var _point = startRef.current;
                var _Editor$leaf = Editor.leaf(editor, _point), _Editor$leaf2 = _slicedToArray(_Editor$leaf, 1), node = _Editor$leaf2[0];
                var path = _point.path;
                var _start = start, offset = _start.offset;
                var text = node.text.slice(offset);
                if (text.length > 0) {
                    editor.apply({
                        type: "remove_text",
                        path: path,
                        offset: offset,
                        text: text
                    });
                    removedText = text;
                }
            }
            pathRefs.reverse().map(function(r) {
                return r.unref();
            }).filter(function(r) {
                return r !== null;
            }).forEach(function(p) {
                return Transforms.removeNodes(editor, {
                    at: p,
                    voids: voids
                });
            });
            if (!endVoid) {
                var _point2 = endRef.current;
                var _Editor$leaf3 = Editor.leaf(editor, _point2), _Editor$leaf4 = _slicedToArray(_Editor$leaf3, 1), _node = _Editor$leaf4[0];
                var _path = _point2.path;
                var _offset = isSingleText ? start.offset : 0;
                var _text = _node.text.slice(_offset, end.offset);
                if (_text.length > 0) {
                    editor.apply({
                        type: "remove_text",
                        path: _path,
                        offset: _offset,
                        text: _text
                    });
                    removedText = _text;
                }
            }
            if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {
                Transforms.mergeNodes(editor, {
                    at: endRef.current,
                    hanging: true,
                    voids: voids
                });
            } // For Thai script, deleting N character(s) backward should delete
            // N code point(s) instead of an entire grapheme cluster.
            // Therefore, the remaining code points should be inserted back.
            if (isCollapsed && reverse && unit === "character" && removedText.length > 1 && removedText.match(/[\u0E00-\u0E7F]+/)) {
                Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));
            }
            var startUnref = startRef.unref();
            var endUnref = endRef.unref();
            var point = reverse ? startUnref || endUnref : endUnref || startUnref;
            if (options.at == null && point) {
                Transforms.select(editor, point);
            }
        });
    },
    /**
   * Insert a fragment at a specific location in the editor.
   */ insertFragment: function insertFragment(editor, fragment) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        Editor.withoutNormalizing(editor, function() {
            var _options$hanging2 = options.hanging, hanging = _options$hanging2 === void 0 ? false : _options$hanging2, _options$voids2 = options.voids, voids = _options$voids2 === void 0 ? false : _options$voids2;
            var _options$at2 = options.at, at = _options$at2 === void 0 ? editor.selection : _options$at2;
            if (!fragment.length) {
                return;
            }
            if (!at) {
                return;
            } else if (Range.isRange(at)) {
                if (!hanging) {
                    at = Editor.unhangRange(editor, at, {
                        voids: voids
                    });
                }
                if (Range.isCollapsed(at)) {
                    at = at.anchor;
                } else {
                    var _Range$edges5 = Range.edges(at), _Range$edges6 = _slicedToArray(_Range$edges5, 2), end = _Range$edges6[1];
                    if (!voids && Editor["void"](editor, {
                        at: end
                    })) {
                        return;
                    }
                    var pointRef = Editor.pointRef(editor, end);
                    Transforms["delete"](editor, {
                        at: at
                    });
                    at = pointRef.unref();
                }
            } else if (Path.isPath(at)) {
                at = Editor.start(editor, at);
            }
            if (!voids && Editor["void"](editor, {
                at: at
            })) {
                return;
            } // If the insert point is at the edge of an inline node, move it outside
            // instead since it will need to be split otherwise.
            var inlineElementMatch = Editor.above(editor, {
                at: at,
                match: function match(n) {
                    return Element.isElement(n) && Editor.isInline(editor, n);
                },
                mode: "highest",
                voids: voids
            });
            if (inlineElementMatch) {
                var _inlineElementMatch = _slicedToArray(inlineElementMatch, 2), _inlinePath = _inlineElementMatch[1];
                if (Editor.isEnd(editor, at, _inlinePath)) {
                    var after = Editor.after(editor, _inlinePath);
                    at = after;
                } else if (Editor.isStart(editor, at, _inlinePath)) {
                    var before = Editor.before(editor, _inlinePath);
                    at = before;
                }
            }
            var blockMatch = Editor.above(editor, {
                match: function match(n) {
                    return Element.isElement(n) && Editor.isBlock(editor, n);
                },
                at: at,
                voids: voids
            });
            var _blockMatch = _slicedToArray(blockMatch, 2), blockPath = _blockMatch[1];
            var isBlockStart = Editor.isStart(editor, at, blockPath);
            var isBlockEnd = Editor.isEnd(editor, at, blockPath);
            var isBlockEmpty = isBlockStart && isBlockEnd;
            var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;
            var mergeEnd = !isBlockEnd;
            var _Node$first = Node.first({
                children: fragment
            }, []), _Node$first2 = _slicedToArray(_Node$first, 2), firstPath = _Node$first2[1];
            var _Node$last = Node.last({
                children: fragment
            }, []), _Node$last2 = _slicedToArray(_Node$last, 2), lastPath = _Node$last2[1];
            var matches = [];
            var matcher = function matcher(_ref3) {
                var _ref4 = _slicedToArray(_ref3, 2), n = _ref4[0], p = _ref4[1];
                var isRoot = p.length === 0;
                if (isRoot) {
                    return false;
                }
                if (isBlockEmpty) {
                    return true;
                }
                if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {
                    return false;
                }
                if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {
                    return false;
                }
                return true;
            };
            var _iterator2 = _createForOfIteratorHelper(Node.nodes({
                children: fragment
            }, {
                pass: matcher
            })), _step2;
            try {
                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                    var entry = _step2.value;
                    if (matcher(entry)) {
                        matches.push(entry);
                    }
                }
            } catch (err) {
                _iterator2.e(err);
            } finally{
                _iterator2.f();
            }
            var starts = [];
            var middles = [];
            var ends = [];
            var starting = true;
            var hasBlocks = false;
            for(var _i = 0, _matches = matches; _i < _matches.length; _i++){
                var _matches$_i = _slicedToArray(_matches[_i], 1), node = _matches$_i[0];
                if (Element.isElement(node) && !editor.isInline(node)) {
                    starting = false;
                    hasBlocks = true;
                    middles.push(node);
                } else if (starting) {
                    starts.push(node);
                } else {
                    ends.push(node);
                }
            }
            var _Editor$nodes = Editor.nodes(editor, {
                at: at,
                match: function match(n) {
                    return Text.isText(n) || Editor.isInline(editor, n);
                },
                mode: "highest",
                voids: voids
            }), _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1), inlineMatch = _Editor$nodes2[0];
            var _inlineMatch = _slicedToArray(inlineMatch, 2), inlinePath = _inlineMatch[1];
            var isInlineStart = Editor.isStart(editor, at, inlinePath);
            var isInlineEnd = Editor.isEnd(editor, at, inlinePath);
            var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);
            var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);
            Transforms.splitNodes(editor, {
                at: at,
                match: function match(n) {
                    return hasBlocks ? Element.isElement(n) && Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n);
                },
                mode: hasBlocks ? "lowest" : "highest",
                always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),
                voids: voids
            });
            var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);
            Transforms.insertNodes(editor, starts, {
                at: startRef.current,
                match: function match(n) {
                    return Text.isText(n) || Editor.isInline(editor, n);
                },
                mode: "highest",
                voids: voids
            });
            if (isBlockEmpty && !starts.length && middles.length && !ends.length) {
                Transforms["delete"](editor, {
                    at: blockPath,
                    voids: voids
                });
            }
            Transforms.insertNodes(editor, middles, {
                at: middleRef.current,
                match: function match(n) {
                    return Element.isElement(n) && Editor.isBlock(editor, n);
                },
                mode: "lowest",
                voids: voids
            });
            Transforms.insertNodes(editor, ends, {
                at: endRef.current,
                match: function match(n) {
                    return Text.isText(n) || Editor.isInline(editor, n);
                },
                mode: "highest",
                voids: voids
            });
            if (!options.at) {
                var path;
                if (ends.length > 0 && endRef.current) {
                    path = Path.previous(endRef.current);
                } else if (middles.length > 0 && middleRef.current) {
                    path = Path.previous(middleRef.current);
                } else if (startRef.current) {
                    path = Path.previous(startRef.current);
                }
                if (path) {
                    var _end2 = Editor.end(editor, path);
                    Transforms.select(editor, _end2);
                }
            }
            startRef.unref();
            middleRef.unref();
            endRef.unref();
        });
    },
    /**
   * Insert a string of text in the Editor.
   */ insertText: function insertText(editor, text) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        Editor.withoutNormalizing(editor, function() {
            var _options$voids3 = options.voids, voids = _options$voids3 === void 0 ? false : _options$voids3;
            var _options$at3 = options.at, at = _options$at3 === void 0 ? editor.selection : _options$at3;
            if (!at) {
                return;
            }
            if (Path.isPath(at)) {
                at = Editor.range(editor, at);
            }
            if (Range.isRange(at)) {
                if (Range.isCollapsed(at)) {
                    at = at.anchor;
                } else {
                    var end = Range.end(at);
                    if (!voids && Editor["void"](editor, {
                        at: end
                    })) {
                        return;
                    }
                    var start = Range.start(at);
                    var startRef = Editor.pointRef(editor, start);
                    var endRef = Editor.pointRef(editor, end);
                    Transforms["delete"](editor, {
                        at: at,
                        voids: voids
                    });
                    var startPoint = startRef.unref();
                    var endPoint = endRef.unref();
                    at = startPoint || endPoint;
                    Transforms.setSelection(editor, {
                        anchor: at,
                        focus: at
                    });
                }
            }
            if (!voids && Editor["void"](editor, {
                at: at
            })) {
                return;
            }
            var _at = at, path = _at.path, offset = _at.offset;
            if (text.length > 0) editor.apply({
                type: "insert_text",
                path: path,
                offset: offset,
                text: text
            });
        });
    }
};
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
                _defineProperty(target, key, source[key]);
            });
        } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
            ownKeys(Object(source)).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
        }
    }
    return target;
}
var Transforms = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);
exports.ML = Editor;
exports.W_ = Element;
__webpack_unused_export__ = Location;
exports.NB = Node;
__webpack_unused_export__ = Operation;
exports.y$ = Path;
__webpack_unused_export__ = PathRef;
exports.E9 = Point;
__webpack_unused_export__ = PointRef;
exports.e6 = Range;
__webpack_unused_export__ = RangeRef;
__webpack_unused_export__ = Scrubber;
__webpack_unused_export__ = Span;
exports.xv = Text;
exports.YR = Transforms;
exports.Jh = createEditor; //# sourceMappingURL=index.js.map


/***/ })

};
;